// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: models.proto

#ifndef PROTOBUF_models_2eproto__INCLUDED
#define PROTOBUF_models_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace eos {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_models_2eproto();
void protobuf_AssignDesc_models_2eproto();
void protobuf_ShutdownFile_models_2eproto();

class GetTimestamps;
class Timestamps;
class Zone;
class Zone_Point;
class Zones;
class JSONSettings;
class Settings;
class Range;
class Sensor;
class Sensor_Point;
class Sensors;
class Patrol;
class Patrol_Position;
class Patrol_Point;
class Patrols;
class Map;
class TaskScheduled;
class TasksScheduled;

enum Zone_Permission {
  Zone_Permission_Nothing = 0,
  Zone_Permission_NoDetection = 1,
  Zone_Permission_NoMovement = 2,
  Zone_Permission_NoRemapping = 3,
  Zone_Permission_Map = 4
};
bool Zone_Permission_IsValid(int value);
const Zone_Permission Zone_Permission_Permission_MIN = Zone_Permission_Nothing;
const Zone_Permission Zone_Permission_Permission_MAX = Zone_Permission_Map;
const int Zone_Permission_Permission_ARRAYSIZE = Zone_Permission_Permission_MAX + 1;

const ::google::protobuf::EnumDescriptor* Zone_Permission_descriptor();
inline const ::std::string& Zone_Permission_Name(Zone_Permission value) {
  return ::google::protobuf::internal::NameOfEnum(
    Zone_Permission_descriptor(), value);
}
inline bool Zone_Permission_Parse(
    const ::std::string& name, Zone_Permission* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Zone_Permission>(
    Zone_Permission_descriptor(), name, value);
}
enum Sensor_Type {
  Sensor_Type_RobotDock = 0,
  Sensor_Type_DoorSwitch = 1,
  Sensor_Type_Radar = 2,
  Sensor_Type_InfraredBarrier = 3,
  Sensor_Type_Rack = 4
};
bool Sensor_Type_IsValid(int value);
const Sensor_Type Sensor_Type_Type_MIN = Sensor_Type_RobotDock;
const Sensor_Type Sensor_Type_Type_MAX = Sensor_Type_Rack;
const int Sensor_Type_Type_ARRAYSIZE = Sensor_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Sensor_Type_descriptor();
inline const ::std::string& Sensor_Type_Name(Sensor_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Sensor_Type_descriptor(), value);
}
inline bool Sensor_Type_Parse(
    const ::std::string& name, Sensor_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Sensor_Type>(
    Sensor_Type_descriptor(), name, value);
}
enum Patrol_Type {
  Patrol_Type_Normal = 0,
  Patrol_Type_PopOut = 1,
  Patrol_Type_Remapping = 2,
  Patrol_Type_Refill = 3
};
bool Patrol_Type_IsValid(int value);
const Patrol_Type Patrol_Type_Type_MIN = Patrol_Type_Normal;
const Patrol_Type Patrol_Type_Type_MAX = Patrol_Type_Refill;
const int Patrol_Type_Type_ARRAYSIZE = Patrol_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Patrol_Type_descriptor();
inline const ::std::string& Patrol_Type_Name(Patrol_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Patrol_Type_descriptor(), value);
}
inline bool Patrol_Type_Parse(
    const ::std::string& name, Patrol_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Patrol_Type>(
    Patrol_Type_descriptor(), name, value);
}
enum Patrol_Priority {
  Patrol_Priority_Standard = 0,
  Patrol_Priority_High = 1
};
bool Patrol_Priority_IsValid(int value);
const Patrol_Priority Patrol_Priority_Priority_MIN = Patrol_Priority_Standard;
const Patrol_Priority Patrol_Priority_Priority_MAX = Patrol_Priority_High;
const int Patrol_Priority_Priority_ARRAYSIZE = Patrol_Priority_Priority_MAX + 1;

const ::google::protobuf::EnumDescriptor* Patrol_Priority_descriptor();
inline const ::std::string& Patrol_Priority_Name(Patrol_Priority value) {
  return ::google::protobuf::internal::NameOfEnum(
    Patrol_Priority_descriptor(), value);
}
inline bool Patrol_Priority_Parse(
    const ::std::string& name, Patrol_Priority* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Patrol_Priority>(
    Patrol_Priority_descriptor(), name, value);
}
enum Map_Type {
  Map_Type_BASE_MAP = 0,
  Map_Type_REMAP_MAP = 1,
  Map_Type_DISPLAY_MAP = 2
};
bool Map_Type_IsValid(int value);
const Map_Type Map_Type_Type_MIN = Map_Type_BASE_MAP;
const Map_Type Map_Type_Type_MAX = Map_Type_DISPLAY_MAP;
const int Map_Type_Type_ARRAYSIZE = Map_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Map_Type_descriptor();
inline const ::std::string& Map_Type_Name(Map_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Map_Type_descriptor(), value);
}
inline bool Map_Type_Parse(
    const ::std::string& name, Map_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Map_Type>(
    Map_Type_descriptor(), name, value);
}
// ===================================================================

class GetTimestamps : public ::google::protobuf::Message {
 public:
  GetTimestamps();
  virtual ~GetTimestamps();

  GetTimestamps(const GetTimestamps& from);

  inline GetTimestamps& operator=(const GetTimestamps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTimestamps& default_instance();

  void Swap(GetTimestamps* other);

  // implements Message ----------------------------------------------

  GetTimestamps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTimestamps& from);
  void MergeFrom(const GetTimestamps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eos.GetTimestamps)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static GetTimestamps* default_instance_;
};
// -------------------------------------------------------------------

class Timestamps : public ::google::protobuf::Message {
 public:
  Timestamps();
  virtual ~Timestamps();

  Timestamps(const Timestamps& from);

  inline Timestamps& operator=(const Timestamps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Timestamps& default_instance();

  void Swap(Timestamps* other);

  // implements Message ----------------------------------------------

  Timestamps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Timestamps& from);
  void MergeFrom(const Timestamps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 base_map = 1;
  inline bool has_base_map() const;
  inline void clear_base_map();
  static const int kBaseMapFieldNumber = 1;
  inline ::google::protobuf::uint64 base_map() const;
  inline void set_base_map(::google::protobuf::uint64 value);

  // required uint64 static_map = 2;
  inline bool has_static_map() const;
  inline void clear_static_map();
  static const int kStaticMapFieldNumber = 2;
  inline ::google::protobuf::uint64 static_map() const;
  inline void set_static_map(::google::protobuf::uint64 value);

  // required uint64 display_map = 3;
  inline bool has_display_map() const;
  inline void clear_display_map();
  static const int kDisplayMapFieldNumber = 3;
  inline ::google::protobuf::uint64 display_map() const;
  inline void set_display_map(::google::protobuf::uint64 value);

  // required uint64 patrols = 4;
  inline bool has_patrols() const;
  inline void clear_patrols();
  static const int kPatrolsFieldNumber = 4;
  inline ::google::protobuf::uint64 patrols() const;
  inline void set_patrols(::google::protobuf::uint64 value);

  // required uint64 zones = 5;
  inline bool has_zones() const;
  inline void clear_zones();
  static const int kZonesFieldNumber = 5;
  inline ::google::protobuf::uint64 zones() const;
  inline void set_zones(::google::protobuf::uint64 value);

  // required uint64 sensors = 6;
  inline bool has_sensors() const;
  inline void clear_sensors();
  static const int kSensorsFieldNumber = 6;
  inline ::google::protobuf::uint64 sensors() const;
  inline void set_sensors(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:eos.Timestamps)
 private:
  inline void set_has_base_map();
  inline void clear_has_base_map();
  inline void set_has_static_map();
  inline void clear_has_static_map();
  inline void set_has_display_map();
  inline void clear_has_display_map();
  inline void set_has_patrols();
  inline void clear_has_patrols();
  inline void set_has_zones();
  inline void clear_has_zones();
  inline void set_has_sensors();
  inline void clear_has_sensors();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 base_map_;
  ::google::protobuf::uint64 static_map_;
  ::google::protobuf::uint64 display_map_;
  ::google::protobuf::uint64 patrols_;
  ::google::protobuf::uint64 zones_;
  ::google::protobuf::uint64 sensors_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Timestamps* default_instance_;
};
// -------------------------------------------------------------------

class Zone_Point : public ::google::protobuf::Message {
 public:
  Zone_Point();
  virtual ~Zone_Point();

  Zone_Point(const Zone_Point& from);

  inline Zone_Point& operator=(const Zone_Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Zone_Point& default_instance();

  void Swap(Zone_Point* other);

  // implements Message ----------------------------------------------

  Zone_Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Zone_Point& from);
  void MergeFrom(const Zone_Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eos.Zone.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Zone_Point* default_instance_;
};
// -------------------------------------------------------------------

class Zone : public ::google::protobuf::Message {
 public:
  Zone();
  virtual ~Zone();

  Zone(const Zone& from);

  inline Zone& operator=(const Zone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Zone& default_instance();

  void Swap(Zone* other);

  // implements Message ----------------------------------------------

  Zone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Zone& from);
  void MergeFrom(const Zone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Zone_Point Point;

  typedef Zone_Permission Permission;
  static const Permission Nothing = Zone_Permission_Nothing;
  static const Permission NoDetection = Zone_Permission_NoDetection;
  static const Permission NoMovement = Zone_Permission_NoMovement;
  static const Permission NoRemapping = Zone_Permission_NoRemapping;
  static const Permission Map = Zone_Permission_Map;
  static inline bool Permission_IsValid(int value) {
    return Zone_Permission_IsValid(value);
  }
  static const Permission Permission_MIN =
    Zone_Permission_Permission_MIN;
  static const Permission Permission_MAX =
    Zone_Permission_Permission_MAX;
  static const int Permission_ARRAYSIZE =
    Zone_Permission_Permission_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Permission_descriptor() {
    return Zone_Permission_descriptor();
  }
  static inline const ::std::string& Permission_Name(Permission value) {
    return Zone_Permission_Name(value);
  }
  static inline bool Permission_Parse(const ::std::string& name,
      Permission* value) {
    return Zone_Permission_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .eos.Zone.Point top_left = 1;
  inline bool has_top_left() const;
  inline void clear_top_left();
  static const int kTopLeftFieldNumber = 1;
  inline const ::eos::Zone_Point& top_left() const;
  inline ::eos::Zone_Point* mutable_top_left();
  inline ::eos::Zone_Point* release_top_left();
  inline void set_allocated_top_left(::eos::Zone_Point* top_left);

  // required .eos.Zone.Point bottom_right = 2;
  inline bool has_bottom_right() const;
  inline void clear_bottom_right();
  static const int kBottomRightFieldNumber = 2;
  inline const ::eos::Zone_Point& bottom_right() const;
  inline ::eos::Zone_Point* mutable_bottom_right();
  inline ::eos::Zone_Point* release_bottom_right();
  inline void set_allocated_bottom_right(::eos::Zone_Point* bottom_right);

  // required .eos.Zone.Permission permissions = 3 [default = NoDetection];
  inline bool has_permissions() const;
  inline void clear_permissions();
  static const int kPermissionsFieldNumber = 3;
  inline ::eos::Zone_Permission permissions() const;
  inline void set_permissions(::eos::Zone_Permission value);

  // @@protoc_insertion_point(class_scope:eos.Zone)
 private:
  inline void set_has_top_left();
  inline void clear_has_top_left();
  inline void set_has_bottom_right();
  inline void clear_has_bottom_right();
  inline void set_has_permissions();
  inline void clear_has_permissions();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::eos::Zone_Point* top_left_;
  ::eos::Zone_Point* bottom_right_;
  int permissions_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Zone* default_instance_;
};
// -------------------------------------------------------------------

class Zones : public ::google::protobuf::Message {
 public:
  Zones();
  virtual ~Zones();

  Zones(const Zones& from);

  inline Zones& operator=(const Zones& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Zones& default_instance();

  void Swap(Zones* other);

  // implements Message ----------------------------------------------

  Zones* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Zones& from);
  void MergeFrom(const Zones& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp = 1 [default = 0];
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // repeated .eos.Zone zones = 2;
  inline int zones_size() const;
  inline void clear_zones();
  static const int kZonesFieldNumber = 2;
  inline const ::eos::Zone& zones(int index) const;
  inline ::eos::Zone* mutable_zones(int index);
  inline ::eos::Zone* add_zones();
  inline const ::google::protobuf::RepeatedPtrField< ::eos::Zone >&
      zones() const;
  inline ::google::protobuf::RepeatedPtrField< ::eos::Zone >*
      mutable_zones();

  // @@protoc_insertion_point(class_scope:eos.Zones)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::eos::Zone > zones_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Zones* default_instance_;
};
// -------------------------------------------------------------------

class JSONSettings : public ::google::protobuf::Message {
 public:
  JSONSettings();
  virtual ~JSONSettings();

  JSONSettings(const JSONSettings& from);

  inline JSONSettings& operator=(const JSONSettings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JSONSettings& default_instance();

  void Swap(JSONSettings* other);

  // implements Message ----------------------------------------------

  JSONSettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JSONSettings& from);
  void MergeFrom(const JSONSettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string keys = 1;
  inline bool has_keys() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys() const;
  inline void set_keys(const ::std::string& value);
  inline void set_keys(const char* value);
  inline void set_keys(const char* value, size_t size);
  inline ::std::string* mutable_keys();
  inline ::std::string* release_keys();
  inline void set_allocated_keys(::std::string* keys);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:eos.JSONSettings)
 private:
  inline void set_has_keys();
  inline void clear_has_keys();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* keys_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static JSONSettings* default_instance_;
};
// -------------------------------------------------------------------

class Settings : public ::google::protobuf::Message {
 public:
  Settings();
  virtual ~Settings();

  Settings(const Settings& from);

  inline Settings& operator=(const Settings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Settings& default_instance();

  void Swap(Settings* other);

  // implements Message ----------------------------------------------

  Settings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Settings& from);
  void MergeFrom(const Settings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp = 1 [default = 0];
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // repeated .eos.JSONSettings settings = 2;
  inline int settings_size() const;
  inline void clear_settings();
  static const int kSettingsFieldNumber = 2;
  inline const ::eos::JSONSettings& settings(int index) const;
  inline ::eos::JSONSettings* mutable_settings(int index);
  inline ::eos::JSONSettings* add_settings();
  inline const ::google::protobuf::RepeatedPtrField< ::eos::JSONSettings >&
      settings() const;
  inline ::google::protobuf::RepeatedPtrField< ::eos::JSONSettings >*
      mutable_settings();

  // @@protoc_insertion_point(class_scope:eos.Settings)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::eos::JSONSettings > settings_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Settings* default_instance_;
};
// -------------------------------------------------------------------

class Range : public ::google::protobuf::Message {
 public:
  Range();
  virtual ~Range();

  Range(const Range& from);

  inline Range& operator=(const Range& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Range& default_instance();

  void Swap(Range* other);

  // implements Message ----------------------------------------------

  Range* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Range& from);
  void MergeFrom(const Range& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 min = 1 [default = 0];
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 1;
  inline ::google::protobuf::uint32 min() const;
  inline void set_min(::google::protobuf::uint32 value);

  // required uint32 max = 2 [default = 0];
  inline bool has_max() const;
  inline void clear_max();
  static const int kMaxFieldNumber = 2;
  inline ::google::protobuf::uint32 max() const;
  inline void set_max(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eos.Range)
 private:
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 min_;
  ::google::protobuf::uint32 max_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Range* default_instance_;
};
// -------------------------------------------------------------------

class Sensor_Point : public ::google::protobuf::Message {
 public:
  Sensor_Point();
  virtual ~Sensor_Point();

  Sensor_Point(const Sensor_Point& from);

  inline Sensor_Point& operator=(const Sensor_Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sensor_Point& default_instance();

  void Swap(Sensor_Point* other);

  // implements Message ----------------------------------------------

  Sensor_Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sensor_Point& from);
  void MergeFrom(const Sensor_Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 x = 1 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 2 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eos.Sensor.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Sensor_Point* default_instance_;
};
// -------------------------------------------------------------------

class Sensor : public ::google::protobuf::Message {
 public:
  Sensor();
  virtual ~Sensor();

  Sensor(const Sensor& from);

  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sensor& default_instance();

  void Swap(Sensor* other);

  // implements Message ----------------------------------------------

  Sensor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sensor& from);
  void MergeFrom(const Sensor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Sensor_Point Point;

  typedef Sensor_Type Type;
  static const Type RobotDock = Sensor_Type_RobotDock;
  static const Type DoorSwitch = Sensor_Type_DoorSwitch;
  static const Type Radar = Sensor_Type_Radar;
  static const Type InfraredBarrier = Sensor_Type_InfraredBarrier;
  static const Type Rack = Sensor_Type_Rack;
  static inline bool Type_IsValid(int value) {
    return Sensor_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Sensor_Type_Type_MIN;
  static const Type Type_MAX =
    Sensor_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Sensor_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Sensor_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Sensor_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Sensor_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .eos.Sensor.Point position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::eos::Sensor_Point& position() const;
  inline ::eos::Sensor_Point* mutable_position();
  inline ::eos::Sensor_Point* release_position();
  inline void set_allocated_position(::eos::Sensor_Point* position);

  // required .eos.Sensor.Point position_second_element = 3;
  inline bool has_position_second_element() const;
  inline void clear_position_second_element();
  static const int kPositionSecondElementFieldNumber = 3;
  inline const ::eos::Sensor_Point& position_second_element() const;
  inline ::eos::Sensor_Point* mutable_position_second_element();
  inline ::eos::Sensor_Point* release_position_second_element();
  inline void set_allocated_position_second_element(::eos::Sensor_Point* position_second_element);

  // required int32 orientation = 4 [default = 0];
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  inline ::google::protobuf::int32 orientation() const;
  inline void set_orientation(::google::protobuf::int32 value);

  // required .eos.Range distance = 5;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 5;
  inline const ::eos::Range& distance() const;
  inline ::eos::Range* mutable_distance();
  inline ::eos::Range* release_distance();
  inline void set_allocated_distance(::eos::Range* distance);

  // required .eos.Range angle = 6;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 6;
  inline const ::eos::Range& angle() const;
  inline ::eos::Range* mutable_angle();
  inline ::eos::Range* release_angle();
  inline void set_allocated_angle(::eos::Range* angle);

  // required .eos.Sensor.Type type = 7 [default = RobotDock];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline ::eos::Sensor_Type type() const;
  inline void set_type(::eos::Sensor_Type value);

  // required .eos.Sensor.Point robot_point = 8;
  inline bool has_robot_point() const;
  inline void clear_robot_point();
  static const int kRobotPointFieldNumber = 8;
  inline const ::eos::Sensor_Point& robot_point() const;
  inline ::eos::Sensor_Point* mutable_robot_point();
  inline ::eos::Sensor_Point* release_robot_point();
  inline void set_allocated_robot_point(::eos::Sensor_Point* robot_point);

  // @@protoc_insertion_point(class_scope:eos.Sensor)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_position_second_element();
  inline void clear_has_position_second_element();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_robot_point();
  inline void clear_has_robot_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::eos::Sensor_Point* position_;
  ::eos::Sensor_Point* position_second_element_;
  ::eos::Range* distance_;
  ::google::protobuf::int32 orientation_;
  int type_;
  ::eos::Range* angle_;
  ::eos::Sensor_Point* robot_point_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Sensor* default_instance_;
};
// -------------------------------------------------------------------

class Sensors : public ::google::protobuf::Message {
 public:
  Sensors();
  virtual ~Sensors();

  Sensors(const Sensors& from);

  inline Sensors& operator=(const Sensors& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sensors& default_instance();

  void Swap(Sensors* other);

  // implements Message ----------------------------------------------

  Sensors* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sensors& from);
  void MergeFrom(const Sensors& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp = 1 [default = 0];
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // repeated .eos.Sensor sensors = 2;
  inline int sensors_size() const;
  inline void clear_sensors();
  static const int kSensorsFieldNumber = 2;
  inline const ::eos::Sensor& sensors(int index) const;
  inline ::eos::Sensor* mutable_sensors(int index);
  inline ::eos::Sensor* add_sensors();
  inline const ::google::protobuf::RepeatedPtrField< ::eos::Sensor >&
      sensors() const;
  inline ::google::protobuf::RepeatedPtrField< ::eos::Sensor >*
      mutable_sensors();

  // @@protoc_insertion_point(class_scope:eos.Sensors)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::eos::Sensor > sensors_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Sensors* default_instance_;
};
// -------------------------------------------------------------------

class Patrol_Position : public ::google::protobuf::Message {
 public:
  Patrol_Position();
  virtual ~Patrol_Position();

  Patrol_Position(const Patrol_Position& from);

  inline Patrol_Position& operator=(const Patrol_Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Patrol_Position& default_instance();

  void Swap(Patrol_Position* other);

  // implements Message ----------------------------------------------

  Patrol_Position* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Patrol_Position& from);
  void MergeFrom(const Patrol_Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eos.Patrol.Position)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Patrol_Position* default_instance_;
};
// -------------------------------------------------------------------

class Patrol_Point : public ::google::protobuf::Message {
 public:
  Patrol_Point();
  virtual ~Patrol_Point();

  Patrol_Point(const Patrol_Point& from);

  inline Patrol_Point& operator=(const Patrol_Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Patrol_Point& default_instance();

  void Swap(Patrol_Point* other);

  // implements Message ----------------------------------------------

  Patrol_Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Patrol_Point& from);
  void MergeFrom(const Patrol_Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .eos.Patrol.Position position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::eos::Patrol_Position& position() const;
  inline ::eos::Patrol_Position* mutable_position();
  inline ::eos::Patrol_Position* release_position();
  inline void set_allocated_position(::eos::Patrol_Position* position);

  // required .eos.Patrol.Priority priority = 2;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 2;
  inline ::eos::Patrol_Priority priority() const;
  inline void set_priority(::eos::Patrol_Priority value);

  // @@protoc_insertion_point(class_scope:eos.Patrol.Point)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_priority();
  inline void clear_has_priority();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::eos::Patrol_Position* position_;
  int priority_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Patrol_Point* default_instance_;
};
// -------------------------------------------------------------------

class Patrol : public ::google::protobuf::Message {
 public:
  Patrol();
  virtual ~Patrol();

  Patrol(const Patrol& from);

  inline Patrol& operator=(const Patrol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Patrol& default_instance();

  void Swap(Patrol* other);

  // implements Message ----------------------------------------------

  Patrol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Patrol& from);
  void MergeFrom(const Patrol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Patrol_Position Position;
  typedef Patrol_Point Point;

  typedef Patrol_Type Type;
  static const Type Normal = Patrol_Type_Normal;
  static const Type PopOut = Patrol_Type_PopOut;
  static const Type Remapping = Patrol_Type_Remapping;
  static const Type Refill = Patrol_Type_Refill;
  static inline bool Type_IsValid(int value) {
    return Patrol_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Patrol_Type_Type_MIN;
  static const Type Type_MAX =
    Patrol_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Patrol_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Patrol_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Patrol_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Patrol_Type_Parse(name, value);
  }

  typedef Patrol_Priority Priority;
  static const Priority Standard = Patrol_Priority_Standard;
  static const Priority High = Patrol_Priority_High;
  static inline bool Priority_IsValid(int value) {
    return Patrol_Priority_IsValid(value);
  }
  static const Priority Priority_MIN =
    Patrol_Priority_Priority_MIN;
  static const Priority Priority_MAX =
    Patrol_Priority_Priority_MAX;
  static const int Priority_ARRAYSIZE =
    Patrol_Priority_Priority_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Priority_descriptor() {
    return Patrol_Priority_descriptor();
  }
  static inline const ::std::string& Priority_Name(Priority value) {
    return Patrol_Priority_Name(value);
  }
  static inline bool Priority_Parse(const ::std::string& name,
      Priority* value) {
    return Patrol_Priority_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .eos.Patrol.Type type = 2 [default = Normal];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::eos::Patrol_Type type() const;
  inline void set_type(::eos::Patrol_Type value);

  // repeated .eos.Patrol.Point points = 3;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 3;
  inline const ::eos::Patrol_Point& points(int index) const;
  inline ::eos::Patrol_Point* mutable_points(int index);
  inline ::eos::Patrol_Point* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::eos::Patrol_Point >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::eos::Patrol_Point >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:eos.Patrol)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::eos::Patrol_Point > points_;
  int type_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Patrol* default_instance_;
};
// -------------------------------------------------------------------

class Patrols : public ::google::protobuf::Message {
 public:
  Patrols();
  virtual ~Patrols();

  Patrols(const Patrols& from);

  inline Patrols& operator=(const Patrols& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Patrols& default_instance();

  void Swap(Patrols* other);

  // implements Message ----------------------------------------------

  Patrols* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Patrols& from);
  void MergeFrom(const Patrols& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp = 1 [default = 0];
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // repeated .eos.Patrol Patrols = 2;
  inline int patrols_size() const;
  inline void clear_patrols();
  static const int kPatrolsFieldNumber = 2;
  inline const ::eos::Patrol& patrols(int index) const;
  inline ::eos::Patrol* mutable_patrols(int index);
  inline ::eos::Patrol* add_patrols();
  inline const ::google::protobuf::RepeatedPtrField< ::eos::Patrol >&
      patrols() const;
  inline ::google::protobuf::RepeatedPtrField< ::eos::Patrol >*
      mutable_patrols();

  // @@protoc_insertion_point(class_scope:eos.Patrols)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::eos::Patrol > patrols_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Patrols* default_instance_;
};
// -------------------------------------------------------------------

class Map : public ::google::protobuf::Message {
 public:
  Map();
  virtual ~Map();

  Map(const Map& from);

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Map& default_instance();

  void Swap(Map* other);

  // implements Message ----------------------------------------------

  Map* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Map& from);
  void MergeFrom(const Map& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Map_Type Type;
  static const Type BASE_MAP = Map_Type_BASE_MAP;
  static const Type REMAP_MAP = Map_Type_REMAP_MAP;
  static const Type DISPLAY_MAP = Map_Type_DISPLAY_MAP;
  static inline bool Type_IsValid(int value) {
    return Map_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Map_Type_Type_MIN;
  static const Type Type_MAX =
    Map_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Map_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Map_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Map_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Map_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint64 timestamp = 1 [default = 0];
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // required uint32 width = 2;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 2;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // required float resolution = 4;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 4;
  inline float resolution() const;
  inline void set_resolution(float value);

  // required bytes content = 5;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 5;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required .eos.Map.Type type = 6 [default = BASE_MAP];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::eos::Map_Type type() const;
  inline void set_type(::eos::Map_Type value);

  // @@protoc_insertion_point(class_scope:eos.Map)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::std::string* content_;
  float resolution_;
  int type_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static Map* default_instance_;
};
// -------------------------------------------------------------------

class TaskScheduled : public ::google::protobuf::Message {
 public:
  TaskScheduled();
  virtual ~TaskScheduled();

  TaskScheduled(const TaskScheduled& from);

  inline TaskScheduled& operator=(const TaskScheduled& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskScheduled& default_instance();

  void Swap(TaskScheduled* other);

  // implements Message ----------------------------------------------

  TaskScheduled* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskScheduled& from);
  void MergeFrom(const TaskScheduled& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string patrol_name = 1 [default = "none"];
  inline bool has_patrol_name() const;
  inline void clear_patrol_name();
  static const int kPatrolNameFieldNumber = 1;
  inline const ::std::string& patrol_name() const;
  inline void set_patrol_name(const ::std::string& value);
  inline void set_patrol_name(const char* value);
  inline void set_patrol_name(const char* value, size_t size);
  inline ::std::string* mutable_patrol_name();
  inline ::std::string* release_patrol_name();
  inline void set_allocated_patrol_name(::std::string* patrol_name);

  // required int64 start = 2 [default = 0];
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 2;
  inline ::google::protobuf::int64 start() const;
  inline void set_start(::google::protobuf::int64 value);

  // required int64 stop = 3 [default = 0];
  inline bool has_stop() const;
  inline void clear_stop();
  static const int kStopFieldNumber = 3;
  inline ::google::protobuf::int64 stop() const;
  inline void set_stop(::google::protobuf::int64 value);

  // required int64 group_id = 4 [default = 0];
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 4;
  inline ::google::protobuf::int64 group_id() const;
  inline void set_group_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:eos.TaskScheduled)
 private:
  inline void set_has_patrol_name();
  inline void clear_has_patrol_name();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_stop();
  inline void clear_has_stop();
  inline void set_has_group_id();
  inline void clear_has_group_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  static ::std::string* _default_patrol_name_;
  ::std::string* patrol_name_;
  ::google::protobuf::int64 start_;
  ::google::protobuf::int64 stop_;
  ::google::protobuf::int64 group_id_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static TaskScheduled* default_instance_;
};
// -------------------------------------------------------------------

class TasksScheduled : public ::google::protobuf::Message {
 public:
  TasksScheduled();
  virtual ~TasksScheduled();

  TasksScheduled(const TasksScheduled& from);

  inline TasksScheduled& operator=(const TasksScheduled& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TasksScheduled& default_instance();

  void Swap(TasksScheduled* other);

  // implements Message ----------------------------------------------

  TasksScheduled* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TasksScheduled& from);
  void MergeFrom(const TasksScheduled& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 timestamp = 1 [default = 0];
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // repeated .eos.TaskScheduled tasks = 2;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 2;
  inline const ::eos::TaskScheduled& tasks(int index) const;
  inline ::eos::TaskScheduled* mutable_tasks(int index);
  inline ::eos::TaskScheduled* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::eos::TaskScheduled >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::eos::TaskScheduled >*
      mutable_tasks();

  // @@protoc_insertion_point(class_scope:eos.TasksScheduled)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::eos::TaskScheduled > tasks_;
  friend void  protobuf_AddDesc_models_2eproto();
  friend void protobuf_AssignDesc_models_2eproto();
  friend void protobuf_ShutdownFile_models_2eproto();

  void InitAsDefaultInstance();
  static TasksScheduled* default_instance_;
};
// ===================================================================


// ===================================================================

// GetTimestamps

// -------------------------------------------------------------------

// Timestamps

// required uint64 base_map = 1;
inline bool Timestamps::has_base_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Timestamps::set_has_base_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Timestamps::clear_has_base_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Timestamps::clear_base_map() {
  base_map_ = GOOGLE_ULONGLONG(0);
  clear_has_base_map();
}
inline ::google::protobuf::uint64 Timestamps::base_map() const {
  // @@protoc_insertion_point(field_get:eos.Timestamps.base_map)
  return base_map_;
}
inline void Timestamps::set_base_map(::google::protobuf::uint64 value) {
  set_has_base_map();
  base_map_ = value;
  // @@protoc_insertion_point(field_set:eos.Timestamps.base_map)
}

// required uint64 static_map = 2;
inline bool Timestamps::has_static_map() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Timestamps::set_has_static_map() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Timestamps::clear_has_static_map() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Timestamps::clear_static_map() {
  static_map_ = GOOGLE_ULONGLONG(0);
  clear_has_static_map();
}
inline ::google::protobuf::uint64 Timestamps::static_map() const {
  // @@protoc_insertion_point(field_get:eos.Timestamps.static_map)
  return static_map_;
}
inline void Timestamps::set_static_map(::google::protobuf::uint64 value) {
  set_has_static_map();
  static_map_ = value;
  // @@protoc_insertion_point(field_set:eos.Timestamps.static_map)
}

// required uint64 display_map = 3;
inline bool Timestamps::has_display_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Timestamps::set_has_display_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Timestamps::clear_has_display_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Timestamps::clear_display_map() {
  display_map_ = GOOGLE_ULONGLONG(0);
  clear_has_display_map();
}
inline ::google::protobuf::uint64 Timestamps::display_map() const {
  // @@protoc_insertion_point(field_get:eos.Timestamps.display_map)
  return display_map_;
}
inline void Timestamps::set_display_map(::google::protobuf::uint64 value) {
  set_has_display_map();
  display_map_ = value;
  // @@protoc_insertion_point(field_set:eos.Timestamps.display_map)
}

// required uint64 patrols = 4;
inline bool Timestamps::has_patrols() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Timestamps::set_has_patrols() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Timestamps::clear_has_patrols() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Timestamps::clear_patrols() {
  patrols_ = GOOGLE_ULONGLONG(0);
  clear_has_patrols();
}
inline ::google::protobuf::uint64 Timestamps::patrols() const {
  // @@protoc_insertion_point(field_get:eos.Timestamps.patrols)
  return patrols_;
}
inline void Timestamps::set_patrols(::google::protobuf::uint64 value) {
  set_has_patrols();
  patrols_ = value;
  // @@protoc_insertion_point(field_set:eos.Timestamps.patrols)
}

// required uint64 zones = 5;
inline bool Timestamps::has_zones() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Timestamps::set_has_zones() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Timestamps::clear_has_zones() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Timestamps::clear_zones() {
  zones_ = GOOGLE_ULONGLONG(0);
  clear_has_zones();
}
inline ::google::protobuf::uint64 Timestamps::zones() const {
  // @@protoc_insertion_point(field_get:eos.Timestamps.zones)
  return zones_;
}
inline void Timestamps::set_zones(::google::protobuf::uint64 value) {
  set_has_zones();
  zones_ = value;
  // @@protoc_insertion_point(field_set:eos.Timestamps.zones)
}

// required uint64 sensors = 6;
inline bool Timestamps::has_sensors() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Timestamps::set_has_sensors() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Timestamps::clear_has_sensors() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Timestamps::clear_sensors() {
  sensors_ = GOOGLE_ULONGLONG(0);
  clear_has_sensors();
}
inline ::google::protobuf::uint64 Timestamps::sensors() const {
  // @@protoc_insertion_point(field_get:eos.Timestamps.sensors)
  return sensors_;
}
inline void Timestamps::set_sensors(::google::protobuf::uint64 value) {
  set_has_sensors();
  sensors_ = value;
  // @@protoc_insertion_point(field_set:eos.Timestamps.sensors)
}

// -------------------------------------------------------------------

// Zone_Point

// required uint32 x = 1;
inline bool Zone_Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Zone_Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Zone_Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Zone_Point::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 Zone_Point::x() const {
  // @@protoc_insertion_point(field_get:eos.Zone.Point.x)
  return x_;
}
inline void Zone_Point::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:eos.Zone.Point.x)
}

// required uint32 y = 2;
inline bool Zone_Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Zone_Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Zone_Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Zone_Point::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 Zone_Point::y() const {
  // @@protoc_insertion_point(field_get:eos.Zone.Point.y)
  return y_;
}
inline void Zone_Point::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:eos.Zone.Point.y)
}

// -------------------------------------------------------------------

// Zone

// required .eos.Zone.Point top_left = 1;
inline bool Zone::has_top_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Zone::set_has_top_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Zone::clear_has_top_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Zone::clear_top_left() {
  if (top_left_ != NULL) top_left_->::eos::Zone_Point::Clear();
  clear_has_top_left();
}
inline const ::eos::Zone_Point& Zone::top_left() const {
  // @@protoc_insertion_point(field_get:eos.Zone.top_left)
  return top_left_ != NULL ? *top_left_ : *default_instance_->top_left_;
}
inline ::eos::Zone_Point* Zone::mutable_top_left() {
  set_has_top_left();
  if (top_left_ == NULL) top_left_ = new ::eos::Zone_Point;
  // @@protoc_insertion_point(field_mutable:eos.Zone.top_left)
  return top_left_;
}
inline ::eos::Zone_Point* Zone::release_top_left() {
  clear_has_top_left();
  ::eos::Zone_Point* temp = top_left_;
  top_left_ = NULL;
  return temp;
}
inline void Zone::set_allocated_top_left(::eos::Zone_Point* top_left) {
  delete top_left_;
  top_left_ = top_left;
  if (top_left) {
    set_has_top_left();
  } else {
    clear_has_top_left();
  }
  // @@protoc_insertion_point(field_set_allocated:eos.Zone.top_left)
}

// required .eos.Zone.Point bottom_right = 2;
inline bool Zone::has_bottom_right() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Zone::set_has_bottom_right() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Zone::clear_has_bottom_right() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Zone::clear_bottom_right() {
  if (bottom_right_ != NULL) bottom_right_->::eos::Zone_Point::Clear();
  clear_has_bottom_right();
}
inline const ::eos::Zone_Point& Zone::bottom_right() const {
  // @@protoc_insertion_point(field_get:eos.Zone.bottom_right)
  return bottom_right_ != NULL ? *bottom_right_ : *default_instance_->bottom_right_;
}
inline ::eos::Zone_Point* Zone::mutable_bottom_right() {
  set_has_bottom_right();
  if (bottom_right_ == NULL) bottom_right_ = new ::eos::Zone_Point;
  // @@protoc_insertion_point(field_mutable:eos.Zone.bottom_right)
  return bottom_right_;
}
inline ::eos::Zone_Point* Zone::release_bottom_right() {
  clear_has_bottom_right();
  ::eos::Zone_Point* temp = bottom_right_;
  bottom_right_ = NULL;
  return temp;
}
inline void Zone::set_allocated_bottom_right(::eos::Zone_Point* bottom_right) {
  delete bottom_right_;
  bottom_right_ = bottom_right;
  if (bottom_right) {
    set_has_bottom_right();
  } else {
    clear_has_bottom_right();
  }
  // @@protoc_insertion_point(field_set_allocated:eos.Zone.bottom_right)
}

// required .eos.Zone.Permission permissions = 3 [default = NoDetection];
inline bool Zone::has_permissions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Zone::set_has_permissions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Zone::clear_has_permissions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Zone::clear_permissions() {
  permissions_ = 1;
  clear_has_permissions();
}
inline ::eos::Zone_Permission Zone::permissions() const {
  // @@protoc_insertion_point(field_get:eos.Zone.permissions)
  return static_cast< ::eos::Zone_Permission >(permissions_);
}
inline void Zone::set_permissions(::eos::Zone_Permission value) {
  assert(::eos::Zone_Permission_IsValid(value));
  set_has_permissions();
  permissions_ = value;
  // @@protoc_insertion_point(field_set:eos.Zone.permissions)
}

// -------------------------------------------------------------------

// Zones

// required uint64 timestamp = 1 [default = 0];
inline bool Zones::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Zones::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Zones::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Zones::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Zones::timestamp() const {
  // @@protoc_insertion_point(field_get:eos.Zones.timestamp)
  return timestamp_;
}
inline void Zones::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:eos.Zones.timestamp)
}

// repeated .eos.Zone zones = 2;
inline int Zones::zones_size() const {
  return zones_.size();
}
inline void Zones::clear_zones() {
  zones_.Clear();
}
inline const ::eos::Zone& Zones::zones(int index) const {
  // @@protoc_insertion_point(field_get:eos.Zones.zones)
  return zones_.Get(index);
}
inline ::eos::Zone* Zones::mutable_zones(int index) {
  // @@protoc_insertion_point(field_mutable:eos.Zones.zones)
  return zones_.Mutable(index);
}
inline ::eos::Zone* Zones::add_zones() {
  // @@protoc_insertion_point(field_add:eos.Zones.zones)
  return zones_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eos::Zone >&
Zones::zones() const {
  // @@protoc_insertion_point(field_list:eos.Zones.zones)
  return zones_;
}
inline ::google::protobuf::RepeatedPtrField< ::eos::Zone >*
Zones::mutable_zones() {
  // @@protoc_insertion_point(field_mutable_list:eos.Zones.zones)
  return &zones_;
}

// -------------------------------------------------------------------

// JSONSettings

// required string keys = 1;
inline bool JSONSettings::has_keys() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JSONSettings::set_has_keys() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JSONSettings::clear_has_keys() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JSONSettings::clear_keys() {
  if (keys_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keys_->clear();
  }
  clear_has_keys();
}
inline const ::std::string& JSONSettings::keys() const {
  // @@protoc_insertion_point(field_get:eos.JSONSettings.keys)
  return *keys_;
}
inline void JSONSettings::set_keys(const ::std::string& value) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keys_ = new ::std::string;
  }
  keys_->assign(value);
  // @@protoc_insertion_point(field_set:eos.JSONSettings.keys)
}
inline void JSONSettings::set_keys(const char* value) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keys_ = new ::std::string;
  }
  keys_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.JSONSettings.keys)
}
inline void JSONSettings::set_keys(const char* value, size_t size) {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keys_ = new ::std::string;
  }
  keys_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.JSONSettings.keys)
}
inline ::std::string* JSONSettings::mutable_keys() {
  set_has_keys();
  if (keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    keys_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.JSONSettings.keys)
  return keys_;
}
inline ::std::string* JSONSettings::release_keys() {
  clear_has_keys();
  if (keys_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = keys_;
    keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JSONSettings::set_allocated_keys(::std::string* keys) {
  if (keys_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete keys_;
  }
  if (keys) {
    set_has_keys();
    keys_ = keys;
  } else {
    clear_has_keys();
    keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.JSONSettings.keys)
}

// required string value = 2;
inline bool JSONSettings::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JSONSettings::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JSONSettings::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JSONSettings::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& JSONSettings::value() const {
  // @@protoc_insertion_point(field_get:eos.JSONSettings.value)
  return *value_;
}
inline void JSONSettings::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:eos.JSONSettings.value)
}
inline void JSONSettings::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.JSONSettings.value)
}
inline void JSONSettings::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.JSONSettings.value)
}
inline ::std::string* JSONSettings::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.JSONSettings.value)
  return value_;
}
inline ::std::string* JSONSettings::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JSONSettings::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.JSONSettings.value)
}

// -------------------------------------------------------------------

// Settings

// required uint64 timestamp = 1 [default = 0];
inline bool Settings::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Settings::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Settings::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Settings::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Settings::timestamp() const {
  // @@protoc_insertion_point(field_get:eos.Settings.timestamp)
  return timestamp_;
}
inline void Settings::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:eos.Settings.timestamp)
}

// repeated .eos.JSONSettings settings = 2;
inline int Settings::settings_size() const {
  return settings_.size();
}
inline void Settings::clear_settings() {
  settings_.Clear();
}
inline const ::eos::JSONSettings& Settings::settings(int index) const {
  // @@protoc_insertion_point(field_get:eos.Settings.settings)
  return settings_.Get(index);
}
inline ::eos::JSONSettings* Settings::mutable_settings(int index) {
  // @@protoc_insertion_point(field_mutable:eos.Settings.settings)
  return settings_.Mutable(index);
}
inline ::eos::JSONSettings* Settings::add_settings() {
  // @@protoc_insertion_point(field_add:eos.Settings.settings)
  return settings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eos::JSONSettings >&
Settings::settings() const {
  // @@protoc_insertion_point(field_list:eos.Settings.settings)
  return settings_;
}
inline ::google::protobuf::RepeatedPtrField< ::eos::JSONSettings >*
Settings::mutable_settings() {
  // @@protoc_insertion_point(field_mutable_list:eos.Settings.settings)
  return &settings_;
}

// -------------------------------------------------------------------

// Range

// required uint32 min = 1 [default = 0];
inline bool Range::has_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Range::set_has_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Range::clear_has_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Range::clear_min() {
  min_ = 0u;
  clear_has_min();
}
inline ::google::protobuf::uint32 Range::min() const {
  // @@protoc_insertion_point(field_get:eos.Range.min)
  return min_;
}
inline void Range::set_min(::google::protobuf::uint32 value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:eos.Range.min)
}

// required uint32 max = 2 [default = 0];
inline bool Range::has_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Range::set_has_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Range::clear_has_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Range::clear_max() {
  max_ = 0u;
  clear_has_max();
}
inline ::google::protobuf::uint32 Range::max() const {
  // @@protoc_insertion_point(field_get:eos.Range.max)
  return max_;
}
inline void Range::set_max(::google::protobuf::uint32 value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:eos.Range.max)
}

// -------------------------------------------------------------------

// Sensor_Point

// required uint32 x = 1 [default = 0];
inline bool Sensor_Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sensor_Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sensor_Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sensor_Point::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 Sensor_Point::x() const {
  // @@protoc_insertion_point(field_get:eos.Sensor.Point.x)
  return x_;
}
inline void Sensor_Point::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:eos.Sensor.Point.x)
}

// required uint32 y = 2 [default = 0];
inline bool Sensor_Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sensor_Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sensor_Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sensor_Point::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 Sensor_Point::y() const {
  // @@protoc_insertion_point(field_get:eos.Sensor.Point.y)
  return y_;
}
inline void Sensor_Point::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:eos.Sensor.Point.y)
}

// -------------------------------------------------------------------

// Sensor

// required string name = 1;
inline bool Sensor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sensor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sensor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sensor::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Sensor::name() const {
  // @@protoc_insertion_point(field_get:eos.Sensor.name)
  return *name_;
}
inline void Sensor::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:eos.Sensor.name)
}
inline void Sensor::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.Sensor.name)
}
inline void Sensor::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.Sensor.name)
}
inline ::std::string* Sensor::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.Sensor.name)
  return name_;
}
inline ::std::string* Sensor::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Sensor::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.Sensor.name)
}

// required .eos.Sensor.Point position = 2;
inline bool Sensor::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sensor::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sensor::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sensor::clear_position() {
  if (position_ != NULL) position_->::eos::Sensor_Point::Clear();
  clear_has_position();
}
inline const ::eos::Sensor_Point& Sensor::position() const {
  // @@protoc_insertion_point(field_get:eos.Sensor.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::eos::Sensor_Point* Sensor::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::eos::Sensor_Point;
  // @@protoc_insertion_point(field_mutable:eos.Sensor.position)
  return position_;
}
inline ::eos::Sensor_Point* Sensor::release_position() {
  clear_has_position();
  ::eos::Sensor_Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Sensor::set_allocated_position(::eos::Sensor_Point* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:eos.Sensor.position)
}

// required .eos.Sensor.Point position_second_element = 3;
inline bool Sensor::has_position_second_element() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sensor::set_has_position_second_element() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sensor::clear_has_position_second_element() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sensor::clear_position_second_element() {
  if (position_second_element_ != NULL) position_second_element_->::eos::Sensor_Point::Clear();
  clear_has_position_second_element();
}
inline const ::eos::Sensor_Point& Sensor::position_second_element() const {
  // @@protoc_insertion_point(field_get:eos.Sensor.position_second_element)
  return position_second_element_ != NULL ? *position_second_element_ : *default_instance_->position_second_element_;
}
inline ::eos::Sensor_Point* Sensor::mutable_position_second_element() {
  set_has_position_second_element();
  if (position_second_element_ == NULL) position_second_element_ = new ::eos::Sensor_Point;
  // @@protoc_insertion_point(field_mutable:eos.Sensor.position_second_element)
  return position_second_element_;
}
inline ::eos::Sensor_Point* Sensor::release_position_second_element() {
  clear_has_position_second_element();
  ::eos::Sensor_Point* temp = position_second_element_;
  position_second_element_ = NULL;
  return temp;
}
inline void Sensor::set_allocated_position_second_element(::eos::Sensor_Point* position_second_element) {
  delete position_second_element_;
  position_second_element_ = position_second_element;
  if (position_second_element) {
    set_has_position_second_element();
  } else {
    clear_has_position_second_element();
  }
  // @@protoc_insertion_point(field_set_allocated:eos.Sensor.position_second_element)
}

// required int32 orientation = 4 [default = 0];
inline bool Sensor::has_orientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Sensor::set_has_orientation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Sensor::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Sensor::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline ::google::protobuf::int32 Sensor::orientation() const {
  // @@protoc_insertion_point(field_get:eos.Sensor.orientation)
  return orientation_;
}
inline void Sensor::set_orientation(::google::protobuf::int32 value) {
  set_has_orientation();
  orientation_ = value;
  // @@protoc_insertion_point(field_set:eos.Sensor.orientation)
}

// required .eos.Range distance = 5;
inline bool Sensor::has_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Sensor::set_has_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Sensor::clear_has_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Sensor::clear_distance() {
  if (distance_ != NULL) distance_->::eos::Range::Clear();
  clear_has_distance();
}
inline const ::eos::Range& Sensor::distance() const {
  // @@protoc_insertion_point(field_get:eos.Sensor.distance)
  return distance_ != NULL ? *distance_ : *default_instance_->distance_;
}
inline ::eos::Range* Sensor::mutable_distance() {
  set_has_distance();
  if (distance_ == NULL) distance_ = new ::eos::Range;
  // @@protoc_insertion_point(field_mutable:eos.Sensor.distance)
  return distance_;
}
inline ::eos::Range* Sensor::release_distance() {
  clear_has_distance();
  ::eos::Range* temp = distance_;
  distance_ = NULL;
  return temp;
}
inline void Sensor::set_allocated_distance(::eos::Range* distance) {
  delete distance_;
  distance_ = distance;
  if (distance) {
    set_has_distance();
  } else {
    clear_has_distance();
  }
  // @@protoc_insertion_point(field_set_allocated:eos.Sensor.distance)
}

// required .eos.Range angle = 6;
inline bool Sensor::has_angle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Sensor::set_has_angle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Sensor::clear_has_angle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Sensor::clear_angle() {
  if (angle_ != NULL) angle_->::eos::Range::Clear();
  clear_has_angle();
}
inline const ::eos::Range& Sensor::angle() const {
  // @@protoc_insertion_point(field_get:eos.Sensor.angle)
  return angle_ != NULL ? *angle_ : *default_instance_->angle_;
}
inline ::eos::Range* Sensor::mutable_angle() {
  set_has_angle();
  if (angle_ == NULL) angle_ = new ::eos::Range;
  // @@protoc_insertion_point(field_mutable:eos.Sensor.angle)
  return angle_;
}
inline ::eos::Range* Sensor::release_angle() {
  clear_has_angle();
  ::eos::Range* temp = angle_;
  angle_ = NULL;
  return temp;
}
inline void Sensor::set_allocated_angle(::eos::Range* angle) {
  delete angle_;
  angle_ = angle;
  if (angle) {
    set_has_angle();
  } else {
    clear_has_angle();
  }
  // @@protoc_insertion_point(field_set_allocated:eos.Sensor.angle)
}

// required .eos.Sensor.Type type = 7 [default = RobotDock];
inline bool Sensor::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Sensor::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Sensor::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Sensor::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::eos::Sensor_Type Sensor::type() const {
  // @@protoc_insertion_point(field_get:eos.Sensor.type)
  return static_cast< ::eos::Sensor_Type >(type_);
}
inline void Sensor::set_type(::eos::Sensor_Type value) {
  assert(::eos::Sensor_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:eos.Sensor.type)
}

// required .eos.Sensor.Point robot_point = 8;
inline bool Sensor::has_robot_point() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Sensor::set_has_robot_point() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Sensor::clear_has_robot_point() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Sensor::clear_robot_point() {
  if (robot_point_ != NULL) robot_point_->::eos::Sensor_Point::Clear();
  clear_has_robot_point();
}
inline const ::eos::Sensor_Point& Sensor::robot_point() const {
  // @@protoc_insertion_point(field_get:eos.Sensor.robot_point)
  return robot_point_ != NULL ? *robot_point_ : *default_instance_->robot_point_;
}
inline ::eos::Sensor_Point* Sensor::mutable_robot_point() {
  set_has_robot_point();
  if (robot_point_ == NULL) robot_point_ = new ::eos::Sensor_Point;
  // @@protoc_insertion_point(field_mutable:eos.Sensor.robot_point)
  return robot_point_;
}
inline ::eos::Sensor_Point* Sensor::release_robot_point() {
  clear_has_robot_point();
  ::eos::Sensor_Point* temp = robot_point_;
  robot_point_ = NULL;
  return temp;
}
inline void Sensor::set_allocated_robot_point(::eos::Sensor_Point* robot_point) {
  delete robot_point_;
  robot_point_ = robot_point;
  if (robot_point) {
    set_has_robot_point();
  } else {
    clear_has_robot_point();
  }
  // @@protoc_insertion_point(field_set_allocated:eos.Sensor.robot_point)
}

// -------------------------------------------------------------------

// Sensors

// required uint64 timestamp = 1 [default = 0];
inline bool Sensors::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sensors::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sensors::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sensors::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Sensors::timestamp() const {
  // @@protoc_insertion_point(field_get:eos.Sensors.timestamp)
  return timestamp_;
}
inline void Sensors::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:eos.Sensors.timestamp)
}

// repeated .eos.Sensor sensors = 2;
inline int Sensors::sensors_size() const {
  return sensors_.size();
}
inline void Sensors::clear_sensors() {
  sensors_.Clear();
}
inline const ::eos::Sensor& Sensors::sensors(int index) const {
  // @@protoc_insertion_point(field_get:eos.Sensors.sensors)
  return sensors_.Get(index);
}
inline ::eos::Sensor* Sensors::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:eos.Sensors.sensors)
  return sensors_.Mutable(index);
}
inline ::eos::Sensor* Sensors::add_sensors() {
  // @@protoc_insertion_point(field_add:eos.Sensors.sensors)
  return sensors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eos::Sensor >&
Sensors::sensors() const {
  // @@protoc_insertion_point(field_list:eos.Sensors.sensors)
  return sensors_;
}
inline ::google::protobuf::RepeatedPtrField< ::eos::Sensor >*
Sensors::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:eos.Sensors.sensors)
  return &sensors_;
}

// -------------------------------------------------------------------

// Patrol_Position

// required uint32 x = 1;
inline bool Patrol_Position::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Patrol_Position::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Patrol_Position::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Patrol_Position::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 Patrol_Position::x() const {
  // @@protoc_insertion_point(field_get:eos.Patrol.Position.x)
  return x_;
}
inline void Patrol_Position::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:eos.Patrol.Position.x)
}

// required uint32 y = 2;
inline bool Patrol_Position::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Patrol_Position::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Patrol_Position::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Patrol_Position::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 Patrol_Position::y() const {
  // @@protoc_insertion_point(field_get:eos.Patrol.Position.y)
  return y_;
}
inline void Patrol_Position::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:eos.Patrol.Position.y)
}

// -------------------------------------------------------------------

// Patrol_Point

// required .eos.Patrol.Position position = 1;
inline bool Patrol_Point::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Patrol_Point::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Patrol_Point::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Patrol_Point::clear_position() {
  if (position_ != NULL) position_->::eos::Patrol_Position::Clear();
  clear_has_position();
}
inline const ::eos::Patrol_Position& Patrol_Point::position() const {
  // @@protoc_insertion_point(field_get:eos.Patrol.Point.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::eos::Patrol_Position* Patrol_Point::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::eos::Patrol_Position;
  // @@protoc_insertion_point(field_mutable:eos.Patrol.Point.position)
  return position_;
}
inline ::eos::Patrol_Position* Patrol_Point::release_position() {
  clear_has_position();
  ::eos::Patrol_Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void Patrol_Point::set_allocated_position(::eos::Patrol_Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:eos.Patrol.Point.position)
}

// required .eos.Patrol.Priority priority = 2;
inline bool Patrol_Point::has_priority() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Patrol_Point::set_has_priority() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Patrol_Point::clear_has_priority() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Patrol_Point::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::eos::Patrol_Priority Patrol_Point::priority() const {
  // @@protoc_insertion_point(field_get:eos.Patrol.Point.priority)
  return static_cast< ::eos::Patrol_Priority >(priority_);
}
inline void Patrol_Point::set_priority(::eos::Patrol_Priority value) {
  assert(::eos::Patrol_Priority_IsValid(value));
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:eos.Patrol.Point.priority)
}

// -------------------------------------------------------------------

// Patrol

// required string name = 1;
inline bool Patrol::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Patrol::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Patrol::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Patrol::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Patrol::name() const {
  // @@protoc_insertion_point(field_get:eos.Patrol.name)
  return *name_;
}
inline void Patrol::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:eos.Patrol.name)
}
inline void Patrol::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.Patrol.name)
}
inline void Patrol::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.Patrol.name)
}
inline ::std::string* Patrol::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.Patrol.name)
  return name_;
}
inline ::std::string* Patrol::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Patrol::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.Patrol.name)
}

// required .eos.Patrol.Type type = 2 [default = Normal];
inline bool Patrol::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Patrol::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Patrol::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Patrol::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::eos::Patrol_Type Patrol::type() const {
  // @@protoc_insertion_point(field_get:eos.Patrol.type)
  return static_cast< ::eos::Patrol_Type >(type_);
}
inline void Patrol::set_type(::eos::Patrol_Type value) {
  assert(::eos::Patrol_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:eos.Patrol.type)
}

// repeated .eos.Patrol.Point points = 3;
inline int Patrol::points_size() const {
  return points_.size();
}
inline void Patrol::clear_points() {
  points_.Clear();
}
inline const ::eos::Patrol_Point& Patrol::points(int index) const {
  // @@protoc_insertion_point(field_get:eos.Patrol.points)
  return points_.Get(index);
}
inline ::eos::Patrol_Point* Patrol::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:eos.Patrol.points)
  return points_.Mutable(index);
}
inline ::eos::Patrol_Point* Patrol::add_points() {
  // @@protoc_insertion_point(field_add:eos.Patrol.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eos::Patrol_Point >&
Patrol::points() const {
  // @@protoc_insertion_point(field_list:eos.Patrol.points)
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::eos::Patrol_Point >*
Patrol::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:eos.Patrol.points)
  return &points_;
}

// -------------------------------------------------------------------

// Patrols

// required uint64 timestamp = 1 [default = 0];
inline bool Patrols::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Patrols::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Patrols::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Patrols::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Patrols::timestamp() const {
  // @@protoc_insertion_point(field_get:eos.Patrols.timestamp)
  return timestamp_;
}
inline void Patrols::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:eos.Patrols.timestamp)
}

// repeated .eos.Patrol Patrols = 2;
inline int Patrols::patrols_size() const {
  return patrols_.size();
}
inline void Patrols::clear_patrols() {
  patrols_.Clear();
}
inline const ::eos::Patrol& Patrols::patrols(int index) const {
  // @@protoc_insertion_point(field_get:eos.Patrols.Patrols)
  return patrols_.Get(index);
}
inline ::eos::Patrol* Patrols::mutable_patrols(int index) {
  // @@protoc_insertion_point(field_mutable:eos.Patrols.Patrols)
  return patrols_.Mutable(index);
}
inline ::eos::Patrol* Patrols::add_patrols() {
  // @@protoc_insertion_point(field_add:eos.Patrols.Patrols)
  return patrols_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eos::Patrol >&
Patrols::patrols() const {
  // @@protoc_insertion_point(field_list:eos.Patrols.Patrols)
  return patrols_;
}
inline ::google::protobuf::RepeatedPtrField< ::eos::Patrol >*
Patrols::mutable_patrols() {
  // @@protoc_insertion_point(field_mutable_list:eos.Patrols.Patrols)
  return &patrols_;
}

// -------------------------------------------------------------------

// Map

// required uint64 timestamp = 1 [default = 0];
inline bool Map::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Map::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Map::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Map::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 Map::timestamp() const {
  // @@protoc_insertion_point(field_get:eos.Map.timestamp)
  return timestamp_;
}
inline void Map::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:eos.Map.timestamp)
}

// required uint32 width = 2;
inline bool Map::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Map::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Map::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Map::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Map::width() const {
  // @@protoc_insertion_point(field_get:eos.Map.width)
  return width_;
}
inline void Map::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:eos.Map.width)
}

// required uint32 height = 3;
inline bool Map::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Map::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Map::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Map::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Map::height() const {
  // @@protoc_insertion_point(field_get:eos.Map.height)
  return height_;
}
inline void Map::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:eos.Map.height)
}

// required float resolution = 4;
inline bool Map::has_resolution() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Map::set_has_resolution() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Map::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Map::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline float Map::resolution() const {
  // @@protoc_insertion_point(field_get:eos.Map.resolution)
  return resolution_;
}
inline void Map::set_resolution(float value) {
  set_has_resolution();
  resolution_ = value;
  // @@protoc_insertion_point(field_set:eos.Map.resolution)
}

// required bytes content = 5;
inline bool Map::has_content() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Map::set_has_content() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Map::clear_has_content() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Map::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Map::content() const {
  // @@protoc_insertion_point(field_get:eos.Map.content)
  return *content_;
}
inline void Map::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:eos.Map.content)
}
inline void Map::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.Map.content)
}
inline void Map::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.Map.content)
}
inline ::std::string* Map::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.Map.content)
  return content_;
}
inline ::std::string* Map::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Map::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.Map.content)
}

// required .eos.Map.Type type = 6 [default = BASE_MAP];
inline bool Map::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Map::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Map::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Map::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::eos::Map_Type Map::type() const {
  // @@protoc_insertion_point(field_get:eos.Map.type)
  return static_cast< ::eos::Map_Type >(type_);
}
inline void Map::set_type(::eos::Map_Type value) {
  assert(::eos::Map_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:eos.Map.type)
}

// -------------------------------------------------------------------

// TaskScheduled

// required string patrol_name = 1 [default = "none"];
inline bool TaskScheduled::has_patrol_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskScheduled::set_has_patrol_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskScheduled::clear_has_patrol_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskScheduled::clear_patrol_name() {
  if (patrol_name_ != _default_patrol_name_) {
    patrol_name_->assign(*_default_patrol_name_);
  }
  clear_has_patrol_name();
}
inline const ::std::string& TaskScheduled::patrol_name() const {
  // @@protoc_insertion_point(field_get:eos.TaskScheduled.patrol_name)
  return *patrol_name_;
}
inline void TaskScheduled::set_patrol_name(const ::std::string& value) {
  set_has_patrol_name();
  if (patrol_name_ == _default_patrol_name_) {
    patrol_name_ = new ::std::string;
  }
  patrol_name_->assign(value);
  // @@protoc_insertion_point(field_set:eos.TaskScheduled.patrol_name)
}
inline void TaskScheduled::set_patrol_name(const char* value) {
  set_has_patrol_name();
  if (patrol_name_ == _default_patrol_name_) {
    patrol_name_ = new ::std::string;
  }
  patrol_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.TaskScheduled.patrol_name)
}
inline void TaskScheduled::set_patrol_name(const char* value, size_t size) {
  set_has_patrol_name();
  if (patrol_name_ == _default_patrol_name_) {
    patrol_name_ = new ::std::string;
  }
  patrol_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.TaskScheduled.patrol_name)
}
inline ::std::string* TaskScheduled::mutable_patrol_name() {
  set_has_patrol_name();
  if (patrol_name_ == _default_patrol_name_) {
    patrol_name_ = new ::std::string(*_default_patrol_name_);
  }
  // @@protoc_insertion_point(field_mutable:eos.TaskScheduled.patrol_name)
  return patrol_name_;
}
inline ::std::string* TaskScheduled::release_patrol_name() {
  clear_has_patrol_name();
  if (patrol_name_ == _default_patrol_name_) {
    return NULL;
  } else {
    ::std::string* temp = patrol_name_;
    patrol_name_ = const_cast< ::std::string*>(_default_patrol_name_);
    return temp;
  }
}
inline void TaskScheduled::set_allocated_patrol_name(::std::string* patrol_name) {
  if (patrol_name_ != _default_patrol_name_) {
    delete patrol_name_;
  }
  if (patrol_name) {
    set_has_patrol_name();
    patrol_name_ = patrol_name;
  } else {
    clear_has_patrol_name();
    patrol_name_ = const_cast< ::std::string*>(_default_patrol_name_);
  }
  // @@protoc_insertion_point(field_set_allocated:eos.TaskScheduled.patrol_name)
}

// required int64 start = 2 [default = 0];
inline bool TaskScheduled::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskScheduled::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskScheduled::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskScheduled::clear_start() {
  start_ = GOOGLE_LONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::int64 TaskScheduled::start() const {
  // @@protoc_insertion_point(field_get:eos.TaskScheduled.start)
  return start_;
}
inline void TaskScheduled::set_start(::google::protobuf::int64 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:eos.TaskScheduled.start)
}

// required int64 stop = 3 [default = 0];
inline bool TaskScheduled::has_stop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskScheduled::set_has_stop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskScheduled::clear_has_stop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskScheduled::clear_stop() {
  stop_ = GOOGLE_LONGLONG(0);
  clear_has_stop();
}
inline ::google::protobuf::int64 TaskScheduled::stop() const {
  // @@protoc_insertion_point(field_get:eos.TaskScheduled.stop)
  return stop_;
}
inline void TaskScheduled::set_stop(::google::protobuf::int64 value) {
  set_has_stop();
  stop_ = value;
  // @@protoc_insertion_point(field_set:eos.TaskScheduled.stop)
}

// required int64 group_id = 4 [default = 0];
inline bool TaskScheduled::has_group_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskScheduled::set_has_group_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskScheduled::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskScheduled::clear_group_id() {
  group_id_ = GOOGLE_LONGLONG(0);
  clear_has_group_id();
}
inline ::google::protobuf::int64 TaskScheduled::group_id() const {
  // @@protoc_insertion_point(field_get:eos.TaskScheduled.group_id)
  return group_id_;
}
inline void TaskScheduled::set_group_id(::google::protobuf::int64 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:eos.TaskScheduled.group_id)
}

// -------------------------------------------------------------------

// TasksScheduled

// required uint64 timestamp = 1 [default = 0];
inline bool TasksScheduled::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TasksScheduled::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TasksScheduled::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TasksScheduled::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 TasksScheduled::timestamp() const {
  // @@protoc_insertion_point(field_get:eos.TasksScheduled.timestamp)
  return timestamp_;
}
inline void TasksScheduled::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:eos.TasksScheduled.timestamp)
}

// repeated .eos.TaskScheduled tasks = 2;
inline int TasksScheduled::tasks_size() const {
  return tasks_.size();
}
inline void TasksScheduled::clear_tasks() {
  tasks_.Clear();
}
inline const ::eos::TaskScheduled& TasksScheduled::tasks(int index) const {
  // @@protoc_insertion_point(field_get:eos.TasksScheduled.tasks)
  return tasks_.Get(index);
}
inline ::eos::TaskScheduled* TasksScheduled::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:eos.TasksScheduled.tasks)
  return tasks_.Mutable(index);
}
inline ::eos::TaskScheduled* TasksScheduled::add_tasks() {
  // @@protoc_insertion_point(field_add:eos.TasksScheduled.tasks)
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eos::TaskScheduled >&
TasksScheduled::tasks() const {
  // @@protoc_insertion_point(field_list:eos.TasksScheduled.tasks)
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::eos::TaskScheduled >*
TasksScheduled::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:eos.TasksScheduled.tasks)
  return &tasks_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace eos

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::eos::Zone_Permission> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::Zone_Permission>() {
  return ::eos::Zone_Permission_descriptor();
}
template <> struct is_proto_enum< ::eos::Sensor_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::Sensor_Type>() {
  return ::eos::Sensor_Type_descriptor();
}
template <> struct is_proto_enum< ::eos::Patrol_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::Patrol_Type>() {
  return ::eos::Patrol_Type_descriptor();
}
template <> struct is_proto_enum< ::eos::Patrol_Priority> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::Patrol_Priority>() {
  return ::eos::Patrol_Priority_descriptor();
}
template <> struct is_proto_enum< ::eos::Map_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::Map_Type>() {
  return ::eos::Map_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_models_2eproto__INCLUDED
