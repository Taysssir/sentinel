// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: models.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "models.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace eos {

namespace {

const ::google::protobuf::Descriptor* GetTimestamps_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetTimestamps_reflection_ = NULL;
const ::google::protobuf::Descriptor* Timestamps_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Timestamps_reflection_ = NULL;
const ::google::protobuf::Descriptor* Zone_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Zone_reflection_ = NULL;
const ::google::protobuf::Descriptor* Zone_Point_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Zone_Point_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Zone_Permission_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Zones_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Zones_reflection_ = NULL;
const ::google::protobuf::Descriptor* JSONSettings_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  JSONSettings_reflection_ = NULL;
const ::google::protobuf::Descriptor* Settings_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Settings_reflection_ = NULL;
const ::google::protobuf::Descriptor* Range_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Range_reflection_ = NULL;
const ::google::protobuf::Descriptor* Sensor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sensor_reflection_ = NULL;
const ::google::protobuf::Descriptor* Sensor_Point_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sensor_Point_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Sensor_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Sensors_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sensors_reflection_ = NULL;
const ::google::protobuf::Descriptor* Patrol_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Patrol_reflection_ = NULL;
const ::google::protobuf::Descriptor* Patrol_Position_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Patrol_Position_reflection_ = NULL;
const ::google::protobuf::Descriptor* Patrol_Point_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Patrol_Point_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Patrol_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Patrol_Priority_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Patrols_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Patrols_reflection_ = NULL;
const ::google::protobuf::Descriptor* Map_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Map_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Map_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* TaskScheduled_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskScheduled_reflection_ = NULL;
const ::google::protobuf::Descriptor* TasksScheduled_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TasksScheduled_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_models_2eproto() {
  protobuf_AddDesc_models_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "models.proto");
  GOOGLE_CHECK(file != NULL);
  GetTimestamps_descriptor_ = file->message_type(0);
  static const int GetTimestamps_offsets_[1] = {
  };
  GetTimestamps_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetTimestamps_descriptor_,
      GetTimestamps::default_instance_,
      GetTimestamps_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetTimestamps, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetTimestamps, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetTimestamps));
  Timestamps_descriptor_ = file->message_type(1);
  static const int Timestamps_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamps, base_map_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamps, static_map_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamps, display_map_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamps, patrols_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamps, zones_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamps, sensors_),
  };
  Timestamps_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Timestamps_descriptor_,
      Timestamps::default_instance_,
      Timestamps_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamps, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Timestamps, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Timestamps));
  Zone_descriptor_ = file->message_type(2);
  static const int Zone_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, top_left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, bottom_right_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, permissions_),
  };
  Zone_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Zone_descriptor_,
      Zone::default_instance_,
      Zone_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Zone));
  Zone_Point_descriptor_ = Zone_descriptor_->nested_type(0);
  static const int Zone_Point_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone_Point, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone_Point, y_),
  };
  Zone_Point_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Zone_Point_descriptor_,
      Zone_Point::default_instance_,
      Zone_Point_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone_Point, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone_Point, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Zone_Point));
  Zone_Permission_descriptor_ = Zone_descriptor_->enum_type(0);
  Zones_descriptor_ = file->message_type(3);
  static const int Zones_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zones, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zones, zones_),
  };
  Zones_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Zones_descriptor_,
      Zones::default_instance_,
      Zones_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zones, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zones, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Zones));
  JSONSettings_descriptor_ = file->message_type(4);
  static const int JSONSettings_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JSONSettings, keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JSONSettings, value_),
  };
  JSONSettings_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      JSONSettings_descriptor_,
      JSONSettings::default_instance_,
      JSONSettings_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JSONSettings, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JSONSettings, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(JSONSettings));
  Settings_descriptor_ = file->message_type(5);
  static const int Settings_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Settings, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Settings, settings_),
  };
  Settings_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Settings_descriptor_,
      Settings::default_instance_,
      Settings_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Settings, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Settings, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Settings));
  Range_descriptor_ = file->message_type(6);
  static const int Range_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, max_),
  };
  Range_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Range_descriptor_,
      Range::default_instance_,
      Range_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Range, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Range));
  Sensor_descriptor_ = file->message_type(7);
  static const int Sensor_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, position_second_element_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, orientation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, distance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, angle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, robot_point_),
  };
  Sensor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Sensor_descriptor_,
      Sensor::default_instance_,
      Sensor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Sensor));
  Sensor_Point_descriptor_ = Sensor_descriptor_->nested_type(0);
  static const int Sensor_Point_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor_Point, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor_Point, y_),
  };
  Sensor_Point_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Sensor_Point_descriptor_,
      Sensor_Point::default_instance_,
      Sensor_Point_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor_Point, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensor_Point, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Sensor_Point));
  Sensor_Type_descriptor_ = Sensor_descriptor_->enum_type(0);
  Sensors_descriptor_ = file->message_type(8);
  static const int Sensors_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensors, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensors, sensors_),
  };
  Sensors_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Sensors_descriptor_,
      Sensors::default_instance_,
      Sensors_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensors, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sensors, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Sensors));
  Patrol_descriptor_ = file->message_type(9);
  static const int Patrol_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol, points_),
  };
  Patrol_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Patrol_descriptor_,
      Patrol::default_instance_,
      Patrol_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Patrol));
  Patrol_Position_descriptor_ = Patrol_descriptor_->nested_type(0);
  static const int Patrol_Position_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol_Position, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol_Position, y_),
  };
  Patrol_Position_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Patrol_Position_descriptor_,
      Patrol_Position::default_instance_,
      Patrol_Position_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol_Position, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol_Position, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Patrol_Position));
  Patrol_Point_descriptor_ = Patrol_descriptor_->nested_type(1);
  static const int Patrol_Point_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol_Point, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol_Point, priority_),
  };
  Patrol_Point_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Patrol_Point_descriptor_,
      Patrol_Point::default_instance_,
      Patrol_Point_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol_Point, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrol_Point, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Patrol_Point));
  Patrol_Type_descriptor_ = Patrol_descriptor_->enum_type(0);
  Patrol_Priority_descriptor_ = Patrol_descriptor_->enum_type(1);
  Patrols_descriptor_ = file->message_type(10);
  static const int Patrols_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrols, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrols, patrols_),
  };
  Patrols_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Patrols_descriptor_,
      Patrols::default_instance_,
      Patrols_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrols, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Patrols, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Patrols));
  Map_descriptor_ = file->message_type(11);
  static const int Map_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Map, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Map, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Map, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Map, resolution_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Map, content_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Map, type_),
  };
  Map_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Map_descriptor_,
      Map::default_instance_,
      Map_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Map, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Map, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Map));
  Map_Type_descriptor_ = Map_descriptor_->enum_type(0);
  TaskScheduled_descriptor_ = file->message_type(12);
  static const int TaskScheduled_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskScheduled, patrol_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskScheduled, start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskScheduled, stop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskScheduled, group_id_),
  };
  TaskScheduled_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TaskScheduled_descriptor_,
      TaskScheduled::default_instance_,
      TaskScheduled_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskScheduled, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskScheduled, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TaskScheduled));
  TasksScheduled_descriptor_ = file->message_type(13);
  static const int TasksScheduled_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksScheduled, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksScheduled, tasks_),
  };
  TasksScheduled_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TasksScheduled_descriptor_,
      TasksScheduled::default_instance_,
      TasksScheduled_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksScheduled, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TasksScheduled, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TasksScheduled));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_models_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetTimestamps_descriptor_, &GetTimestamps::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Timestamps_descriptor_, &Timestamps::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Zone_descriptor_, &Zone::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Zone_Point_descriptor_, &Zone_Point::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Zones_descriptor_, &Zones::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JSONSettings_descriptor_, &JSONSettings::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Settings_descriptor_, &Settings::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Range_descriptor_, &Range::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Sensor_descriptor_, &Sensor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Sensor_Point_descriptor_, &Sensor_Point::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Sensors_descriptor_, &Sensors::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Patrol_descriptor_, &Patrol::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Patrol_Position_descriptor_, &Patrol_Position::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Patrol_Point_descriptor_, &Patrol_Point::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Patrols_descriptor_, &Patrols::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Map_descriptor_, &Map::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TaskScheduled_descriptor_, &TaskScheduled::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TasksScheduled_descriptor_, &TasksScheduled::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_models_2eproto() {
  delete GetTimestamps::default_instance_;
  delete GetTimestamps_reflection_;
  delete Timestamps::default_instance_;
  delete Timestamps_reflection_;
  delete Zone::default_instance_;
  delete Zone_reflection_;
  delete Zone_Point::default_instance_;
  delete Zone_Point_reflection_;
  delete Zones::default_instance_;
  delete Zones_reflection_;
  delete JSONSettings::default_instance_;
  delete JSONSettings_reflection_;
  delete Settings::default_instance_;
  delete Settings_reflection_;
  delete Range::default_instance_;
  delete Range_reflection_;
  delete Sensor::default_instance_;
  delete Sensor_reflection_;
  delete Sensor_Point::default_instance_;
  delete Sensor_Point_reflection_;
  delete Sensors::default_instance_;
  delete Sensors_reflection_;
  delete Patrol::default_instance_;
  delete Patrol_reflection_;
  delete Patrol_Position::default_instance_;
  delete Patrol_Position_reflection_;
  delete Patrol_Point::default_instance_;
  delete Patrol_Point_reflection_;
  delete Patrols::default_instance_;
  delete Patrols_reflection_;
  delete Map::default_instance_;
  delete Map_reflection_;
  delete TaskScheduled::default_instance_;
  delete TaskScheduled_reflection_;
  delete TaskScheduled::_default_patrol_name_;
  delete TasksScheduled::default_instance_;
  delete TasksScheduled_reflection_;
}

void protobuf_AddDesc_models_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014models.proto\022\003eos\"\017\n\rGetTimestamps\"x\n\n"
    "Timestamps\022\020\n\010base_map\030\001 \002(\004\022\022\n\nstatic_m"
    "ap\030\002 \002(\004\022\023\n\013display_map\030\003 \002(\004\022\017\n\007patrols"
    "\030\004 \002(\004\022\r\n\005zones\030\005 \002(\004\022\017\n\007sensors\030\006 \002(\004\"\375"
    "\001\n\004Zone\022!\n\010top_left\030\001 \002(\0132\017.eos.Zone.Poi"
    "nt\022%\n\014bottom_right\030\002 \002(\0132\017.eos.Zone.Poin"
    "t\0226\n\013permissions\030\003 \002(\0162\024.eos.Zone.Permis"
    "sion:\013NoDetection\032\035\n\005Point\022\t\n\001x\030\001 \002(\r\022\t\n"
    "\001y\030\002 \002(\r\"T\n\nPermission\022\013\n\007Nothing\020\000\022\017\n\013N"
    "oDetection\020\001\022\016\n\nNoMovement\020\002\022\017\n\013NoRemapp"
    "ing\020\003\022\007\n\003Map\020\004\"7\n\005Zones\022\024\n\ttimestamp\030\001 \002"
    "(\004:\0010\022\030\n\005zones\030\002 \003(\0132\t.eos.Zone\"+\n\014JSONS"
    "ettings\022\014\n\004keys\030\001 \002(\t\022\r\n\005value\030\002 \002(\t\"E\n\010"
    "Settings\022\024\n\ttimestamp\030\001 \002(\004:\0010\022#\n\010settin"
    "gs\030\002 \003(\0132\021.eos.JSONSettings\"\'\n\005Range\022\016\n\003"
    "min\030\001 \002(\r:\0010\022\016\n\003max\030\002 \002(\r:\0010\"\211\003\n\006Sensor\022"
    "\014\n\004name\030\001 \002(\t\022#\n\010position\030\002 \002(\0132\021.eos.Se"
    "nsor.Point\0222\n\027position_second_element\030\003 "
    "\002(\0132\021.eos.Sensor.Point\022\026\n\013orientation\030\004 "
    "\002(\005:\0010\022\034\n\010distance\030\005 \002(\0132\n.eos.Range\022\031\n\005"
    "angle\030\006 \002(\0132\n.eos.Range\022)\n\004type\030\007 \002(\0162\020."
    "eos.Sensor.Type:\tRobotDock\022&\n\013robot_poin"
    "t\030\010 \002(\0132\021.eos.Sensor.Point\032#\n\005Point\022\014\n\001x"
    "\030\001 \002(\r:\0010\022\014\n\001y\030\002 \002(\r:\0010\"O\n\004Type\022\r\n\tRobot"
    "Dock\020\000\022\016\n\nDoorSwitch\020\001\022\t\n\005Radar\020\002\022\023\n\017Inf"
    "raredBarrier\020\003\022\010\n\004Rack\020\004\"=\n\007Sensors\022\024\n\tt"
    "imestamp\030\001 \002(\004:\0010\022\034\n\007sensors\030\002 \003(\0132\013.eos"
    ".Sensor\"\273\002\n\006Patrol\022\014\n\004name\030\001 \002(\t\022&\n\004type"
    "\030\002 \002(\0162\020.eos.Patrol.Type:\006Normal\022!\n\006poin"
    "ts\030\003 \003(\0132\021.eos.Patrol.Point\032 \n\010Position\022"
    "\t\n\001x\030\001 \002(\r\022\t\n\001y\030\002 \002(\r\032W\n\005Point\022&\n\010positi"
    "on\030\001 \002(\0132\024.eos.Patrol.Position\022&\n\010priori"
    "ty\030\002 \002(\0162\024.eos.Patrol.Priority\"9\n\004Type\022\n"
    "\n\006Normal\020\000\022\n\n\006PopOut\020\001\022\r\n\tRemapping\020\002\022\n\n"
    "\006Refill\020\003\"\"\n\010Priority\022\014\n\010Standard\020\000\022\010\n\004H"
    "igh\020\001\"=\n\007Patrols\022\024\n\ttimestamp\030\001 \002(\004:\0010\022\034"
    "\n\007Patrols\030\002 \003(\0132\013.eos.Patrol\"\274\001\n\003Map\022\024\n\t"
    "timestamp\030\001 \002(\004:\0010\022\r\n\005width\030\002 \002(\r\022\016\n\006hei"
    "ght\030\003 \002(\r\022\022\n\nresolution\030\004 \002(\002\022\017\n\007content"
    "\030\005 \002(\014\022%\n\004type\030\006 \002(\0162\r.eos.Map.Type:\010BAS"
    "E_MAP\"4\n\004Type\022\014\n\010BASE_MAP\020\000\022\r\n\tREMAP_MAP"
    "\020\001\022\017\n\013DISPLAY_MAP\020\002\"b\n\rTaskScheduled\022\031\n\013"
    "patrol_name\030\001 \002(\t:\004none\022\020\n\005start\030\002 \002(\003:\001"
    "0\022\017\n\004stop\030\003 \002(\003:\0010\022\023\n\010group_id\030\004 \002(\003:\0010\""
    "I\n\016TasksScheduled\022\024\n\ttimestamp\030\001 \002(\004:\0010\022"
    "!\n\005tasks\030\002 \003(\0132\022.eos.TaskScheduled", 1834);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "models.proto", &protobuf_RegisterTypes);
  GetTimestamps::default_instance_ = new GetTimestamps();
  Timestamps::default_instance_ = new Timestamps();
  Zone::default_instance_ = new Zone();
  Zone_Point::default_instance_ = new Zone_Point();
  Zones::default_instance_ = new Zones();
  JSONSettings::default_instance_ = new JSONSettings();
  Settings::default_instance_ = new Settings();
  Range::default_instance_ = new Range();
  Sensor::default_instance_ = new Sensor();
  Sensor_Point::default_instance_ = new Sensor_Point();
  Sensors::default_instance_ = new Sensors();
  Patrol::default_instance_ = new Patrol();
  Patrol_Position::default_instance_ = new Patrol_Position();
  Patrol_Point::default_instance_ = new Patrol_Point();
  Patrols::default_instance_ = new Patrols();
  Map::default_instance_ = new Map();
  TaskScheduled::_default_patrol_name_ =
      new ::std::string("none", 4);
  TaskScheduled::default_instance_ = new TaskScheduled();
  TasksScheduled::default_instance_ = new TasksScheduled();
  GetTimestamps::default_instance_->InitAsDefaultInstance();
  Timestamps::default_instance_->InitAsDefaultInstance();
  Zone::default_instance_->InitAsDefaultInstance();
  Zone_Point::default_instance_->InitAsDefaultInstance();
  Zones::default_instance_->InitAsDefaultInstance();
  JSONSettings::default_instance_->InitAsDefaultInstance();
  Settings::default_instance_->InitAsDefaultInstance();
  Range::default_instance_->InitAsDefaultInstance();
  Sensor::default_instance_->InitAsDefaultInstance();
  Sensor_Point::default_instance_->InitAsDefaultInstance();
  Sensors::default_instance_->InitAsDefaultInstance();
  Patrol::default_instance_->InitAsDefaultInstance();
  Patrol_Position::default_instance_->InitAsDefaultInstance();
  Patrol_Point::default_instance_->InitAsDefaultInstance();
  Patrols::default_instance_->InitAsDefaultInstance();
  Map::default_instance_->InitAsDefaultInstance();
  TaskScheduled::default_instance_->InitAsDefaultInstance();
  TasksScheduled::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_models_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_models_2eproto {
  StaticDescriptorInitializer_models_2eproto() {
    protobuf_AddDesc_models_2eproto();
  }
} static_descriptor_initializer_models_2eproto_;

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GetTimestamps::GetTimestamps()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.GetTimestamps)
}

void GetTimestamps::InitAsDefaultInstance() {
}

GetTimestamps::GetTimestamps(const GetTimestamps& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.GetTimestamps)
}

void GetTimestamps::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetTimestamps::~GetTimestamps() {
  // @@protoc_insertion_point(destructor:eos.GetTimestamps)
  SharedDtor();
}

void GetTimestamps::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetTimestamps::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetTimestamps::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetTimestamps_descriptor_;
}

const GetTimestamps& GetTimestamps::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

GetTimestamps* GetTimestamps::default_instance_ = NULL;

GetTimestamps* GetTimestamps::New() const {
  return new GetTimestamps;
}

void GetTimestamps::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetTimestamps::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.GetTimestamps)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:eos.GetTimestamps)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.GetTimestamps)
  return false;
#undef DO_
}

void GetTimestamps::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.GetTimestamps)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.GetTimestamps)
}

::google::protobuf::uint8* GetTimestamps::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.GetTimestamps)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.GetTimestamps)
  return target;
}

int GetTimestamps::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetTimestamps::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetTimestamps* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetTimestamps*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetTimestamps::MergeFrom(const GetTimestamps& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetTimestamps::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetTimestamps::CopyFrom(const GetTimestamps& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTimestamps::IsInitialized() const {

  return true;
}

void GetTimestamps::Swap(GetTimestamps* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetTimestamps::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetTimestamps_descriptor_;
  metadata.reflection = GetTimestamps_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Timestamps::kBaseMapFieldNumber;
const int Timestamps::kStaticMapFieldNumber;
const int Timestamps::kDisplayMapFieldNumber;
const int Timestamps::kPatrolsFieldNumber;
const int Timestamps::kZonesFieldNumber;
const int Timestamps::kSensorsFieldNumber;
#endif  // !_MSC_VER

Timestamps::Timestamps()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Timestamps)
}

void Timestamps::InitAsDefaultInstance() {
}

Timestamps::Timestamps(const Timestamps& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Timestamps)
}

void Timestamps::SharedCtor() {
  _cached_size_ = 0;
  base_map_ = GOOGLE_ULONGLONG(0);
  static_map_ = GOOGLE_ULONGLONG(0);
  display_map_ = GOOGLE_ULONGLONG(0);
  patrols_ = GOOGLE_ULONGLONG(0);
  zones_ = GOOGLE_ULONGLONG(0);
  sensors_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Timestamps::~Timestamps() {
  // @@protoc_insertion_point(destructor:eos.Timestamps)
  SharedDtor();
}

void Timestamps::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Timestamps::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Timestamps::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Timestamps_descriptor_;
}

const Timestamps& Timestamps::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Timestamps* Timestamps::default_instance_ = NULL;

Timestamps* Timestamps::New() const {
  return new Timestamps;
}

void Timestamps::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Timestamps*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(base_map_, sensors_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Timestamps::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Timestamps)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 base_map = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &base_map_)));
          set_has_base_map();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_static_map;
        break;
      }

      // required uint64 static_map = 2;
      case 2: {
        if (tag == 16) {
         parse_static_map:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &static_map_)));
          set_has_static_map();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_display_map;
        break;
      }

      // required uint64 display_map = 3;
      case 3: {
        if (tag == 24) {
         parse_display_map:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &display_map_)));
          set_has_display_map();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_patrols;
        break;
      }

      // required uint64 patrols = 4;
      case 4: {
        if (tag == 32) {
         parse_patrols:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &patrols_)));
          set_has_patrols();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_zones;
        break;
      }

      // required uint64 zones = 5;
      case 5: {
        if (tag == 40) {
         parse_zones:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &zones_)));
          set_has_zones();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_sensors;
        break;
      }

      // required uint64 sensors = 6;
      case 6: {
        if (tag == 48) {
         parse_sensors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sensors_)));
          set_has_sensors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Timestamps)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Timestamps)
  return false;
#undef DO_
}

void Timestamps::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Timestamps)
  // required uint64 base_map = 1;
  if (has_base_map()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->base_map(), output);
  }

  // required uint64 static_map = 2;
  if (has_static_map()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->static_map(), output);
  }

  // required uint64 display_map = 3;
  if (has_display_map()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->display_map(), output);
  }

  // required uint64 patrols = 4;
  if (has_patrols()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->patrols(), output);
  }

  // required uint64 zones = 5;
  if (has_zones()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->zones(), output);
  }

  // required uint64 sensors = 6;
  if (has_sensors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->sensors(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Timestamps)
}

::google::protobuf::uint8* Timestamps::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Timestamps)
  // required uint64 base_map = 1;
  if (has_base_map()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->base_map(), target);
  }

  // required uint64 static_map = 2;
  if (has_static_map()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->static_map(), target);
  }

  // required uint64 display_map = 3;
  if (has_display_map()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->display_map(), target);
  }

  // required uint64 patrols = 4;
  if (has_patrols()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->patrols(), target);
  }

  // required uint64 zones = 5;
  if (has_zones()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->zones(), target);
  }

  // required uint64 sensors = 6;
  if (has_sensors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->sensors(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Timestamps)
  return target;
}

int Timestamps::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 base_map = 1;
    if (has_base_map()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->base_map());
    }

    // required uint64 static_map = 2;
    if (has_static_map()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->static_map());
    }

    // required uint64 display_map = 3;
    if (has_display_map()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->display_map());
    }

    // required uint64 patrols = 4;
    if (has_patrols()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->patrols());
    }

    // required uint64 zones = 5;
    if (has_zones()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->zones());
    }

    // required uint64 sensors = 6;
    if (has_sensors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sensors());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Timestamps::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Timestamps* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Timestamps*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Timestamps::MergeFrom(const Timestamps& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base_map()) {
      set_base_map(from.base_map());
    }
    if (from.has_static_map()) {
      set_static_map(from.static_map());
    }
    if (from.has_display_map()) {
      set_display_map(from.display_map());
    }
    if (from.has_patrols()) {
      set_patrols(from.patrols());
    }
    if (from.has_zones()) {
      set_zones(from.zones());
    }
    if (from.has_sensors()) {
      set_sensors(from.sensors());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Timestamps::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Timestamps::CopyFrom(const Timestamps& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Timestamps::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void Timestamps::Swap(Timestamps* other) {
  if (other != this) {
    std::swap(base_map_, other->base_map_);
    std::swap(static_map_, other->static_map_);
    std::swap(display_map_, other->display_map_);
    std::swap(patrols_, other->patrols_);
    std::swap(zones_, other->zones_);
    std::swap(sensors_, other->sensors_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Timestamps::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Timestamps_descriptor_;
  metadata.reflection = Timestamps_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Zone_Permission_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Zone_Permission_descriptor_;
}
bool Zone_Permission_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Zone_Permission Zone::Nothing;
const Zone_Permission Zone::NoDetection;
const Zone_Permission Zone::NoMovement;
const Zone_Permission Zone::NoRemapping;
const Zone_Permission Zone::Map;
const Zone_Permission Zone::Permission_MIN;
const Zone_Permission Zone::Permission_MAX;
const int Zone::Permission_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Zone_Point::kXFieldNumber;
const int Zone_Point::kYFieldNumber;
#endif  // !_MSC_VER

Zone_Point::Zone_Point()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Zone.Point)
}

void Zone_Point::InitAsDefaultInstance() {
}

Zone_Point::Zone_Point(const Zone_Point& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Zone.Point)
}

void Zone_Point::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0u;
  y_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Zone_Point::~Zone_Point() {
  // @@protoc_insertion_point(destructor:eos.Zone.Point)
  SharedDtor();
}

void Zone_Point::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Zone_Point::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Zone_Point::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Zone_Point_descriptor_;
}

const Zone_Point& Zone_Point::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Zone_Point* Zone_Point::default_instance_ = NULL;

Zone_Point* Zone_Point::New() const {
  return new Zone_Point;
}

void Zone_Point::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Zone_Point*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, y_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Zone_Point::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Zone.Point)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 x = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // required uint32 y = 2;
      case 2: {
        if (tag == 16) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Zone.Point)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Zone.Point)
  return false;
#undef DO_
}

void Zone_Point::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Zone.Point)
  // required uint32 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->x(), output);
  }

  // required uint32 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->y(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Zone.Point)
}

::google::protobuf::uint8* Zone_Point::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Zone.Point)
  // required uint32 x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->x(), target);
  }

  // required uint32 y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->y(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Zone.Point)
  return target;
}

int Zone_Point::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->x());
    }

    // required uint32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->y());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Zone_Point::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Zone_Point* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Zone_Point*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Zone_Point::MergeFrom(const Zone_Point& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Zone_Point::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Zone_Point::CopyFrom(const Zone_Point& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Zone_Point::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Zone_Point::Swap(Zone_Point* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Zone_Point::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Zone_Point_descriptor_;
  metadata.reflection = Zone_Point_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Zone::kTopLeftFieldNumber;
const int Zone::kBottomRightFieldNumber;
const int Zone::kPermissionsFieldNumber;
#endif  // !_MSC_VER

Zone::Zone()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Zone)
}

void Zone::InitAsDefaultInstance() {
  top_left_ = const_cast< ::eos::Zone_Point*>(&::eos::Zone_Point::default_instance());
  bottom_right_ = const_cast< ::eos::Zone_Point*>(&::eos::Zone_Point::default_instance());
}

Zone::Zone(const Zone& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Zone)
}

void Zone::SharedCtor() {
  _cached_size_ = 0;
  top_left_ = NULL;
  bottom_right_ = NULL;
  permissions_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Zone::~Zone() {
  // @@protoc_insertion_point(destructor:eos.Zone)
  SharedDtor();
}

void Zone::SharedDtor() {
  if (this != default_instance_) {
    delete top_left_;
    delete bottom_right_;
  }
}

void Zone::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Zone::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Zone_descriptor_;
}

const Zone& Zone::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Zone* Zone::default_instance_ = NULL;

Zone* Zone::New() const {
  return new Zone;
}

void Zone::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_top_left()) {
      if (top_left_ != NULL) top_left_->::eos::Zone_Point::Clear();
    }
    if (has_bottom_right()) {
      if (bottom_right_ != NULL) bottom_right_->::eos::Zone_Point::Clear();
    }
    permissions_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Zone::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Zone)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .eos.Zone.Point top_left = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_top_left()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_bottom_right;
        break;
      }

      // required .eos.Zone.Point bottom_right = 2;
      case 2: {
        if (tag == 18) {
         parse_bottom_right:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bottom_right()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_permissions;
        break;
      }

      // required .eos.Zone.Permission permissions = 3 [default = NoDetection];
      case 3: {
        if (tag == 24) {
         parse_permissions:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::Zone_Permission_IsValid(value)) {
            set_permissions(static_cast< ::eos::Zone_Permission >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Zone)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Zone)
  return false;
#undef DO_
}

void Zone::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Zone)
  // required .eos.Zone.Point top_left = 1;
  if (has_top_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->top_left(), output);
  }

  // required .eos.Zone.Point bottom_right = 2;
  if (has_bottom_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->bottom_right(), output);
  }

  // required .eos.Zone.Permission permissions = 3 [default = NoDetection];
  if (has_permissions()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->permissions(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Zone)
}

::google::protobuf::uint8* Zone::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Zone)
  // required .eos.Zone.Point top_left = 1;
  if (has_top_left()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->top_left(), target);
  }

  // required .eos.Zone.Point bottom_right = 2;
  if (has_bottom_right()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->bottom_right(), target);
  }

  // required .eos.Zone.Permission permissions = 3 [default = NoDetection];
  if (has_permissions()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->permissions(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Zone)
  return target;
}

int Zone::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .eos.Zone.Point top_left = 1;
    if (has_top_left()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->top_left());
    }

    // required .eos.Zone.Point bottom_right = 2;
    if (has_bottom_right()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bottom_right());
    }

    // required .eos.Zone.Permission permissions = 3 [default = NoDetection];
    if (has_permissions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->permissions());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Zone::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Zone* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Zone*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Zone::MergeFrom(const Zone& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_top_left()) {
      mutable_top_left()->::eos::Zone_Point::MergeFrom(from.top_left());
    }
    if (from.has_bottom_right()) {
      mutable_bottom_right()->::eos::Zone_Point::MergeFrom(from.bottom_right());
    }
    if (from.has_permissions()) {
      set_permissions(from.permissions());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Zone::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Zone::CopyFrom(const Zone& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Zone::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_top_left()) {
    if (!this->top_left().IsInitialized()) return false;
  }
  if (has_bottom_right()) {
    if (!this->bottom_right().IsInitialized()) return false;
  }
  return true;
}

void Zone::Swap(Zone* other) {
  if (other != this) {
    std::swap(top_left_, other->top_left_);
    std::swap(bottom_right_, other->bottom_right_);
    std::swap(permissions_, other->permissions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Zone::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Zone_descriptor_;
  metadata.reflection = Zone_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Zones::kTimestampFieldNumber;
const int Zones::kZonesFieldNumber;
#endif  // !_MSC_VER

Zones::Zones()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Zones)
}

void Zones::InitAsDefaultInstance() {
}

Zones::Zones(const Zones& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Zones)
}

void Zones::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Zones::~Zones() {
  // @@protoc_insertion_point(destructor:eos.Zones)
  SharedDtor();
}

void Zones::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Zones::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Zones::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Zones_descriptor_;
}

const Zones& Zones::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Zones* Zones::default_instance_ = NULL;

Zones* Zones::New() const {
  return new Zones;
}

void Zones::Clear() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  zones_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Zones::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Zones)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 timestamp = 1 [default = 0];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_zones;
        break;
      }

      // repeated .eos.Zone zones = 2;
      case 2: {
        if (tag == 18) {
         parse_zones:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_zones()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_zones;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Zones)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Zones)
  return false;
#undef DO_
}

void Zones::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Zones)
  // required uint64 timestamp = 1 [default = 0];
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->timestamp(), output);
  }

  // repeated .eos.Zone zones = 2;
  for (int i = 0; i < this->zones_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->zones(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Zones)
}

::google::protobuf::uint8* Zones::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Zones)
  // required uint64 timestamp = 1 [default = 0];
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->timestamp(), target);
  }

  // repeated .eos.Zone zones = 2;
  for (int i = 0; i < this->zones_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->zones(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Zones)
  return target;
}

int Zones::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 timestamp = 1 [default = 0];
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp());
    }

  }
  // repeated .eos.Zone zones = 2;
  total_size += 1 * this->zones_size();
  for (int i = 0; i < this->zones_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->zones(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Zones::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Zones* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Zones*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Zones::MergeFrom(const Zones& from) {
  GOOGLE_CHECK_NE(&from, this);
  zones_.MergeFrom(from.zones_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Zones::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Zones::CopyFrom(const Zones& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Zones::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->zones())) return false;
  return true;
}

void Zones::Swap(Zones* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    zones_.Swap(&other->zones_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Zones::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Zones_descriptor_;
  metadata.reflection = Zones_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int JSONSettings::kKeysFieldNumber;
const int JSONSettings::kValueFieldNumber;
#endif  // !_MSC_VER

JSONSettings::JSONSettings()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.JSONSettings)
}

void JSONSettings::InitAsDefaultInstance() {
}

JSONSettings::JSONSettings(const JSONSettings& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.JSONSettings)
}

void JSONSettings::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  keys_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JSONSettings::~JSONSettings() {
  // @@protoc_insertion_point(destructor:eos.JSONSettings)
  SharedDtor();
}

void JSONSettings::SharedDtor() {
  if (keys_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete keys_;
  }
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void JSONSettings::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* JSONSettings::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return JSONSettings_descriptor_;
}

const JSONSettings& JSONSettings::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

JSONSettings* JSONSettings::default_instance_ = NULL;

JSONSettings* JSONSettings::New() const {
  return new JSONSettings;
}

void JSONSettings::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_keys()) {
      if (keys_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        keys_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JSONSettings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.JSONSettings)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string keys = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_keys()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->keys().data(), this->keys().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "keys");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // required string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.JSONSettings)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.JSONSettings)
  return false;
#undef DO_
}

void JSONSettings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.JSONSettings)
  // required string keys = 1;
  if (has_keys()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->keys().data(), this->keys().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "keys");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->keys(), output);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.JSONSettings)
}

::google::protobuf::uint8* JSONSettings::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.JSONSettings)
  // required string keys = 1;
  if (has_keys()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->keys().data(), this->keys().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "keys");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->keys(), target);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.JSONSettings)
  return target;
}

int JSONSettings::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string keys = 1;
    if (has_keys()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->keys());
    }

    // required string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JSONSettings::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JSONSettings* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JSONSettings*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void JSONSettings::MergeFrom(const JSONSettings& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keys()) {
      set_keys(from.keys());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JSONSettings::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JSONSettings::CopyFrom(const JSONSettings& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JSONSettings::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void JSONSettings::Swap(JSONSettings* other) {
  if (other != this) {
    std::swap(keys_, other->keys_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata JSONSettings::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = JSONSettings_descriptor_;
  metadata.reflection = JSONSettings_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Settings::kTimestampFieldNumber;
const int Settings::kSettingsFieldNumber;
#endif  // !_MSC_VER

Settings::Settings()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Settings)
}

void Settings::InitAsDefaultInstance() {
}

Settings::Settings(const Settings& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Settings)
}

void Settings::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Settings::~Settings() {
  // @@protoc_insertion_point(destructor:eos.Settings)
  SharedDtor();
}

void Settings::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Settings::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Settings::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Settings_descriptor_;
}

const Settings& Settings::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Settings* Settings::default_instance_ = NULL;

Settings* Settings::New() const {
  return new Settings;
}

void Settings::Clear() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  settings_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Settings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Settings)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 timestamp = 1 [default = 0];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_settings;
        break;
      }

      // repeated .eos.JSONSettings settings = 2;
      case 2: {
        if (tag == 18) {
         parse_settings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_settings()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_settings;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Settings)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Settings)
  return false;
#undef DO_
}

void Settings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Settings)
  // required uint64 timestamp = 1 [default = 0];
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->timestamp(), output);
  }

  // repeated .eos.JSONSettings settings = 2;
  for (int i = 0; i < this->settings_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->settings(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Settings)
}

::google::protobuf::uint8* Settings::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Settings)
  // required uint64 timestamp = 1 [default = 0];
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->timestamp(), target);
  }

  // repeated .eos.JSONSettings settings = 2;
  for (int i = 0; i < this->settings_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->settings(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Settings)
  return target;
}

int Settings::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 timestamp = 1 [default = 0];
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp());
    }

  }
  // repeated .eos.JSONSettings settings = 2;
  total_size += 1 * this->settings_size();
  for (int i = 0; i < this->settings_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->settings(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Settings::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Settings* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Settings*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Settings::MergeFrom(const Settings& from) {
  GOOGLE_CHECK_NE(&from, this);
  settings_.MergeFrom(from.settings_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Settings::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Settings::CopyFrom(const Settings& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Settings::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->settings())) return false;
  return true;
}

void Settings::Swap(Settings* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    settings_.Swap(&other->settings_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Settings::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Settings_descriptor_;
  metadata.reflection = Settings_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Range::kMinFieldNumber;
const int Range::kMaxFieldNumber;
#endif  // !_MSC_VER

Range::Range()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Range)
}

void Range::InitAsDefaultInstance() {
}

Range::Range(const Range& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Range)
}

void Range::SharedCtor() {
  _cached_size_ = 0;
  min_ = 0u;
  max_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Range::~Range() {
  // @@protoc_insertion_point(destructor:eos.Range)
  SharedDtor();
}

void Range::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Range::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Range::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Range_descriptor_;
}

const Range& Range::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Range* Range::default_instance_ = NULL;

Range* Range::New() const {
  return new Range;
}

void Range::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Range*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(min_, max_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Range::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Range)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 min = 1 [default = 0];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &min_)));
          set_has_min();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max;
        break;
      }

      // required uint32 max = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_)));
          set_has_max();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Range)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Range)
  return false;
#undef DO_
}

void Range::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Range)
  // required uint32 min = 1 [default = 0];
  if (has_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->min(), output);
  }

  // required uint32 max = 2 [default = 0];
  if (has_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->max(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Range)
}

::google::protobuf::uint8* Range::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Range)
  // required uint32 min = 1 [default = 0];
  if (has_min()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->min(), target);
  }

  // required uint32 max = 2 [default = 0];
  if (has_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->max(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Range)
  return target;
}

int Range::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 min = 1 [default = 0];
    if (has_min()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->min());
    }

    // required uint32 max = 2 [default = 0];
    if (has_max()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Range::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Range* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Range*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Range::MergeFrom(const Range& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_min()) {
      set_min(from.min());
    }
    if (from.has_max()) {
      set_max(from.max());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Range::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Range::CopyFrom(const Range& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Range::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Range::Swap(Range* other) {
  if (other != this) {
    std::swap(min_, other->min_);
    std::swap(max_, other->max_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Range::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Range_descriptor_;
  metadata.reflection = Range_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Sensor_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sensor_Type_descriptor_;
}
bool Sensor_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Sensor_Type Sensor::RobotDock;
const Sensor_Type Sensor::DoorSwitch;
const Sensor_Type Sensor::Radar;
const Sensor_Type Sensor::InfraredBarrier;
const Sensor_Type Sensor::Rack;
const Sensor_Type Sensor::Type_MIN;
const Sensor_Type Sensor::Type_MAX;
const int Sensor::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Sensor_Point::kXFieldNumber;
const int Sensor_Point::kYFieldNumber;
#endif  // !_MSC_VER

Sensor_Point::Sensor_Point()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Sensor.Point)
}

void Sensor_Point::InitAsDefaultInstance() {
}

Sensor_Point::Sensor_Point(const Sensor_Point& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Sensor.Point)
}

void Sensor_Point::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0u;
  y_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Sensor_Point::~Sensor_Point() {
  // @@protoc_insertion_point(destructor:eos.Sensor.Point)
  SharedDtor();
}

void Sensor_Point::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Sensor_Point::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sensor_Point::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sensor_Point_descriptor_;
}

const Sensor_Point& Sensor_Point::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Sensor_Point* Sensor_Point::default_instance_ = NULL;

Sensor_Point* Sensor_Point::New() const {
  return new Sensor_Point;
}

void Sensor_Point::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Sensor_Point*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, y_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Sensor_Point::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Sensor.Point)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 x = 1 [default = 0];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // required uint32 y = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Sensor.Point)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Sensor.Point)
  return false;
#undef DO_
}

void Sensor_Point::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Sensor.Point)
  // required uint32 x = 1 [default = 0];
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->x(), output);
  }

  // required uint32 y = 2 [default = 0];
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->y(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Sensor.Point)
}

::google::protobuf::uint8* Sensor_Point::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Sensor.Point)
  // required uint32 x = 1 [default = 0];
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->x(), target);
  }

  // required uint32 y = 2 [default = 0];
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->y(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Sensor.Point)
  return target;
}

int Sensor_Point::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 x = 1 [default = 0];
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->x());
    }

    // required uint32 y = 2 [default = 0];
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->y());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sensor_Point::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Sensor_Point* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Sensor_Point*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Sensor_Point::MergeFrom(const Sensor_Point& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Sensor_Point::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sensor_Point::CopyFrom(const Sensor_Point& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sensor_Point::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Sensor_Point::Swap(Sensor_Point* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Sensor_Point::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sensor_Point_descriptor_;
  metadata.reflection = Sensor_Point_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Sensor::kNameFieldNumber;
const int Sensor::kPositionFieldNumber;
const int Sensor::kPositionSecondElementFieldNumber;
const int Sensor::kOrientationFieldNumber;
const int Sensor::kDistanceFieldNumber;
const int Sensor::kAngleFieldNumber;
const int Sensor::kTypeFieldNumber;
const int Sensor::kRobotPointFieldNumber;
#endif  // !_MSC_VER

Sensor::Sensor()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Sensor)
}

void Sensor::InitAsDefaultInstance() {
  position_ = const_cast< ::eos::Sensor_Point*>(&::eos::Sensor_Point::default_instance());
  position_second_element_ = const_cast< ::eos::Sensor_Point*>(&::eos::Sensor_Point::default_instance());
  distance_ = const_cast< ::eos::Range*>(&::eos::Range::default_instance());
  angle_ = const_cast< ::eos::Range*>(&::eos::Range::default_instance());
  robot_point_ = const_cast< ::eos::Sensor_Point*>(&::eos::Sensor_Point::default_instance());
}

Sensor::Sensor(const Sensor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Sensor)
}

void Sensor::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  position_ = NULL;
  position_second_element_ = NULL;
  orientation_ = 0;
  distance_ = NULL;
  angle_ = NULL;
  type_ = 0;
  robot_point_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Sensor::~Sensor() {
  // @@protoc_insertion_point(destructor:eos.Sensor)
  SharedDtor();
}

void Sensor::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
    delete position_;
    delete position_second_element_;
    delete distance_;
    delete angle_;
    delete robot_point_;
  }
}

void Sensor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sensor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sensor_descriptor_;
}

const Sensor& Sensor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Sensor* Sensor::default_instance_ = NULL;

Sensor* Sensor::New() const {
  return new Sensor;
}

void Sensor::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Sensor*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(orientation_, type_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_position()) {
      if (position_ != NULL) position_->::eos::Sensor_Point::Clear();
    }
    if (has_position_second_element()) {
      if (position_second_element_ != NULL) position_second_element_->::eos::Sensor_Point::Clear();
    }
    if (has_distance()) {
      if (distance_ != NULL) distance_->::eos::Range::Clear();
    }
    if (has_angle()) {
      if (angle_ != NULL) angle_->::eos::Range::Clear();
    }
    if (has_robot_point()) {
      if (robot_point_ != NULL) robot_point_->::eos::Sensor_Point::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Sensor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Sensor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_position;
        break;
      }

      // required .eos.Sensor.Point position = 2;
      case 2: {
        if (tag == 18) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_position_second_element;
        break;
      }

      // required .eos.Sensor.Point position_second_element = 3;
      case 3: {
        if (tag == 26) {
         parse_position_second_element:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position_second_element()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_orientation;
        break;
      }

      // required int32 orientation = 4 [default = 0];
      case 4: {
        if (tag == 32) {
         parse_orientation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &orientation_)));
          set_has_orientation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_distance;
        break;
      }

      // required .eos.Range distance = 5;
      case 5: {
        if (tag == 42) {
         parse_distance:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_distance()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_angle;
        break;
      }

      // required .eos.Range angle = 6;
      case 6: {
        if (tag == 50) {
         parse_angle:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_angle()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_type;
        break;
      }

      // required .eos.Sensor.Type type = 7 [default = RobotDock];
      case 7: {
        if (tag == 56) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::Sensor_Type_IsValid(value)) {
            set_type(static_cast< ::eos::Sensor_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_robot_point;
        break;
      }

      // required .eos.Sensor.Point robot_point = 8;
      case 8: {
        if (tag == 66) {
         parse_robot_point:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_robot_point()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Sensor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Sensor)
  return false;
#undef DO_
}

void Sensor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Sensor)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required .eos.Sensor.Point position = 2;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->position(), output);
  }

  // required .eos.Sensor.Point position_second_element = 3;
  if (has_position_second_element()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->position_second_element(), output);
  }

  // required int32 orientation = 4 [default = 0];
  if (has_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->orientation(), output);
  }

  // required .eos.Range distance = 5;
  if (has_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->distance(), output);
  }

  // required .eos.Range angle = 6;
  if (has_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->angle(), output);
  }

  // required .eos.Sensor.Type type = 7 [default = RobotDock];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->type(), output);
  }

  // required .eos.Sensor.Point robot_point = 8;
  if (has_robot_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->robot_point(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Sensor)
}

::google::protobuf::uint8* Sensor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Sensor)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .eos.Sensor.Point position = 2;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->position(), target);
  }

  // required .eos.Sensor.Point position_second_element = 3;
  if (has_position_second_element()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->position_second_element(), target);
  }

  // required int32 orientation = 4 [default = 0];
  if (has_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->orientation(), target);
  }

  // required .eos.Range distance = 5;
  if (has_distance()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->distance(), target);
  }

  // required .eos.Range angle = 6;
  if (has_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->angle(), target);
  }

  // required .eos.Sensor.Type type = 7 [default = RobotDock];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->type(), target);
  }

  // required .eos.Sensor.Point robot_point = 8;
  if (has_robot_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->robot_point(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Sensor)
  return target;
}

int Sensor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required .eos.Sensor.Point position = 2;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }

    // required .eos.Sensor.Point position_second_element = 3;
    if (has_position_second_element()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position_second_element());
    }

    // required int32 orientation = 4 [default = 0];
    if (has_orientation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->orientation());
    }

    // required .eos.Range distance = 5;
    if (has_distance()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->distance());
    }

    // required .eos.Range angle = 6;
    if (has_angle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->angle());
    }

    // required .eos.Sensor.Type type = 7 [default = RobotDock];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required .eos.Sensor.Point robot_point = 8;
    if (has_robot_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->robot_point());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sensor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Sensor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Sensor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Sensor::MergeFrom(const Sensor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_position()) {
      mutable_position()->::eos::Sensor_Point::MergeFrom(from.position());
    }
    if (from.has_position_second_element()) {
      mutable_position_second_element()->::eos::Sensor_Point::MergeFrom(from.position_second_element());
    }
    if (from.has_orientation()) {
      set_orientation(from.orientation());
    }
    if (from.has_distance()) {
      mutable_distance()->::eos::Range::MergeFrom(from.distance());
    }
    if (from.has_angle()) {
      mutable_angle()->::eos::Range::MergeFrom(from.angle());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_robot_point()) {
      mutable_robot_point()->::eos::Sensor_Point::MergeFrom(from.robot_point());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Sensor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sensor::CopyFrom(const Sensor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sensor::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  if (has_position()) {
    if (!this->position().IsInitialized()) return false;
  }
  if (has_position_second_element()) {
    if (!this->position_second_element().IsInitialized()) return false;
  }
  if (has_distance()) {
    if (!this->distance().IsInitialized()) return false;
  }
  if (has_angle()) {
    if (!this->angle().IsInitialized()) return false;
  }
  if (has_robot_point()) {
    if (!this->robot_point().IsInitialized()) return false;
  }
  return true;
}

void Sensor::Swap(Sensor* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(position_, other->position_);
    std::swap(position_second_element_, other->position_second_element_);
    std::swap(orientation_, other->orientation_);
    std::swap(distance_, other->distance_);
    std::swap(angle_, other->angle_);
    std::swap(type_, other->type_);
    std::swap(robot_point_, other->robot_point_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Sensor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sensor_descriptor_;
  metadata.reflection = Sensor_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Sensors::kTimestampFieldNumber;
const int Sensors::kSensorsFieldNumber;
#endif  // !_MSC_VER

Sensors::Sensors()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Sensors)
}

void Sensors::InitAsDefaultInstance() {
}

Sensors::Sensors(const Sensors& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Sensors)
}

void Sensors::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Sensors::~Sensors() {
  // @@protoc_insertion_point(destructor:eos.Sensors)
  SharedDtor();
}

void Sensors::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Sensors::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sensors::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sensors_descriptor_;
}

const Sensors& Sensors::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Sensors* Sensors::default_instance_ = NULL;

Sensors* Sensors::New() const {
  return new Sensors;
}

void Sensors::Clear() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  sensors_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Sensors::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Sensors)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 timestamp = 1 [default = 0];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sensors;
        break;
      }

      // repeated .eos.Sensor sensors = 2;
      case 2: {
        if (tag == 18) {
         parse_sensors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sensors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_sensors;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Sensors)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Sensors)
  return false;
#undef DO_
}

void Sensors::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Sensors)
  // required uint64 timestamp = 1 [default = 0];
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->timestamp(), output);
  }

  // repeated .eos.Sensor sensors = 2;
  for (int i = 0; i < this->sensors_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->sensors(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Sensors)
}

::google::protobuf::uint8* Sensors::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Sensors)
  // required uint64 timestamp = 1 [default = 0];
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->timestamp(), target);
  }

  // repeated .eos.Sensor sensors = 2;
  for (int i = 0; i < this->sensors_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->sensors(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Sensors)
  return target;
}

int Sensors::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 timestamp = 1 [default = 0];
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp());
    }

  }
  // repeated .eos.Sensor sensors = 2;
  total_size += 1 * this->sensors_size();
  for (int i = 0; i < this->sensors_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sensors(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sensors::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Sensors* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Sensors*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Sensors::MergeFrom(const Sensors& from) {
  GOOGLE_CHECK_NE(&from, this);
  sensors_.MergeFrom(from.sensors_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Sensors::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sensors::CopyFrom(const Sensors& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sensors::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->sensors())) return false;
  return true;
}

void Sensors::Swap(Sensors* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    sensors_.Swap(&other->sensors_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Sensors::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sensors_descriptor_;
  metadata.reflection = Sensors_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Patrol_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Patrol_Type_descriptor_;
}
bool Patrol_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Patrol_Type Patrol::Normal;
const Patrol_Type Patrol::PopOut;
const Patrol_Type Patrol::Remapping;
const Patrol_Type Patrol::Refill;
const Patrol_Type Patrol::Type_MIN;
const Patrol_Type Patrol::Type_MAX;
const int Patrol::Type_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Patrol_Priority_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Patrol_Priority_descriptor_;
}
bool Patrol_Priority_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Patrol_Priority Patrol::Standard;
const Patrol_Priority Patrol::High;
const Patrol_Priority Patrol::Priority_MIN;
const Patrol_Priority Patrol::Priority_MAX;
const int Patrol::Priority_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Patrol_Position::kXFieldNumber;
const int Patrol_Position::kYFieldNumber;
#endif  // !_MSC_VER

Patrol_Position::Patrol_Position()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Patrol.Position)
}

void Patrol_Position::InitAsDefaultInstance() {
}

Patrol_Position::Patrol_Position(const Patrol_Position& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Patrol.Position)
}

void Patrol_Position::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0u;
  y_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Patrol_Position::~Patrol_Position() {
  // @@protoc_insertion_point(destructor:eos.Patrol.Position)
  SharedDtor();
}

void Patrol_Position::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Patrol_Position::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Patrol_Position::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Patrol_Position_descriptor_;
}

const Patrol_Position& Patrol_Position::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Patrol_Position* Patrol_Position::default_instance_ = NULL;

Patrol_Position* Patrol_Position::New() const {
  return new Patrol_Position;
}

void Patrol_Position::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Patrol_Position*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, y_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Patrol_Position::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Patrol.Position)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 x = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // required uint32 y = 2;
      case 2: {
        if (tag == 16) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Patrol.Position)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Patrol.Position)
  return false;
#undef DO_
}

void Patrol_Position::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Patrol.Position)
  // required uint32 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->x(), output);
  }

  // required uint32 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->y(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Patrol.Position)
}

::google::protobuf::uint8* Patrol_Position::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Patrol.Position)
  // required uint32 x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->x(), target);
  }

  // required uint32 y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->y(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Patrol.Position)
  return target;
}

int Patrol_Position::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->x());
    }

    // required uint32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->y());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Patrol_Position::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Patrol_Position* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Patrol_Position*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Patrol_Position::MergeFrom(const Patrol_Position& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Patrol_Position::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Patrol_Position::CopyFrom(const Patrol_Position& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Patrol_Position::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Patrol_Position::Swap(Patrol_Position* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Patrol_Position::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Patrol_Position_descriptor_;
  metadata.reflection = Patrol_Position_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Patrol_Point::kPositionFieldNumber;
const int Patrol_Point::kPriorityFieldNumber;
#endif  // !_MSC_VER

Patrol_Point::Patrol_Point()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Patrol.Point)
}

void Patrol_Point::InitAsDefaultInstance() {
  position_ = const_cast< ::eos::Patrol_Position*>(&::eos::Patrol_Position::default_instance());
}

Patrol_Point::Patrol_Point(const Patrol_Point& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Patrol.Point)
}

void Patrol_Point::SharedCtor() {
  _cached_size_ = 0;
  position_ = NULL;
  priority_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Patrol_Point::~Patrol_Point() {
  // @@protoc_insertion_point(destructor:eos.Patrol.Point)
  SharedDtor();
}

void Patrol_Point::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
  }
}

void Patrol_Point::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Patrol_Point::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Patrol_Point_descriptor_;
}

const Patrol_Point& Patrol_Point::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Patrol_Point* Patrol_Point::default_instance_ = NULL;

Patrol_Point* Patrol_Point::New() const {
  return new Patrol_Point;
}

void Patrol_Point::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_position()) {
      if (position_ != NULL) position_->::eos::Patrol_Position::Clear();
    }
    priority_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Patrol_Point::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Patrol.Point)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .eos.Patrol.Position position = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_priority;
        break;
      }

      // required .eos.Patrol.Priority priority = 2;
      case 2: {
        if (tag == 16) {
         parse_priority:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::Patrol_Priority_IsValid(value)) {
            set_priority(static_cast< ::eos::Patrol_Priority >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Patrol.Point)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Patrol.Point)
  return false;
#undef DO_
}

void Patrol_Point::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Patrol.Point)
  // required .eos.Patrol.Position position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->position(), output);
  }

  // required .eos.Patrol.Priority priority = 2;
  if (has_priority()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->priority(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Patrol.Point)
}

::google::protobuf::uint8* Patrol_Point::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Patrol.Point)
  // required .eos.Patrol.Position position = 1;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->position(), target);
  }

  // required .eos.Patrol.Priority priority = 2;
  if (has_priority()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->priority(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Patrol.Point)
  return target;
}

int Patrol_Point::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .eos.Patrol.Position position = 1;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->position());
    }

    // required .eos.Patrol.Priority priority = 2;
    if (has_priority()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->priority());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Patrol_Point::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Patrol_Point* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Patrol_Point*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Patrol_Point::MergeFrom(const Patrol_Point& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position()) {
      mutable_position()->::eos::Patrol_Position::MergeFrom(from.position());
    }
    if (from.has_priority()) {
      set_priority(from.priority());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Patrol_Point::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Patrol_Point::CopyFrom(const Patrol_Point& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Patrol_Point::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_position()) {
    if (!this->position().IsInitialized()) return false;
  }
  return true;
}

void Patrol_Point::Swap(Patrol_Point* other) {
  if (other != this) {
    std::swap(position_, other->position_);
    std::swap(priority_, other->priority_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Patrol_Point::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Patrol_Point_descriptor_;
  metadata.reflection = Patrol_Point_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Patrol::kNameFieldNumber;
const int Patrol::kTypeFieldNumber;
const int Patrol::kPointsFieldNumber;
#endif  // !_MSC_VER

Patrol::Patrol()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Patrol)
}

void Patrol::InitAsDefaultInstance() {
}

Patrol::Patrol(const Patrol& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Patrol)
}

void Patrol::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Patrol::~Patrol() {
  // @@protoc_insertion_point(destructor:eos.Patrol)
  SharedDtor();
}

void Patrol::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void Patrol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Patrol::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Patrol_descriptor_;
}

const Patrol& Patrol::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Patrol* Patrol::default_instance_ = NULL;

Patrol* Patrol::New() const {
  return new Patrol;
}

void Patrol::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    type_ = 0;
  }
  points_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Patrol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Patrol)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .eos.Patrol.Type type = 2 [default = Normal];
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::Patrol_Type_IsValid(value)) {
            set_type(static_cast< ::eos::Patrol_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_points;
        break;
      }

      // repeated .eos.Patrol.Point points = 3;
      case 3: {
        if (tag == 26) {
         parse_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_points;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Patrol)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Patrol)
  return false;
#undef DO_
}

void Patrol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Patrol)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required .eos.Patrol.Type type = 2 [default = Normal];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // repeated .eos.Patrol.Point points = 3;
  for (int i = 0; i < this->points_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->points(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Patrol)
}

::google::protobuf::uint8* Patrol::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Patrol)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .eos.Patrol.Type type = 2 [default = Normal];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // repeated .eos.Patrol.Point points = 3;
  for (int i = 0; i < this->points_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->points(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Patrol)
  return target;
}

int Patrol::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required .eos.Patrol.Type type = 2 [default = Normal];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  // repeated .eos.Patrol.Point points = 3;
  total_size += 1 * this->points_size();
  for (int i = 0; i < this->points_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->points(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Patrol::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Patrol* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Patrol*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Patrol::MergeFrom(const Patrol& from) {
  GOOGLE_CHECK_NE(&from, this);
  points_.MergeFrom(from.points_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Patrol::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Patrol::CopyFrom(const Patrol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Patrol::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->points())) return false;
  return true;
}

void Patrol::Swap(Patrol* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(type_, other->type_);
    points_.Swap(&other->points_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Patrol::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Patrol_descriptor_;
  metadata.reflection = Patrol_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Patrols::kTimestampFieldNumber;
const int Patrols::kPatrolsFieldNumber;
#endif  // !_MSC_VER

Patrols::Patrols()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Patrols)
}

void Patrols::InitAsDefaultInstance() {
}

Patrols::Patrols(const Patrols& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Patrols)
}

void Patrols::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Patrols::~Patrols() {
  // @@protoc_insertion_point(destructor:eos.Patrols)
  SharedDtor();
}

void Patrols::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Patrols::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Patrols::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Patrols_descriptor_;
}

const Patrols& Patrols::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Patrols* Patrols::default_instance_ = NULL;

Patrols* Patrols::New() const {
  return new Patrols;
}

void Patrols::Clear() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  patrols_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Patrols::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Patrols)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 timestamp = 1 [default = 0];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Patrols;
        break;
      }

      // repeated .eos.Patrol Patrols = 2;
      case 2: {
        if (tag == 18) {
         parse_Patrols:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_patrols()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_Patrols;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Patrols)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Patrols)
  return false;
#undef DO_
}

void Patrols::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Patrols)
  // required uint64 timestamp = 1 [default = 0];
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->timestamp(), output);
  }

  // repeated .eos.Patrol Patrols = 2;
  for (int i = 0; i < this->patrols_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->patrols(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Patrols)
}

::google::protobuf::uint8* Patrols::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Patrols)
  // required uint64 timestamp = 1 [default = 0];
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->timestamp(), target);
  }

  // repeated .eos.Patrol Patrols = 2;
  for (int i = 0; i < this->patrols_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->patrols(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Patrols)
  return target;
}

int Patrols::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 timestamp = 1 [default = 0];
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp());
    }

  }
  // repeated .eos.Patrol Patrols = 2;
  total_size += 1 * this->patrols_size();
  for (int i = 0; i < this->patrols_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->patrols(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Patrols::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Patrols* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Patrols*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Patrols::MergeFrom(const Patrols& from) {
  GOOGLE_CHECK_NE(&from, this);
  patrols_.MergeFrom(from.patrols_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Patrols::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Patrols::CopyFrom(const Patrols& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Patrols::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->patrols())) return false;
  return true;
}

void Patrols::Swap(Patrols* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    patrols_.Swap(&other->patrols_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Patrols::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Patrols_descriptor_;
  metadata.reflection = Patrols_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Map_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Map_Type_descriptor_;
}
bool Map_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Map_Type Map::BASE_MAP;
const Map_Type Map::REMAP_MAP;
const Map_Type Map::DISPLAY_MAP;
const Map_Type Map::Type_MIN;
const Map_Type Map::Type_MAX;
const int Map::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Map::kTimestampFieldNumber;
const int Map::kWidthFieldNumber;
const int Map::kHeightFieldNumber;
const int Map::kResolutionFieldNumber;
const int Map::kContentFieldNumber;
const int Map::kTypeFieldNumber;
#endif  // !_MSC_VER

Map::Map()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.Map)
}

void Map::InitAsDefaultInstance() {
}

Map::Map(const Map& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.Map)
}

void Map::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  timestamp_ = GOOGLE_ULONGLONG(0);
  width_ = 0u;
  height_ = 0u;
  resolution_ = 0;
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Map::~Map() {
  // @@protoc_insertion_point(destructor:eos.Map)
  SharedDtor();
}

void Map::SharedDtor() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (this != default_instance_) {
  }
}

void Map::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Map::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Map_descriptor_;
}

const Map& Map::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

Map* Map::default_instance_ = NULL;

Map* Map::New() const {
  return new Map;
}

void Map::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Map*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(timestamp_, height_);
    ZR_(resolution_, type_);
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        content_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Map::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.Map)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 timestamp = 1 [default = 0];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_width;
        break;
      }

      // required uint32 width = 2;
      case 2: {
        if (tag == 16) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_height;
        break;
      }

      // required uint32 height = 3;
      case 3: {
        if (tag == 24) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_resolution;
        break;
      }

      // required float resolution = 4;
      case 4: {
        if (tag == 37) {
         parse_resolution:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &resolution_)));
          set_has_resolution();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_content;
        break;
      }

      // required bytes content = 5;
      case 5: {
        if (tag == 42) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_content()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_type;
        break;
      }

      // required .eos.Map.Type type = 6 [default = BASE_MAP];
      case 6: {
        if (tag == 48) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::Map_Type_IsValid(value)) {
            set_type(static_cast< ::eos::Map_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.Map)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.Map)
  return false;
#undef DO_
}

void Map::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.Map)
  // required uint64 timestamp = 1 [default = 0];
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->timestamp(), output);
  }

  // required uint32 width = 2;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->width(), output);
  }

  // required uint32 height = 3;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->height(), output);
  }

  // required float resolution = 4;
  if (has_resolution()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->resolution(), output);
  }

  // required bytes content = 5;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->content(), output);
  }

  // required .eos.Map.Type type = 6 [default = BASE_MAP];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.Map)
}

::google::protobuf::uint8* Map::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.Map)
  // required uint64 timestamp = 1 [default = 0];
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->timestamp(), target);
  }

  // required uint32 width = 2;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->width(), target);
  }

  // required uint32 height = 3;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->height(), target);
  }

  // required float resolution = 4;
  if (has_resolution()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->resolution(), target);
  }

  // required bytes content = 5;
  if (has_content()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->content(), target);
  }

  // required .eos.Map.Type type = 6 [default = BASE_MAP];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.Map)
  return target;
}

int Map::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 timestamp = 1 [default = 0];
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp());
    }

    // required uint32 width = 2;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->width());
    }

    // required uint32 height = 3;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->height());
    }

    // required float resolution = 4;
    if (has_resolution()) {
      total_size += 1 + 4;
    }

    // required bytes content = 5;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->content());
    }

    // required .eos.Map.Type type = 6 [default = BASE_MAP];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Map::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Map* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Map*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Map::MergeFrom(const Map& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_resolution()) {
      set_resolution(from.resolution());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Map::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Map::CopyFrom(const Map& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Map::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void Map::Swap(Map* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(resolution_, other->resolution_);
    std::swap(content_, other->content_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Map::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Map_descriptor_;
  metadata.reflection = Map_reflection_;
  return metadata;
}


// ===================================================================

::std::string* TaskScheduled::_default_patrol_name_ = NULL;
#ifndef _MSC_VER
const int TaskScheduled::kPatrolNameFieldNumber;
const int TaskScheduled::kStartFieldNumber;
const int TaskScheduled::kStopFieldNumber;
const int TaskScheduled::kGroupIdFieldNumber;
#endif  // !_MSC_VER

TaskScheduled::TaskScheduled()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.TaskScheduled)
}

void TaskScheduled::InitAsDefaultInstance() {
}

TaskScheduled::TaskScheduled(const TaskScheduled& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.TaskScheduled)
}

void TaskScheduled::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  patrol_name_ = const_cast< ::std::string*>(_default_patrol_name_);
  start_ = GOOGLE_LONGLONG(0);
  stop_ = GOOGLE_LONGLONG(0);
  group_id_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskScheduled::~TaskScheduled() {
  // @@protoc_insertion_point(destructor:eos.TaskScheduled)
  SharedDtor();
}

void TaskScheduled::SharedDtor() {
  if (patrol_name_ != _default_patrol_name_) {
    delete patrol_name_;
  }
  if (this != default_instance_) {
  }
}

void TaskScheduled::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskScheduled::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskScheduled_descriptor_;
}

const TaskScheduled& TaskScheduled::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

TaskScheduled* TaskScheduled::default_instance_ = NULL;

TaskScheduled* TaskScheduled::New() const {
  return new TaskScheduled;
}

void TaskScheduled::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TaskScheduled*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(start_, group_id_);
    if (has_patrol_name()) {
      if (patrol_name_ != _default_patrol_name_) {
        patrol_name_->assign(*_default_patrol_name_);
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TaskScheduled::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.TaskScheduled)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string patrol_name = 1 [default = "none"];
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_patrol_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->patrol_name().data(), this->patrol_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "patrol_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_start;
        break;
      }

      // required int64 start = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_start:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &start_)));
          set_has_start();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_stop;
        break;
      }

      // required int64 stop = 3 [default = 0];
      case 3: {
        if (tag == 24) {
         parse_stop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &stop_)));
          set_has_stop();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_group_id;
        break;
      }

      // required int64 group_id = 4 [default = 0];
      case 4: {
        if (tag == 32) {
         parse_group_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.TaskScheduled)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.TaskScheduled)
  return false;
#undef DO_
}

void TaskScheduled::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.TaskScheduled)
  // required string patrol_name = 1 [default = "none"];
  if (has_patrol_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->patrol_name().data(), this->patrol_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "patrol_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->patrol_name(), output);
  }

  // required int64 start = 2 [default = 0];
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->start(), output);
  }

  // required int64 stop = 3 [default = 0];
  if (has_stop()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->stop(), output);
  }

  // required int64 group_id = 4 [default = 0];
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->group_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.TaskScheduled)
}

::google::protobuf::uint8* TaskScheduled::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.TaskScheduled)
  // required string patrol_name = 1 [default = "none"];
  if (has_patrol_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->patrol_name().data(), this->patrol_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "patrol_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->patrol_name(), target);
  }

  // required int64 start = 2 [default = 0];
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->start(), target);
  }

  // required int64 stop = 3 [default = 0];
  if (has_stop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->stop(), target);
  }

  // required int64 group_id = 4 [default = 0];
  if (has_group_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->group_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.TaskScheduled)
  return target;
}

int TaskScheduled::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string patrol_name = 1 [default = "none"];
    if (has_patrol_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->patrol_name());
    }

    // required int64 start = 2 [default = 0];
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->start());
    }

    // required int64 stop = 3 [default = 0];
    if (has_stop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->stop());
    }

    // required int64 group_id = 4 [default = 0];
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->group_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskScheduled::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TaskScheduled* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TaskScheduled*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TaskScheduled::MergeFrom(const TaskScheduled& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_patrol_name()) {
      set_patrol_name(from.patrol_name());
    }
    if (from.has_start()) {
      set_start(from.start());
    }
    if (from.has_stop()) {
      set_stop(from.stop());
    }
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TaskScheduled::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskScheduled::CopyFrom(const TaskScheduled& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskScheduled::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void TaskScheduled::Swap(TaskScheduled* other) {
  if (other != this) {
    std::swap(patrol_name_, other->patrol_name_);
    std::swap(start_, other->start_);
    std::swap(stop_, other->stop_);
    std::swap(group_id_, other->group_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TaskScheduled::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskScheduled_descriptor_;
  metadata.reflection = TaskScheduled_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TasksScheduled::kTimestampFieldNumber;
const int TasksScheduled::kTasksFieldNumber;
#endif  // !_MSC_VER

TasksScheduled::TasksScheduled()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.TasksScheduled)
}

void TasksScheduled::InitAsDefaultInstance() {
}

TasksScheduled::TasksScheduled(const TasksScheduled& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.TasksScheduled)
}

void TasksScheduled::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TasksScheduled::~TasksScheduled() {
  // @@protoc_insertion_point(destructor:eos.TasksScheduled)
  SharedDtor();
}

void TasksScheduled::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TasksScheduled::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TasksScheduled::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TasksScheduled_descriptor_;
}

const TasksScheduled& TasksScheduled::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_models_2eproto();
  return *default_instance_;
}

TasksScheduled* TasksScheduled::default_instance_ = NULL;

TasksScheduled* TasksScheduled::New() const {
  return new TasksScheduled;
}

void TasksScheduled::Clear() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  tasks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TasksScheduled::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.TasksScheduled)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 timestamp = 1 [default = 0];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_tasks;
        break;
      }

      // repeated .eos.TaskScheduled tasks = 2;
      case 2: {
        if (tag == 18) {
         parse_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tasks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_tasks;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.TasksScheduled)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.TasksScheduled)
  return false;
#undef DO_
}

void TasksScheduled::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.TasksScheduled)
  // required uint64 timestamp = 1 [default = 0];
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->timestamp(), output);
  }

  // repeated .eos.TaskScheduled tasks = 2;
  for (int i = 0; i < this->tasks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->tasks(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.TasksScheduled)
}

::google::protobuf::uint8* TasksScheduled::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.TasksScheduled)
  // required uint64 timestamp = 1 [default = 0];
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->timestamp(), target);
  }

  // repeated .eos.TaskScheduled tasks = 2;
  for (int i = 0; i < this->tasks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->tasks(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.TasksScheduled)
  return target;
}

int TasksScheduled::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 timestamp = 1 [default = 0];
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp());
    }

  }
  // repeated .eos.TaskScheduled tasks = 2;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TasksScheduled::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TasksScheduled* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TasksScheduled*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TasksScheduled::MergeFrom(const TasksScheduled& from) {
  GOOGLE_CHECK_NE(&from, this);
  tasks_.MergeFrom(from.tasks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TasksScheduled::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TasksScheduled::CopyFrom(const TasksScheduled& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TasksScheduled::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->tasks())) return false;
  return true;
}

void TasksScheduled::Swap(TasksScheduled* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    tasks_.Swap(&other->tasks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TasksScheduled::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TasksScheduled_descriptor_;
  metadata.reflection = TasksScheduled_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace eos

// @@protoc_insertion_point(global_scope)
