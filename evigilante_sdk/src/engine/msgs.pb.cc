// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msgs.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "msgs.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace eos {
namespace sdk {

namespace {

const ::google::protobuf::Descriptor* RobotDataSubscription_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotDataSubscription_reflection_ = NULL;
const ::google::protobuf::Descriptor* Protocol_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Protocol_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Protocol_Port_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Camera_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Camera_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Camera_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* RobotInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* JoystickCommand_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  JoystickCommand_reflection_ = NULL;
const ::google::protobuf::Descriptor* Turn_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Turn_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Turn_Sens_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Stop_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Stop_reflection_ = NULL;
const ::google::protobuf::Descriptor* SetRobotMode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SetRobotMode_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SetRobotMode_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* MoveTo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MoveTo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Hooter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Hooter_reflection_ = NULL;
const ::google::protobuf::Descriptor* ToggleCharging_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ToggleCharging_reflection_ = NULL;
const ::google::protobuf::Descriptor* ToggleComponentsPowerSupply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ToggleComponentsPowerSupply_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotPosition_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotPosition_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotVelocity_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotVelocity_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotState_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RobotState_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* HardwareIssue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HardwareIssue_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* HardwareIssue_Issue_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Alarm_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Alarm_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Alarm_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Alarm_Status_descriptor_ = NULL;
const ::google::protobuf::Descriptor* AlarmUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AlarmUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* BatteryState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BatteryState_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* BatteryState_State_descriptor_ = NULL;
const ::google::protobuf::Descriptor* LaserShot_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LaserShot_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotMonitoring_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotMonitoring_reflection_ = NULL;
const ::google::protobuf::Descriptor* ScoresThreshold_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ScoresThreshold_reflection_ = NULL;
const ::google::protobuf::Descriptor* ControlPatrolling_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ControlPatrolling_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ControlPatrolling_ACTION_descriptor_ = NULL;
const ::google::protobuf::Descriptor* EmergencyStop_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmergencyStop_reflection_ = NULL;
const ::google::protobuf::Descriptor* DynamicObstacle_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DynamicObstacle_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClearDynamicObstacles_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClearDynamicObstacles_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotSensor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotSensor_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RobotSensor_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* RobotSensors_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotSensors_reflection_ = NULL;
const ::google::protobuf::Descriptor* NewMapAvailable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NewMapAvailable_reflection_ = NULL;
const ::google::protobuf::Descriptor* CartoOrder_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CartoOrder_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CartoOrder_Action_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CartoState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CartoState_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CartoState_State_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CartoState_Result_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Version_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Version_reflection_ = NULL;
const ::google::protobuf::Descriptor* Reboot_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Reboot_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_msgs_2eproto() {
  protobuf_AddDesc_msgs_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "msgs.proto");
  GOOGLE_CHECK(file != NULL);
  RobotDataSubscription_descriptor_ = file->message_type(0);
  static const int RobotDataSubscription_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotDataSubscription, dataindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotDataSubscription, all_),
  };
  RobotDataSubscription_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobotDataSubscription_descriptor_,
      RobotDataSubscription::default_instance_,
      RobotDataSubscription_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotDataSubscription, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotDataSubscription, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobotDataSubscription));
  Protocol_descriptor_ = file->message_type(1);
  static const int Protocol_offsets_[1] = {
  };
  Protocol_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Protocol_descriptor_,
      Protocol::default_instance_,
      Protocol_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Protocol, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Protocol, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Protocol));
  Protocol_Port_descriptor_ = Protocol_descriptor_->enum_type(0);
  Camera_descriptor_ = file->message_type(2);
  static const int Camera_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Camera, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Camera, ip_address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Camera, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Camera, id_),
  };
  Camera_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Camera_descriptor_,
      Camera::default_instance_,
      Camera_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Camera, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Camera, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Camera));
  Camera_Type_descriptor_ = Camera_descriptor_->enum_type(0);
  RobotInfo_descriptor_ = file->message_type(3);
  static const int RobotInfo_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, uptime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, filepath_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, robot_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, camera_),
  };
  RobotInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobotInfo_descriptor_,
      RobotInfo::default_instance_,
      RobotInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobotInfo));
  JoystickCommand_descriptor_ = file->message_type(4);
  static const int JoystickCommand_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoystickCommand, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoystickCommand, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoystickCommand, super_),
  };
  JoystickCommand_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      JoystickCommand_descriptor_,
      JoystickCommand::default_instance_,
      JoystickCommand_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoystickCommand, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoystickCommand, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(JoystickCommand));
  Turn_descriptor_ = file->message_type(5);
  static const int Turn_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Turn, sens_),
  };
  Turn_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Turn_descriptor_,
      Turn::default_instance_,
      Turn_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Turn, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Turn, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Turn));
  Turn_Sens_descriptor_ = Turn_descriptor_->enum_type(0);
  Stop_descriptor_ = file->message_type(6);
  static const int Stop_offsets_[1] = {
  };
  Stop_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Stop_descriptor_,
      Stop::default_instance_,
      Stop_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stop, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stop, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Stop));
  SetRobotMode_descriptor_ = file->message_type(7);
  static const int SetRobotMode_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetRobotMode, type_),
  };
  SetRobotMode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SetRobotMode_descriptor_,
      SetRobotMode::default_instance_,
      SetRobotMode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetRobotMode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetRobotMode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SetRobotMode));
  SetRobotMode_Type_descriptor_ = SetRobotMode_descriptor_->enum_type(0);
  MoveTo_descriptor_ = file->message_type(8);
  static const int MoveTo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MoveTo, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MoveTo, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MoveTo, theta_),
  };
  MoveTo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MoveTo_descriptor_,
      MoveTo::default_instance_,
      MoveTo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MoveTo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MoveTo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MoveTo));
  Hooter_descriptor_ = file->message_type(9);
  static const int Hooter_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hooter, active_),
  };
  Hooter_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Hooter_descriptor_,
      Hooter::default_instance_,
      Hooter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hooter, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hooter, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Hooter));
  ToggleCharging_descriptor_ = file->message_type(10);
  static const int ToggleCharging_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ToggleCharging, active_),
  };
  ToggleCharging_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ToggleCharging_descriptor_,
      ToggleCharging::default_instance_,
      ToggleCharging_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ToggleCharging, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ToggleCharging, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ToggleCharging));
  ToggleComponentsPowerSupply_descriptor_ = file->message_type(11);
  static const int ToggleComponentsPowerSupply_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ToggleComponentsPowerSupply, active_),
  };
  ToggleComponentsPowerSupply_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ToggleComponentsPowerSupply_descriptor_,
      ToggleComponentsPowerSupply::default_instance_,
      ToggleComponentsPowerSupply_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ToggleComponentsPowerSupply, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ToggleComponentsPowerSupply, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ToggleComponentsPowerSupply));
  RobotPosition_descriptor_ = file->message_type(12);
  static const int RobotPosition_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPosition, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPosition, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPosition, theta_),
  };
  RobotPosition_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobotPosition_descriptor_,
      RobotPosition::default_instance_,
      RobotPosition_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPosition, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPosition, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobotPosition));
  RobotVelocity_descriptor_ = file->message_type(13);
  static const int RobotVelocity_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotVelocity, linear_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotVelocity, angular_),
  };
  RobotVelocity_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobotVelocity_descriptor_,
      RobotVelocity::default_instance_,
      RobotVelocity_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotVelocity, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotVelocity, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobotVelocity));
  RobotState_descriptor_ = file->message_type(14);
  static const int RobotState_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotState, type_),
  };
  RobotState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobotState_descriptor_,
      RobotState::default_instance_,
      RobotState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobotState));
  RobotState_Type_descriptor_ = RobotState_descriptor_->enum_type(0);
  HardwareIssue_descriptor_ = file->message_type(15);
  static const int HardwareIssue_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardwareIssue, issue_),
  };
  HardwareIssue_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HardwareIssue_descriptor_,
      HardwareIssue::default_instance_,
      HardwareIssue_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardwareIssue, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HardwareIssue, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HardwareIssue));
  HardwareIssue_Issue_descriptor_ = HardwareIssue_descriptor_->enum_type(0);
  Alarm_descriptor_ = file->message_type(16);
  static const int Alarm_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Alarm, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Alarm, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Alarm, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Alarm, distance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Alarm, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Alarm, status_),
  };
  Alarm_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Alarm_descriptor_,
      Alarm::default_instance_,
      Alarm_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Alarm, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Alarm, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Alarm));
  Alarm_Type_descriptor_ = Alarm_descriptor_->enum_type(0);
  Alarm_Status_descriptor_ = Alarm_descriptor_->enum_type(1);
  AlarmUpdate_descriptor_ = file->message_type(17);
  static const int AlarmUpdate_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AlarmUpdate, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AlarmUpdate, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AlarmUpdate, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AlarmUpdate, distance_),
  };
  AlarmUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AlarmUpdate_descriptor_,
      AlarmUpdate::default_instance_,
      AlarmUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AlarmUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AlarmUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AlarmUpdate));
  BatteryState_descriptor_ = file->message_type(18);
  static const int BatteryState_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatteryState, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatteryState, level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatteryState, tension_),
  };
  BatteryState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BatteryState_descriptor_,
      BatteryState::default_instance_,
      BatteryState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatteryState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BatteryState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BatteryState));
  BatteryState_State_descriptor_ = BatteryState_descriptor_->enum_type(0);
  LaserShot_descriptor_ = file->message_type(19);
  static const int LaserShot_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserShot, x_array_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserShot, y_array_),
  };
  LaserShot_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LaserShot_descriptor_,
      LaserShot::default_instance_,
      LaserShot_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserShot, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaserShot, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LaserShot));
  RobotMonitoring_descriptor_ = file->message_type(20);
  static const int RobotMonitoring_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMonitoring, current_score_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMonitoring, min_score_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMonitoring, max_score_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMonitoring, avg_score_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMonitoring, switch_to_mapping_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMonitoring, switch_to_localization_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMonitoring, switch_to_relocalization_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMonitoring, laser_),
  };
  RobotMonitoring_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobotMonitoring_descriptor_,
      RobotMonitoring::default_instance_,
      RobotMonitoring_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMonitoring, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMonitoring, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobotMonitoring));
  ScoresThreshold_descriptor_ = file->message_type(21);
  static const int ScoresThreshold_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScoresThreshold, switch_to_mapping_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScoresThreshold, switch_to_localization_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScoresThreshold, switch_to_relocalization_),
  };
  ScoresThreshold_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ScoresThreshold_descriptor_,
      ScoresThreshold::default_instance_,
      ScoresThreshold_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScoresThreshold, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScoresThreshold, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ScoresThreshold));
  ControlPatrolling_descriptor_ = file->message_type(22);
  static const int ControlPatrolling_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ControlPatrolling, action_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ControlPatrolling, patrol_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ControlPatrolling, duration_),
  };
  ControlPatrolling_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ControlPatrolling_descriptor_,
      ControlPatrolling::default_instance_,
      ControlPatrolling_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ControlPatrolling, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ControlPatrolling, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ControlPatrolling));
  ControlPatrolling_ACTION_descriptor_ = ControlPatrolling_descriptor_->enum_type(0);
  EmergencyStop_descriptor_ = file->message_type(23);
  static const int EmergencyStop_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmergencyStop, active_),
  };
  EmergencyStop_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmergencyStop_descriptor_,
      EmergencyStop::default_instance_,
      EmergencyStop_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmergencyStop, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmergencyStop, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmergencyStop));
  DynamicObstacle_descriptor_ = file->message_type(24);
  static const int DynamicObstacle_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DynamicObstacle, active_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DynamicObstacle, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DynamicObstacle, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DynamicObstacle, radius_),
  };
  DynamicObstacle_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DynamicObstacle_descriptor_,
      DynamicObstacle::default_instance_,
      DynamicObstacle_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DynamicObstacle, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DynamicObstacle, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DynamicObstacle));
  ClearDynamicObstacles_descriptor_ = file->message_type(25);
  static const int ClearDynamicObstacles_offsets_[1] = {
  };
  ClearDynamicObstacles_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClearDynamicObstacles_descriptor_,
      ClearDynamicObstacles::default_instance_,
      ClearDynamicObstacles_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClearDynamicObstacles, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClearDynamicObstacles, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClearDynamicObstacles));
  RobotSensor_descriptor_ = file->message_type(26);
  static const int RobotSensor_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotSensor, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotSensor, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotSensor, unit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotSensor, value_),
  };
  RobotSensor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobotSensor_descriptor_,
      RobotSensor::default_instance_,
      RobotSensor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotSensor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotSensor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobotSensor));
  RobotSensor_Type_descriptor_ = RobotSensor_descriptor_->enum_type(0);
  RobotSensors_descriptor_ = file->message_type(27);
  static const int RobotSensors_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotSensors, sensors_),
  };
  RobotSensors_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobotSensors_descriptor_,
      RobotSensors::default_instance_,
      RobotSensors_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotSensors, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotSensors, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobotSensors));
  NewMapAvailable_descriptor_ = file->message_type(28);
  static const int NewMapAvailable_offsets_[1] = {
  };
  NewMapAvailable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NewMapAvailable_descriptor_,
      NewMapAvailable::default_instance_,
      NewMapAvailable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewMapAvailable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewMapAvailable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NewMapAvailable));
  CartoOrder_descriptor_ = file->message_type(29);
  static const int CartoOrder_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartoOrder, action_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartoOrder, resolution_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartoOrder, size_),
  };
  CartoOrder_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CartoOrder_descriptor_,
      CartoOrder::default_instance_,
      CartoOrder_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartoOrder, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartoOrder, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CartoOrder));
  CartoOrder_Action_descriptor_ = CartoOrder_descriptor_->enum_type(0);
  CartoState_descriptor_ = file->message_type(30);
  static const int CartoState_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartoState, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartoState, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartoState, description_),
  };
  CartoState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CartoState_descriptor_,
      CartoState::default_instance_,
      CartoState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartoState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CartoState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CartoState));
  CartoState_State_descriptor_ = CartoState_descriptor_->enum_type(0);
  CartoState_Result_descriptor_ = CartoState_descriptor_->enum_type(1);
  Version_descriptor_ = file->message_type(31);
  static const int Version_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Version, value_),
  };
  Version_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Version_descriptor_,
      Version::default_instance_,
      Version_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Version, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Version, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Version));
  Reboot_descriptor_ = file->message_type(32);
  static const int Reboot_offsets_[1] = {
  };
  Reboot_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Reboot_descriptor_,
      Reboot::default_instance_,
      Reboot_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reboot, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Reboot, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Reboot));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_msgs_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobotDataSubscription_descriptor_, &RobotDataSubscription::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Protocol_descriptor_, &Protocol::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Camera_descriptor_, &Camera::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobotInfo_descriptor_, &RobotInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JoystickCommand_descriptor_, &JoystickCommand::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Turn_descriptor_, &Turn::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Stop_descriptor_, &Stop::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SetRobotMode_descriptor_, &SetRobotMode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MoveTo_descriptor_, &MoveTo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Hooter_descriptor_, &Hooter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ToggleCharging_descriptor_, &ToggleCharging::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ToggleComponentsPowerSupply_descriptor_, &ToggleComponentsPowerSupply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobotPosition_descriptor_, &RobotPosition::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobotVelocity_descriptor_, &RobotVelocity::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobotState_descriptor_, &RobotState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HardwareIssue_descriptor_, &HardwareIssue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Alarm_descriptor_, &Alarm::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AlarmUpdate_descriptor_, &AlarmUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BatteryState_descriptor_, &BatteryState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LaserShot_descriptor_, &LaserShot::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobotMonitoring_descriptor_, &RobotMonitoring::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ScoresThreshold_descriptor_, &ScoresThreshold::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ControlPatrolling_descriptor_, &ControlPatrolling::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmergencyStop_descriptor_, &EmergencyStop::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DynamicObstacle_descriptor_, &DynamicObstacle::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClearDynamicObstacles_descriptor_, &ClearDynamicObstacles::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobotSensor_descriptor_, &RobotSensor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobotSensors_descriptor_, &RobotSensors::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NewMapAvailable_descriptor_, &NewMapAvailable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CartoOrder_descriptor_, &CartoOrder::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CartoState_descriptor_, &CartoState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Version_descriptor_, &Version::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Reboot_descriptor_, &Reboot::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_msgs_2eproto() {
  delete RobotDataSubscription::default_instance_;
  delete RobotDataSubscription_reflection_;
  delete Protocol::default_instance_;
  delete Protocol_reflection_;
  delete Camera::default_instance_;
  delete Camera_reflection_;
  delete RobotInfo::default_instance_;
  delete RobotInfo_reflection_;
  delete JoystickCommand::default_instance_;
  delete JoystickCommand_reflection_;
  delete Turn::default_instance_;
  delete Turn_reflection_;
  delete Stop::default_instance_;
  delete Stop_reflection_;
  delete SetRobotMode::default_instance_;
  delete SetRobotMode_reflection_;
  delete MoveTo::default_instance_;
  delete MoveTo_reflection_;
  delete Hooter::default_instance_;
  delete Hooter_reflection_;
  delete ToggleCharging::default_instance_;
  delete ToggleCharging_reflection_;
  delete ToggleComponentsPowerSupply::default_instance_;
  delete ToggleComponentsPowerSupply_reflection_;
  delete RobotPosition::default_instance_;
  delete RobotPosition_reflection_;
  delete RobotVelocity::default_instance_;
  delete RobotVelocity_reflection_;
  delete RobotState::default_instance_;
  delete RobotState_reflection_;
  delete HardwareIssue::default_instance_;
  delete HardwareIssue_reflection_;
  delete Alarm::default_instance_;
  delete Alarm_reflection_;
  delete AlarmUpdate::default_instance_;
  delete AlarmUpdate_reflection_;
  delete BatteryState::default_instance_;
  delete BatteryState_reflection_;
  delete LaserShot::default_instance_;
  delete LaserShot_reflection_;
  delete RobotMonitoring::default_instance_;
  delete RobotMonitoring_reflection_;
  delete ScoresThreshold::default_instance_;
  delete ScoresThreshold_reflection_;
  delete ControlPatrolling::default_instance_;
  delete ControlPatrolling_reflection_;
  delete EmergencyStop::default_instance_;
  delete EmergencyStop_reflection_;
  delete DynamicObstacle::default_instance_;
  delete DynamicObstacle_reflection_;
  delete ClearDynamicObstacles::default_instance_;
  delete ClearDynamicObstacles_reflection_;
  delete RobotSensor::default_instance_;
  delete RobotSensor_reflection_;
  delete RobotSensors::default_instance_;
  delete RobotSensors_reflection_;
  delete NewMapAvailable::default_instance_;
  delete NewMapAvailable_reflection_;
  delete CartoOrder::default_instance_;
  delete CartoOrder_reflection_;
  delete CartoState::default_instance_;
  delete CartoState_reflection_;
  delete Version::default_instance_;
  delete Version_reflection_;
  delete Reboot::default_instance_;
  delete Reboot_reflection_;
}

void protobuf_AddDesc_msgs_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\nmsgs.proto\022\007eos.sdk\">\n\025RobotDataSubscr"
    "iption\022\021\n\tdataIndex\030\001 \003(\r\022\022\n\003All\030\002 \001(\010:\005"
    "false\"\036\n\010Protocol\"\022\n\004Port\022\n\n\004PORT\020\313\261\003\"\262\001"
    "\n\006Camera\022(\n\004type\030\001 \001(\0162\024.eos.sdk.Camera."
    "Type:\004MAIN\022\022\n\nip_address\030\002 \001(\t\022\017\n\004port\030\003"
    " \001(\r:\0010\022\r\n\002id\030\004 \001(\r:\0010\"J\n\004Type\022\010\n\004MAIN\020\000"
    "\022\013\n\007SIDE_UP\020\001\022\017\n\013SIDE_MIDDLE\020\002\022\r\n\tSIDE_D"
    "OWN\020\003\022\013\n\007THERMIC\020\004\"p\n\tRobotInfo\022\014\n\004name\030"
    "\001 \001(\t\022\016\n\006uptime\030\002 \001(\004\022\020\n\010filepath\030\003 \001(\t\022"
    "\022\n\nrobot_type\030\004 \001(\t\022\037\n\006camera\030\005 \003(\0132\017.eo"
    "s.sdk.Camera\"=\n\017JoystickCommand\022\t\n\001x\030\001 \002"
    "(\002\022\t\n\001y\030\002 \002(\002\022\024\n\005super\030\003 \001(\010:\005false\"K\n\004T"
    "urn\022&\n\004sens\030\001 \002(\0162\022.eos.sdk.Turn.Sens:\004L"
    "EFT\"\033\n\004Sens\022\010\n\004LEFT\020\000\022\t\n\005RIGHT\020\001\"\006\n\004Stop"
    "\"f\n\014SetRobotMode\0223\n\004type\030\001 \002(\0162\032.eos.sdk"
    ".SetRobotMode.Type:\tAUTOMATIC\"!\n\004Type\022\r\n"
    "\tAUTOMATIC\020\000\022\n\n\006MANUAL\020\001\"-\n\006MoveTo\022\t\n\001x\030"
    "\001 \002(\003\022\t\n\001y\030\002 \002(\003\022\r\n\005theta\030\003 \002(\001\"\030\n\006Hoote"
    "r\022\016\n\006active\030\001 \002(\010\" \n\016ToggleCharging\022\016\n\006a"
    "ctive\030\001 \002(\010\"-\n\033ToggleComponentsPowerSupp"
    "ly\022\016\n\006active\030\001 \002(\010\"4\n\rRobotPosition\022\t\n\001x"
    "\030\001 \002(\003\022\t\n\001y\030\002 \002(\003\022\r\n\005theta\030\003 \002(\001\"0\n\rRobo"
    "tVelocity\022\016\n\006linear\030\001 \002(\002\022\017\n\007angular\030\002 \002"
    "(\002\"\243\001\n\nRobotState\022&\n\004type\030\001 \002(\0162\030.eos.sd"
    "k.RobotState.Type\"m\n\004Type\022\t\n\005READY\020\000\022\014\n\010"
    "CHARGING\020\001\022\r\n\tREMAPPING\020\002\022\016\n\nPATROLLING\020"
    "\003\022\025\n\021MANUAL_CONTROLLED\020\004\022\t\n\005ALARM\020\005\022\013\n\007J"
    "OB_END\020\006\"\237\002\n\rHardwareIssue\022+\n\005issue\030\001 \002("
    "\0162\034.eos.sdk.HardwareIssue.Issue\"\340\001\n\005Issu"
    "e\022\024\n\020OBSTRUCTED_LASER\020\000\022\026\n\022MISSING_MAIN_"
    "LASER\020\001\022\032\n\026MISSING_THERMIC_CAMERA\020\002\022\032\n\026M"
    "ISSING_OPTICAL_CAMERA\020\003\022\031\n\025MISSING_CONTR"
    "OL_BOARD\020\004\022\032\n\026MISSING_SECURITY_LASER\020\005\022\017"
    "\n\013LOW_BATTERY\020\006\022\024\n\020CHARGING_FAILURE\020\007\022\023\n"
    "\017NETWORK_FAILURE\020\010\"\301\002\n\005Alarm\022\n\n\002id\030\001 \002(\r"
    "\022\t\n\001x\030\002 \002(\r\022\t\n\001y\030\003 \002(\r\022\020\n\010distance\030\004 \002(\r"
    "\022!\n\004type\030\005 \002(\0162\023.eos.sdk.Alarm.Type\022%\n\006s"
    "tatus\030\006 \002(\0162\025.eos.sdk.Alarm.Status\"\222\001\n\004T"
    "ype\022\026\n\022DISAPPEARED_OBJECT\020\001\022\022\n\016FIXED_OBS"
    "TACLE\020\002\022\023\n\017MOBILE_OBSTACLE\020\003\022\014\n\010HOTPOINT"
    "\020\004\022\030\n\024ROBOT_HARDWARE_ISSUE\020\005\022\021\n\rROBOT_BL"
    "OCKED\020\006\022\016\n\nROBOT_LOST\020\007\"%\n\006Status\022\006\n\002ON\020"
    "\000\022\007\n\003OFF\020\001\022\n\n\006UPDATE\020\002\"A\n\013AlarmUpdate\022\n\n"
    "\002id\030\001 \002(\005\022\t\n\001x\030\002 \002(\r\022\t\n\001y\030\003 \002(\r\022\020\n\010dista"
    "nce\030\004 \002(\r\"\202\001\n\014BatteryState\022*\n\005state\030\001 \002("
    "\0162\033.eos.sdk.BatteryState.State\022\r\n\005level\030"
    "\002 \002(\002\022\017\n\007tension\030\003 \002(\002\"&\n\005State\022\014\n\010CHARG"
    "ING\020\001\022\017\n\013DISCHARGING\020\002\"-\n\tLaserShot\022\017\n\007x"
    "_array\030\001 \003(\002\022\017\n\007y_array\030\002 \003(\002\"\341\001\n\017RobotM"
    "onitoring\022\025\n\rcurrent_score\030\003 \001(\004\022\021\n\tmin_"
    "score\030\004 \001(\004\022\021\n\tmax_score\030\005 \001(\004\022\021\n\tavg_sc"
    "ore\030\006 \001(\004\022\031\n\021switch_to_mapping\030\007 \001(\004\022\036\n\026"
    "switch_to_localization\030\010 \001(\004\022 \n\030switch_t"
    "o_relocalization\030\t \001(\004\022!\n\005laser\030\n \001(\0132\022."
    "eos.sdk.LaserShot\"n\n\017ScoresThreshold\022\031\n\021"
    "switch_to_mapping\030\001 \002(\004\022\036\n\026switch_to_loc"
    "alization\030\002 \002(\004\022 \n\030switch_to_relocalizat"
    "ion\030\003 \002(\004\"\214\001\n\021ControlPatrolling\0221\n\006actio"
    "n\030\001 \002(\0162!.eos.sdk.ControlPatrolling.ACTI"
    "ON\022\023\n\013patrol_name\030\002 \002(\t\022\020\n\010duration\030\003 \002("
    "\r\"\035\n\006ACTION\022\t\n\005START\020\001\022\010\n\004STOP\020\002\"\037\n\rEmer"
    "gencyStop\022\016\n\006active\030\001 \002(\010\"G\n\017DynamicObst"
    "acle\022\016\n\006active\030\001 \002(\010\022\t\n\001x\030\002 \002(\r\022\t\n\001y\030\003 \002"
    "(\r\022\016\n\006radius\030\004 \002(\r\"\027\n\025ClearDynamicObstac"
    "les\"\244\001\n\013RobotSensor\022\014\n\004path\030\001 \002(\t\022\'\n\004typ"
    "e\030\002 \002(\0162\031.eos.sdk.RobotSensor.Type\022\014\n\004un"
    "it\030\003 \002(\t\022\r\n\005value\030\004 \002(\002\"A\n\004Type\022\014\n\010DISTA"
    "NCE\020\000\022\n\n\006ON_OFF\020\001\022\017\n\013TEMPERATURE\020\002\022\016\n\nHY"
    "DROMETRY\020\003\"5\n\014RobotSensors\022%\n\007sensors\030\001 "
    "\003(\0132\024.eos.sdk.RobotSensor\"\021\n\017NewMapAvail"
    "able\"\217\001\n\nCartoOrder\022*\n\006action\030\001 \002(\0162\032.eo"
    "s.sdk.CartoOrder.Action\022\022\n\nresolution\030\002 "
    "\001(\002\022\014\n\004size\030\003 \001(\r\"3\n\006Action\022\t\n\005START\020\001\022\t"
    "\n\005PAUSE\020\002\022\010\n\004STOP\020\003\022\t\n\005ABORT\020\004\"\343\001\n\nCarto"
    "State\022(\n\005state\030\001 \002(\0162\031.eos.sdk.CartoStat"
    "e.State\022*\n\006result\030\002 \002(\0162\032.eos.sdk.CartoS"
    "tate.Result\022\023\n\013description\030\003 \002(\t\"\?\n\005Stat"
    "e\022\021\n\rSTATE_STARTED\020\001\022\020\n\014STATE_PAUSED\020\002\022\021"
    "\n\rSTATE_STOPPED\020\003\")\n\006Result\022\r\n\tRESULT_OK"
    "\020\001\022\020\n\014RESULT_ERROR\020\002\"\"\n\007Version\022\027\n\005value"
    "\030\001 \002(\004:\01020161108\"\010\n\006Reboot", 3226);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "msgs.proto", &protobuf_RegisterTypes);
  RobotDataSubscription::default_instance_ = new RobotDataSubscription();
  Protocol::default_instance_ = new Protocol();
  Camera::default_instance_ = new Camera();
  RobotInfo::default_instance_ = new RobotInfo();
  JoystickCommand::default_instance_ = new JoystickCommand();
  Turn::default_instance_ = new Turn();
  Stop::default_instance_ = new Stop();
  SetRobotMode::default_instance_ = new SetRobotMode();
  MoveTo::default_instance_ = new MoveTo();
  Hooter::default_instance_ = new Hooter();
  ToggleCharging::default_instance_ = new ToggleCharging();
  ToggleComponentsPowerSupply::default_instance_ = new ToggleComponentsPowerSupply();
  RobotPosition::default_instance_ = new RobotPosition();
  RobotVelocity::default_instance_ = new RobotVelocity();
  RobotState::default_instance_ = new RobotState();
  HardwareIssue::default_instance_ = new HardwareIssue();
  Alarm::default_instance_ = new Alarm();
  AlarmUpdate::default_instance_ = new AlarmUpdate();
  BatteryState::default_instance_ = new BatteryState();
  LaserShot::default_instance_ = new LaserShot();
  RobotMonitoring::default_instance_ = new RobotMonitoring();
  ScoresThreshold::default_instance_ = new ScoresThreshold();
  ControlPatrolling::default_instance_ = new ControlPatrolling();
  EmergencyStop::default_instance_ = new EmergencyStop();
  DynamicObstacle::default_instance_ = new DynamicObstacle();
  ClearDynamicObstacles::default_instance_ = new ClearDynamicObstacles();
  RobotSensor::default_instance_ = new RobotSensor();
  RobotSensors::default_instance_ = new RobotSensors();
  NewMapAvailable::default_instance_ = new NewMapAvailable();
  CartoOrder::default_instance_ = new CartoOrder();
  CartoState::default_instance_ = new CartoState();
  Version::default_instance_ = new Version();
  Reboot::default_instance_ = new Reboot();
  RobotDataSubscription::default_instance_->InitAsDefaultInstance();
  Protocol::default_instance_->InitAsDefaultInstance();
  Camera::default_instance_->InitAsDefaultInstance();
  RobotInfo::default_instance_->InitAsDefaultInstance();
  JoystickCommand::default_instance_->InitAsDefaultInstance();
  Turn::default_instance_->InitAsDefaultInstance();
  Stop::default_instance_->InitAsDefaultInstance();
  SetRobotMode::default_instance_->InitAsDefaultInstance();
  MoveTo::default_instance_->InitAsDefaultInstance();
  Hooter::default_instance_->InitAsDefaultInstance();
  ToggleCharging::default_instance_->InitAsDefaultInstance();
  ToggleComponentsPowerSupply::default_instance_->InitAsDefaultInstance();
  RobotPosition::default_instance_->InitAsDefaultInstance();
  RobotVelocity::default_instance_->InitAsDefaultInstance();
  RobotState::default_instance_->InitAsDefaultInstance();
  HardwareIssue::default_instance_->InitAsDefaultInstance();
  Alarm::default_instance_->InitAsDefaultInstance();
  AlarmUpdate::default_instance_->InitAsDefaultInstance();
  BatteryState::default_instance_->InitAsDefaultInstance();
  LaserShot::default_instance_->InitAsDefaultInstance();
  RobotMonitoring::default_instance_->InitAsDefaultInstance();
  ScoresThreshold::default_instance_->InitAsDefaultInstance();
  ControlPatrolling::default_instance_->InitAsDefaultInstance();
  EmergencyStop::default_instance_->InitAsDefaultInstance();
  DynamicObstacle::default_instance_->InitAsDefaultInstance();
  ClearDynamicObstacles::default_instance_->InitAsDefaultInstance();
  RobotSensor::default_instance_->InitAsDefaultInstance();
  RobotSensors::default_instance_->InitAsDefaultInstance();
  NewMapAvailable::default_instance_->InitAsDefaultInstance();
  CartoOrder::default_instance_->InitAsDefaultInstance();
  CartoState::default_instance_->InitAsDefaultInstance();
  Version::default_instance_->InitAsDefaultInstance();
  Reboot::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_msgs_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_msgs_2eproto {
  StaticDescriptorInitializer_msgs_2eproto() {
    protobuf_AddDesc_msgs_2eproto();
  }
} static_descriptor_initializer_msgs_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int RobotDataSubscription::kDataIndexFieldNumber;
const int RobotDataSubscription::kAllFieldNumber;
#endif  // !_MSC_VER

RobotDataSubscription::RobotDataSubscription()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.RobotDataSubscription)
}

void RobotDataSubscription::InitAsDefaultInstance() {
}

RobotDataSubscription::RobotDataSubscription(const RobotDataSubscription& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.RobotDataSubscription)
}

void RobotDataSubscription::SharedCtor() {
  _cached_size_ = 0;
  all_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotDataSubscription::~RobotDataSubscription() {
  // @@protoc_insertion_point(destructor:eos.sdk.RobotDataSubscription)
  SharedDtor();
}

void RobotDataSubscription::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RobotDataSubscription::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotDataSubscription::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotDataSubscription_descriptor_;
}

const RobotDataSubscription& RobotDataSubscription::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

RobotDataSubscription* RobotDataSubscription::default_instance_ = NULL;

RobotDataSubscription* RobotDataSubscription::New() const {
  return new RobotDataSubscription;
}

void RobotDataSubscription::Clear() {
  all_ = false;
  dataindex_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobotDataSubscription::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.RobotDataSubscription)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 dataIndex = 1;
      case 1: {
        if (tag == 8) {
         parse_dataIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_dataindex())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_dataindex())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_dataIndex;
        if (input->ExpectTag(16)) goto parse_All;
        break;
      }

      // optional bool All = 2 [default = false];
      case 2: {
        if (tag == 16) {
         parse_All:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &all_)));
          set_has_all();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.RobotDataSubscription)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.RobotDataSubscription)
  return false;
#undef DO_
}

void RobotDataSubscription::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.RobotDataSubscription)
  // repeated uint32 dataIndex = 1;
  for (int i = 0; i < this->dataindex_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->dataindex(i), output);
  }

  // optional bool All = 2 [default = false];
  if (has_all()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->all(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.RobotDataSubscription)
}

::google::protobuf::uint8* RobotDataSubscription::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.RobotDataSubscription)
  // repeated uint32 dataIndex = 1;
  for (int i = 0; i < this->dataindex_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->dataindex(i), target);
  }

  // optional bool All = 2 [default = false];
  if (has_all()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->all(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.RobotDataSubscription)
  return target;
}

int RobotDataSubscription::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bool All = 2 [default = false];
    if (has_all()) {
      total_size += 1 + 1;
    }

  }
  // repeated uint32 dataIndex = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->dataindex_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->dataindex(i));
    }
    total_size += 1 * this->dataindex_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotDataSubscription::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobotDataSubscription* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobotDataSubscription*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobotDataSubscription::MergeFrom(const RobotDataSubscription& from) {
  GOOGLE_CHECK_NE(&from, this);
  dataindex_.MergeFrom(from.dataindex_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_all()) {
      set_all(from.all());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobotDataSubscription::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotDataSubscription::CopyFrom(const RobotDataSubscription& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotDataSubscription::IsInitialized() const {

  return true;
}

void RobotDataSubscription::Swap(RobotDataSubscription* other) {
  if (other != this) {
    dataindex_.Swap(&other->dataindex_);
    std::swap(all_, other->all_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobotDataSubscription::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotDataSubscription_descriptor_;
  metadata.reflection = RobotDataSubscription_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Protocol_Port_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Protocol_Port_descriptor_;
}
bool Protocol_Port_IsValid(int value) {
  switch(value) {
    case 55499:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Protocol_Port Protocol::PORT;
const Protocol_Port Protocol::Port_MIN;
const Protocol_Port Protocol::Port_MAX;
const int Protocol::Port_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
#endif  // !_MSC_VER

Protocol::Protocol()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.Protocol)
}

void Protocol::InitAsDefaultInstance() {
}

Protocol::Protocol(const Protocol& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.Protocol)
}

void Protocol::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Protocol::~Protocol() {
  // @@protoc_insertion_point(destructor:eos.sdk.Protocol)
  SharedDtor();
}

void Protocol::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Protocol::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Protocol::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Protocol_descriptor_;
}

const Protocol& Protocol::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

Protocol* Protocol::default_instance_ = NULL;

Protocol* Protocol::New() const {
  return new Protocol;
}

void Protocol::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Protocol::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.Protocol)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.Protocol)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.Protocol)
  return false;
#undef DO_
}

void Protocol::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.Protocol)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.Protocol)
}

::google::protobuf::uint8* Protocol::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.Protocol)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.Protocol)
  return target;
}

int Protocol::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Protocol::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Protocol* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Protocol*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Protocol::MergeFrom(const Protocol& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Protocol::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Protocol::CopyFrom(const Protocol& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Protocol::IsInitialized() const {

  return true;
}

void Protocol::Swap(Protocol* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Protocol::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Protocol_descriptor_;
  metadata.reflection = Protocol_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Camera_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Camera_Type_descriptor_;
}
bool Camera_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Camera_Type Camera::MAIN;
const Camera_Type Camera::SIDE_UP;
const Camera_Type Camera::SIDE_MIDDLE;
const Camera_Type Camera::SIDE_DOWN;
const Camera_Type Camera::THERMIC;
const Camera_Type Camera::Type_MIN;
const Camera_Type Camera::Type_MAX;
const int Camera::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Camera::kTypeFieldNumber;
const int Camera::kIpAddressFieldNumber;
const int Camera::kPortFieldNumber;
const int Camera::kIdFieldNumber;
#endif  // !_MSC_VER

Camera::Camera()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.Camera)
}

void Camera::InitAsDefaultInstance() {
}

Camera::Camera(const Camera& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.Camera)
}

void Camera::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 0;
  ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0u;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Camera::~Camera() {
  // @@protoc_insertion_point(destructor:eos.sdk.Camera)
  SharedDtor();
}

void Camera::SharedDtor() {
  if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_address_;
  }
  if (this != default_instance_) {
  }
}

void Camera::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Camera::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Camera_descriptor_;
}

const Camera& Camera::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

Camera* Camera::default_instance_ = NULL;

Camera* Camera::New() const {
  return new Camera;
}

void Camera::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Camera*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(type_, id_);
    if (has_ip_address()) {
      if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_address_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Camera::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.Camera)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .eos.sdk.Camera.Type type = 1 [default = MAIN];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::Camera_Type_IsValid(value)) {
            set_type(static_cast< ::eos::sdk::Camera_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ip_address;
        break;
      }

      // optional string ip_address = 2;
      case 2: {
        if (tag == 18) {
         parse_ip_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ip_address().data(), this->ip_address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "ip_address");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // optional uint32 port = 3 [default = 0];
      case 3: {
        if (tag == 24) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_id;
        break;
      }

      // optional uint32 id = 4 [default = 0];
      case 4: {
        if (tag == 32) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.Camera)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.Camera)
  return false;
#undef DO_
}

void Camera::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.Camera)
  // optional .eos.sdk.Camera.Type type = 1 [default = MAIN];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional string ip_address = 2;
  if (has_ip_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip_address().data(), this->ip_address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip_address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ip_address(), output);
  }

  // optional uint32 port = 3 [default = 0];
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->port(), output);
  }

  // optional uint32 id = 4 [default = 0];
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.Camera)
}

::google::protobuf::uint8* Camera::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.Camera)
  // optional .eos.sdk.Camera.Type type = 1 [default = MAIN];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional string ip_address = 2;
  if (has_ip_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip_address().data(), this->ip_address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "ip_address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ip_address(), target);
  }

  // optional uint32 port = 3 [default = 0];
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->port(), target);
  }

  // optional uint32 id = 4 [default = 0];
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.Camera)
  return target;
}

int Camera::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .eos.sdk.Camera.Type type = 1 [default = MAIN];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string ip_address = 2;
    if (has_ip_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip_address());
    }

    // optional uint32 port = 3 [default = 0];
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

    // optional uint32 id = 4 [default = 0];
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Camera::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Camera* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Camera*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Camera::MergeFrom(const Camera& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ip_address()) {
      set_ip_address(from.ip_address());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Camera::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Camera::CopyFrom(const Camera& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Camera::IsInitialized() const {

  return true;
}

void Camera::Swap(Camera* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(ip_address_, other->ip_address_);
    std::swap(port_, other->port_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Camera::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Camera_descriptor_;
  metadata.reflection = Camera_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RobotInfo::kNameFieldNumber;
const int RobotInfo::kUptimeFieldNumber;
const int RobotInfo::kFilepathFieldNumber;
const int RobotInfo::kRobotTypeFieldNumber;
const int RobotInfo::kCameraFieldNumber;
#endif  // !_MSC_VER

RobotInfo::RobotInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.RobotInfo)
}

void RobotInfo::InitAsDefaultInstance() {
}

RobotInfo::RobotInfo(const RobotInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.RobotInfo)
}

void RobotInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uptime_ = GOOGLE_ULONGLONG(0);
  filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  robot_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotInfo::~RobotInfo() {
  // @@protoc_insertion_point(destructor:eos.sdk.RobotInfo)
  SharedDtor();
}

void RobotInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filepath_;
  }
  if (robot_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete robot_type_;
  }
  if (this != default_instance_) {
  }
}

void RobotInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotInfo_descriptor_;
}

const RobotInfo& RobotInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

RobotInfo* RobotInfo::default_instance_ = NULL;

RobotInfo* RobotInfo::New() const {
  return new RobotInfo;
}

void RobotInfo::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    uptime_ = GOOGLE_ULONGLONG(0);
    if (has_filepath()) {
      if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        filepath_->clear();
      }
    }
    if (has_robot_type()) {
      if (robot_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        robot_type_->clear();
      }
    }
  }
  camera_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobotInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.RobotInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_uptime;
        break;
      }

      // optional uint64 uptime = 2;
      case 2: {
        if (tag == 16) {
         parse_uptime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &uptime_)));
          set_has_uptime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_filepath;
        break;
      }

      // optional string filepath = 3;
      case 3: {
        if (tag == 26) {
         parse_filepath:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filepath()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->filepath().data(), this->filepath().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "filepath");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_robot_type;
        break;
      }

      // optional string robot_type = 4;
      case 4: {
        if (tag == 34) {
         parse_robot_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_robot_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->robot_type().data(), this->robot_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "robot_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_camera;
        break;
      }

      // repeated .eos.sdk.Camera camera = 5;
      case 5: {
        if (tag == 42) {
         parse_camera:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_camera()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_camera;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.RobotInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.RobotInfo)
  return false;
#undef DO_
}

void RobotInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.RobotInfo)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional uint64 uptime = 2;
  if (has_uptime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->uptime(), output);
  }

  // optional string filepath = 3;
  if (has_filepath()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filepath().data(), this->filepath().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filepath");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->filepath(), output);
  }

  // optional string robot_type = 4;
  if (has_robot_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->robot_type().data(), this->robot_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robot_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->robot_type(), output);
  }

  // repeated .eos.sdk.Camera camera = 5;
  for (int i = 0; i < this->camera_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->camera(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.RobotInfo)
}

::google::protobuf::uint8* RobotInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.RobotInfo)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional uint64 uptime = 2;
  if (has_uptime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->uptime(), target);
  }

  // optional string filepath = 3;
  if (has_filepath()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filepath().data(), this->filepath().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filepath");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->filepath(), target);
  }

  // optional string robot_type = 4;
  if (has_robot_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->robot_type().data(), this->robot_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "robot_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->robot_type(), target);
  }

  // repeated .eos.sdk.Camera camera = 5;
  for (int i = 0; i < this->camera_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->camera(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.RobotInfo)
  return target;
}

int RobotInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint64 uptime = 2;
    if (has_uptime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->uptime());
    }

    // optional string filepath = 3;
    if (has_filepath()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filepath());
    }

    // optional string robot_type = 4;
    if (has_robot_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->robot_type());
    }

  }
  // repeated .eos.sdk.Camera camera = 5;
  total_size += 1 * this->camera_size();
  for (int i = 0; i < this->camera_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->camera(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobotInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobotInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobotInfo::MergeFrom(const RobotInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  camera_.MergeFrom(from.camera_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_uptime()) {
      set_uptime(from.uptime());
    }
    if (from.has_filepath()) {
      set_filepath(from.filepath());
    }
    if (from.has_robot_type()) {
      set_robot_type(from.robot_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobotInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotInfo::CopyFrom(const RobotInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotInfo::IsInitialized() const {

  return true;
}

void RobotInfo::Swap(RobotInfo* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(uptime_, other->uptime_);
    std::swap(filepath_, other->filepath_);
    std::swap(robot_type_, other->robot_type_);
    camera_.Swap(&other->camera_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobotInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotInfo_descriptor_;
  metadata.reflection = RobotInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int JoystickCommand::kXFieldNumber;
const int JoystickCommand::kYFieldNumber;
const int JoystickCommand::kSuperFieldNumber;
#endif  // !_MSC_VER

JoystickCommand::JoystickCommand()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.JoystickCommand)
}

void JoystickCommand::InitAsDefaultInstance() {
}

JoystickCommand::JoystickCommand(const JoystickCommand& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.JoystickCommand)
}

void JoystickCommand::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  super_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoystickCommand::~JoystickCommand() {
  // @@protoc_insertion_point(destructor:eos.sdk.JoystickCommand)
  SharedDtor();
}

void JoystickCommand::SharedDtor() {
  if (this != default_instance_) {
  }
}

void JoystickCommand::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* JoystickCommand::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return JoystickCommand_descriptor_;
}

const JoystickCommand& JoystickCommand::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

JoystickCommand* JoystickCommand::default_instance_ = NULL;

JoystickCommand* JoystickCommand::New() const {
  return new JoystickCommand;
}

void JoystickCommand::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<JoystickCommand*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, super_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JoystickCommand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.JoystickCommand)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_super;
        break;
      }

      // optional bool super = 3 [default = false];
      case 3: {
        if (tag == 24) {
         parse_super:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &super_)));
          set_has_super();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.JoystickCommand)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.JoystickCommand)
  return false;
#undef DO_
}

void JoystickCommand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.JoystickCommand)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // optional bool super = 3 [default = false];
  if (has_super()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->super(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.JoystickCommand)
}

::google::protobuf::uint8* JoystickCommand::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.JoystickCommand)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // optional bool super = 3 [default = false];
  if (has_super()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->super(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.JoystickCommand)
  return target;
}

int JoystickCommand::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float y = 2;
    if (has_y()) {
      total_size += 1 + 4;
    }

    // optional bool super = 3 [default = false];
    if (has_super()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoystickCommand::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JoystickCommand* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JoystickCommand*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void JoystickCommand::MergeFrom(const JoystickCommand& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_super()) {
      set_super(from.super());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JoystickCommand::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JoystickCommand::CopyFrom(const JoystickCommand& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoystickCommand::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void JoystickCommand::Swap(JoystickCommand* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(super_, other->super_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata JoystickCommand::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = JoystickCommand_descriptor_;
  metadata.reflection = JoystickCommand_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Turn_Sens_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Turn_Sens_descriptor_;
}
bool Turn_Sens_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Turn_Sens Turn::LEFT;
const Turn_Sens Turn::RIGHT;
const Turn_Sens Turn::Sens_MIN;
const Turn_Sens Turn::Sens_MAX;
const int Turn::Sens_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Turn::kSensFieldNumber;
#endif  // !_MSC_VER

Turn::Turn()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.Turn)
}

void Turn::InitAsDefaultInstance() {
}

Turn::Turn(const Turn& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.Turn)
}

void Turn::SharedCtor() {
  _cached_size_ = 0;
  sens_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Turn::~Turn() {
  // @@protoc_insertion_point(destructor:eos.sdk.Turn)
  SharedDtor();
}

void Turn::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Turn::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Turn::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Turn_descriptor_;
}

const Turn& Turn::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

Turn* Turn::default_instance_ = NULL;

Turn* Turn::New() const {
  return new Turn;
}

void Turn::Clear() {
  sens_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Turn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.Turn)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .eos.sdk.Turn.Sens sens = 1 [default = LEFT];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::Turn_Sens_IsValid(value)) {
            set_sens(static_cast< ::eos::sdk::Turn_Sens >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.Turn)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.Turn)
  return false;
#undef DO_
}

void Turn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.Turn)
  // required .eos.sdk.Turn.Sens sens = 1 [default = LEFT];
  if (has_sens()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->sens(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.Turn)
}

::google::protobuf::uint8* Turn::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.Turn)
  // required .eos.sdk.Turn.Sens sens = 1 [default = LEFT];
  if (has_sens()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->sens(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.Turn)
  return target;
}

int Turn::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .eos.sdk.Turn.Sens sens = 1 [default = LEFT];
    if (has_sens()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sens());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Turn::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Turn* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Turn*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Turn::MergeFrom(const Turn& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sens()) {
      set_sens(from.sens());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Turn::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Turn::CopyFrom(const Turn& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Turn::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Turn::Swap(Turn* other) {
  if (other != this) {
    std::swap(sens_, other->sens_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Turn::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Turn_descriptor_;
  metadata.reflection = Turn_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

Stop::Stop()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.Stop)
}

void Stop::InitAsDefaultInstance() {
}

Stop::Stop(const Stop& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.Stop)
}

void Stop::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Stop::~Stop() {
  // @@protoc_insertion_point(destructor:eos.sdk.Stop)
  SharedDtor();
}

void Stop::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Stop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Stop::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Stop_descriptor_;
}

const Stop& Stop::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

Stop* Stop::default_instance_ = NULL;

Stop* Stop::New() const {
  return new Stop;
}

void Stop::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Stop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.Stop)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.Stop)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.Stop)
  return false;
#undef DO_
}

void Stop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.Stop)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.Stop)
}

::google::protobuf::uint8* Stop::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.Stop)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.Stop)
  return target;
}

int Stop::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Stop::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Stop* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Stop*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Stop::MergeFrom(const Stop& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Stop::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Stop::CopyFrom(const Stop& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stop::IsInitialized() const {

  return true;
}

void Stop::Swap(Stop* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Stop::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Stop_descriptor_;
  metadata.reflection = Stop_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SetRobotMode_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SetRobotMode_Type_descriptor_;
}
bool SetRobotMode_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SetRobotMode_Type SetRobotMode::AUTOMATIC;
const SetRobotMode_Type SetRobotMode::MANUAL;
const SetRobotMode_Type SetRobotMode::Type_MIN;
const SetRobotMode_Type SetRobotMode::Type_MAX;
const int SetRobotMode::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SetRobotMode::kTypeFieldNumber;
#endif  // !_MSC_VER

SetRobotMode::SetRobotMode()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.SetRobotMode)
}

void SetRobotMode::InitAsDefaultInstance() {
}

SetRobotMode::SetRobotMode(const SetRobotMode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.SetRobotMode)
}

void SetRobotMode::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetRobotMode::~SetRobotMode() {
  // @@protoc_insertion_point(destructor:eos.sdk.SetRobotMode)
  SharedDtor();
}

void SetRobotMode::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SetRobotMode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SetRobotMode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SetRobotMode_descriptor_;
}

const SetRobotMode& SetRobotMode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

SetRobotMode* SetRobotMode::default_instance_ = NULL;

SetRobotMode* SetRobotMode::New() const {
  return new SetRobotMode;
}

void SetRobotMode::Clear() {
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SetRobotMode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.SetRobotMode)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .eos.sdk.SetRobotMode.Type type = 1 [default = AUTOMATIC];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::SetRobotMode_Type_IsValid(value)) {
            set_type(static_cast< ::eos::sdk::SetRobotMode_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.SetRobotMode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.SetRobotMode)
  return false;
#undef DO_
}

void SetRobotMode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.SetRobotMode)
  // required .eos.sdk.SetRobotMode.Type type = 1 [default = AUTOMATIC];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.SetRobotMode)
}

::google::protobuf::uint8* SetRobotMode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.SetRobotMode)
  // required .eos.sdk.SetRobotMode.Type type = 1 [default = AUTOMATIC];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.SetRobotMode)
  return target;
}

int SetRobotMode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .eos.sdk.SetRobotMode.Type type = 1 [default = AUTOMATIC];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetRobotMode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SetRobotMode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SetRobotMode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SetRobotMode::MergeFrom(const SetRobotMode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SetRobotMode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetRobotMode::CopyFrom(const SetRobotMode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetRobotMode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SetRobotMode::Swap(SetRobotMode* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SetRobotMode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SetRobotMode_descriptor_;
  metadata.reflection = SetRobotMode_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MoveTo::kXFieldNumber;
const int MoveTo::kYFieldNumber;
const int MoveTo::kThetaFieldNumber;
#endif  // !_MSC_VER

MoveTo::MoveTo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.MoveTo)
}

void MoveTo::InitAsDefaultInstance() {
}

MoveTo::MoveTo(const MoveTo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.MoveTo)
}

void MoveTo::SharedCtor() {
  _cached_size_ = 0;
  x_ = GOOGLE_LONGLONG(0);
  y_ = GOOGLE_LONGLONG(0);
  theta_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MoveTo::~MoveTo() {
  // @@protoc_insertion_point(destructor:eos.sdk.MoveTo)
  SharedDtor();
}

void MoveTo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MoveTo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MoveTo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MoveTo_descriptor_;
}

const MoveTo& MoveTo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

MoveTo* MoveTo::default_instance_ = NULL;

MoveTo* MoveTo::New() const {
  return new MoveTo;
}

void MoveTo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MoveTo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, theta_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MoveTo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.MoveTo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 x = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // required int64 y = 2;
      case 2: {
        if (tag == 16) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_theta;
        break;
      }

      // required double theta = 3;
      case 3: {
        if (tag == 25) {
         parse_theta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &theta_)));
          set_has_theta();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.MoveTo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.MoveTo)
  return false;
#undef DO_
}

void MoveTo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.MoveTo)
  // required int64 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->x(), output);
  }

  // required int64 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->y(), output);
  }

  // required double theta = 3;
  if (has_theta()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->theta(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.MoveTo)
}

::google::protobuf::uint8* MoveTo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.MoveTo)
  // required int64 x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->x(), target);
  }

  // required int64 y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->y(), target);
  }

  // required double theta = 3;
  if (has_theta()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->theta(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.MoveTo)
  return target;
}

int MoveTo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->x());
    }

    // required int64 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->y());
    }

    // required double theta = 3;
    if (has_theta()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MoveTo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MoveTo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MoveTo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MoveTo::MergeFrom(const MoveTo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_theta()) {
      set_theta(from.theta());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MoveTo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MoveTo::CopyFrom(const MoveTo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MoveTo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void MoveTo::Swap(MoveTo* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(theta_, other->theta_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MoveTo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MoveTo_descriptor_;
  metadata.reflection = MoveTo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Hooter::kActiveFieldNumber;
#endif  // !_MSC_VER

Hooter::Hooter()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.Hooter)
}

void Hooter::InitAsDefaultInstance() {
}

Hooter::Hooter(const Hooter& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.Hooter)
}

void Hooter::SharedCtor() {
  _cached_size_ = 0;
  active_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Hooter::~Hooter() {
  // @@protoc_insertion_point(destructor:eos.sdk.Hooter)
  SharedDtor();
}

void Hooter::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Hooter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Hooter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Hooter_descriptor_;
}

const Hooter& Hooter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

Hooter* Hooter::default_instance_ = NULL;

Hooter* Hooter::New() const {
  return new Hooter;
}

void Hooter::Clear() {
  active_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Hooter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.Hooter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool active = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &active_)));
          set_has_active();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.Hooter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.Hooter)
  return false;
#undef DO_
}

void Hooter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.Hooter)
  // required bool active = 1;
  if (has_active()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->active(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.Hooter)
}

::google::protobuf::uint8* Hooter::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.Hooter)
  // required bool active = 1;
  if (has_active()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->active(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.Hooter)
  return target;
}

int Hooter::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool active = 1;
    if (has_active()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Hooter::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Hooter* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Hooter*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Hooter::MergeFrom(const Hooter& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_active()) {
      set_active(from.active());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Hooter::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Hooter::CopyFrom(const Hooter& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hooter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Hooter::Swap(Hooter* other) {
  if (other != this) {
    std::swap(active_, other->active_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Hooter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Hooter_descriptor_;
  metadata.reflection = Hooter_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ToggleCharging::kActiveFieldNumber;
#endif  // !_MSC_VER

ToggleCharging::ToggleCharging()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.ToggleCharging)
}

void ToggleCharging::InitAsDefaultInstance() {
}

ToggleCharging::ToggleCharging(const ToggleCharging& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.ToggleCharging)
}

void ToggleCharging::SharedCtor() {
  _cached_size_ = 0;
  active_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ToggleCharging::~ToggleCharging() {
  // @@protoc_insertion_point(destructor:eos.sdk.ToggleCharging)
  SharedDtor();
}

void ToggleCharging::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ToggleCharging::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ToggleCharging::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ToggleCharging_descriptor_;
}

const ToggleCharging& ToggleCharging::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

ToggleCharging* ToggleCharging::default_instance_ = NULL;

ToggleCharging* ToggleCharging::New() const {
  return new ToggleCharging;
}

void ToggleCharging::Clear() {
  active_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ToggleCharging::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.ToggleCharging)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool active = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &active_)));
          set_has_active();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.ToggleCharging)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.ToggleCharging)
  return false;
#undef DO_
}

void ToggleCharging::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.ToggleCharging)
  // required bool active = 1;
  if (has_active()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->active(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.ToggleCharging)
}

::google::protobuf::uint8* ToggleCharging::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.ToggleCharging)
  // required bool active = 1;
  if (has_active()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->active(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.ToggleCharging)
  return target;
}

int ToggleCharging::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool active = 1;
    if (has_active()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ToggleCharging::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ToggleCharging* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ToggleCharging*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ToggleCharging::MergeFrom(const ToggleCharging& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_active()) {
      set_active(from.active());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ToggleCharging::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ToggleCharging::CopyFrom(const ToggleCharging& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ToggleCharging::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ToggleCharging::Swap(ToggleCharging* other) {
  if (other != this) {
    std::swap(active_, other->active_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ToggleCharging::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ToggleCharging_descriptor_;
  metadata.reflection = ToggleCharging_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ToggleComponentsPowerSupply::kActiveFieldNumber;
#endif  // !_MSC_VER

ToggleComponentsPowerSupply::ToggleComponentsPowerSupply()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.ToggleComponentsPowerSupply)
}

void ToggleComponentsPowerSupply::InitAsDefaultInstance() {
}

ToggleComponentsPowerSupply::ToggleComponentsPowerSupply(const ToggleComponentsPowerSupply& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.ToggleComponentsPowerSupply)
}

void ToggleComponentsPowerSupply::SharedCtor() {
  _cached_size_ = 0;
  active_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ToggleComponentsPowerSupply::~ToggleComponentsPowerSupply() {
  // @@protoc_insertion_point(destructor:eos.sdk.ToggleComponentsPowerSupply)
  SharedDtor();
}

void ToggleComponentsPowerSupply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ToggleComponentsPowerSupply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ToggleComponentsPowerSupply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ToggleComponentsPowerSupply_descriptor_;
}

const ToggleComponentsPowerSupply& ToggleComponentsPowerSupply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

ToggleComponentsPowerSupply* ToggleComponentsPowerSupply::default_instance_ = NULL;

ToggleComponentsPowerSupply* ToggleComponentsPowerSupply::New() const {
  return new ToggleComponentsPowerSupply;
}

void ToggleComponentsPowerSupply::Clear() {
  active_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ToggleComponentsPowerSupply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.ToggleComponentsPowerSupply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool active = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &active_)));
          set_has_active();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.ToggleComponentsPowerSupply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.ToggleComponentsPowerSupply)
  return false;
#undef DO_
}

void ToggleComponentsPowerSupply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.ToggleComponentsPowerSupply)
  // required bool active = 1;
  if (has_active()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->active(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.ToggleComponentsPowerSupply)
}

::google::protobuf::uint8* ToggleComponentsPowerSupply::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.ToggleComponentsPowerSupply)
  // required bool active = 1;
  if (has_active()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->active(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.ToggleComponentsPowerSupply)
  return target;
}

int ToggleComponentsPowerSupply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool active = 1;
    if (has_active()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ToggleComponentsPowerSupply::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ToggleComponentsPowerSupply* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ToggleComponentsPowerSupply*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ToggleComponentsPowerSupply::MergeFrom(const ToggleComponentsPowerSupply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_active()) {
      set_active(from.active());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ToggleComponentsPowerSupply::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ToggleComponentsPowerSupply::CopyFrom(const ToggleComponentsPowerSupply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ToggleComponentsPowerSupply::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ToggleComponentsPowerSupply::Swap(ToggleComponentsPowerSupply* other) {
  if (other != this) {
    std::swap(active_, other->active_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ToggleComponentsPowerSupply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ToggleComponentsPowerSupply_descriptor_;
  metadata.reflection = ToggleComponentsPowerSupply_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RobotPosition::kXFieldNumber;
const int RobotPosition::kYFieldNumber;
const int RobotPosition::kThetaFieldNumber;
#endif  // !_MSC_VER

RobotPosition::RobotPosition()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.RobotPosition)
}

void RobotPosition::InitAsDefaultInstance() {
}

RobotPosition::RobotPosition(const RobotPosition& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.RobotPosition)
}

void RobotPosition::SharedCtor() {
  _cached_size_ = 0;
  x_ = GOOGLE_LONGLONG(0);
  y_ = GOOGLE_LONGLONG(0);
  theta_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotPosition::~RobotPosition() {
  // @@protoc_insertion_point(destructor:eos.sdk.RobotPosition)
  SharedDtor();
}

void RobotPosition::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RobotPosition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotPosition::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotPosition_descriptor_;
}

const RobotPosition& RobotPosition::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

RobotPosition* RobotPosition::default_instance_ = NULL;

RobotPosition* RobotPosition::New() const {
  return new RobotPosition;
}

void RobotPosition::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RobotPosition*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, theta_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobotPosition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.RobotPosition)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 x = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // required int64 y = 2;
      case 2: {
        if (tag == 16) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_theta;
        break;
      }

      // required double theta = 3;
      case 3: {
        if (tag == 25) {
         parse_theta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &theta_)));
          set_has_theta();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.RobotPosition)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.RobotPosition)
  return false;
#undef DO_
}

void RobotPosition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.RobotPosition)
  // required int64 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->x(), output);
  }

  // required int64 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->y(), output);
  }

  // required double theta = 3;
  if (has_theta()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->theta(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.RobotPosition)
}

::google::protobuf::uint8* RobotPosition::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.RobotPosition)
  // required int64 x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->x(), target);
  }

  // required int64 y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->y(), target);
  }

  // required double theta = 3;
  if (has_theta()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->theta(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.RobotPosition)
  return target;
}

int RobotPosition::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->x());
    }

    // required int64 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->y());
    }

    // required double theta = 3;
    if (has_theta()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotPosition::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobotPosition* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobotPosition*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobotPosition::MergeFrom(const RobotPosition& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_theta()) {
      set_theta(from.theta());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobotPosition::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotPosition::CopyFrom(const RobotPosition& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotPosition::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RobotPosition::Swap(RobotPosition* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(theta_, other->theta_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobotPosition::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotPosition_descriptor_;
  metadata.reflection = RobotPosition_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RobotVelocity::kLinearFieldNumber;
const int RobotVelocity::kAngularFieldNumber;
#endif  // !_MSC_VER

RobotVelocity::RobotVelocity()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.RobotVelocity)
}

void RobotVelocity::InitAsDefaultInstance() {
}

RobotVelocity::RobotVelocity(const RobotVelocity& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.RobotVelocity)
}

void RobotVelocity::SharedCtor() {
  _cached_size_ = 0;
  linear_ = 0;
  angular_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotVelocity::~RobotVelocity() {
  // @@protoc_insertion_point(destructor:eos.sdk.RobotVelocity)
  SharedDtor();
}

void RobotVelocity::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RobotVelocity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotVelocity::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotVelocity_descriptor_;
}

const RobotVelocity& RobotVelocity::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

RobotVelocity* RobotVelocity::default_instance_ = NULL;

RobotVelocity* RobotVelocity::New() const {
  return new RobotVelocity;
}

void RobotVelocity::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RobotVelocity*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(linear_, angular_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobotVelocity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.RobotVelocity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float linear = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &linear_)));
          set_has_linear();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_angular;
        break;
      }

      // required float angular = 2;
      case 2: {
        if (tag == 21) {
         parse_angular:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angular_)));
          set_has_angular();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.RobotVelocity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.RobotVelocity)
  return false;
#undef DO_
}

void RobotVelocity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.RobotVelocity)
  // required float linear = 1;
  if (has_linear()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->linear(), output);
  }

  // required float angular = 2;
  if (has_angular()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->angular(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.RobotVelocity)
}

::google::protobuf::uint8* RobotVelocity::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.RobotVelocity)
  // required float linear = 1;
  if (has_linear()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->linear(), target);
  }

  // required float angular = 2;
  if (has_angular()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->angular(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.RobotVelocity)
  return target;
}

int RobotVelocity::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float linear = 1;
    if (has_linear()) {
      total_size += 1 + 4;
    }

    // required float angular = 2;
    if (has_angular()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotVelocity::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobotVelocity* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobotVelocity*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobotVelocity::MergeFrom(const RobotVelocity& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_linear()) {
      set_linear(from.linear());
    }
    if (from.has_angular()) {
      set_angular(from.angular());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobotVelocity::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotVelocity::CopyFrom(const RobotVelocity& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotVelocity::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RobotVelocity::Swap(RobotVelocity* other) {
  if (other != this) {
    std::swap(linear_, other->linear_);
    std::swap(angular_, other->angular_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobotVelocity::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotVelocity_descriptor_;
  metadata.reflection = RobotVelocity_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* RobotState_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotState_Type_descriptor_;
}
bool RobotState_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const RobotState_Type RobotState::READY;
const RobotState_Type RobotState::CHARGING;
const RobotState_Type RobotState::REMAPPING;
const RobotState_Type RobotState::PATROLLING;
const RobotState_Type RobotState::MANUAL_CONTROLLED;
const RobotState_Type RobotState::ALARM;
const RobotState_Type RobotState::JOB_END;
const RobotState_Type RobotState::Type_MIN;
const RobotState_Type RobotState::Type_MAX;
const int RobotState::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int RobotState::kTypeFieldNumber;
#endif  // !_MSC_VER

RobotState::RobotState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.RobotState)
}

void RobotState::InitAsDefaultInstance() {
}

RobotState::RobotState(const RobotState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.RobotState)
}

void RobotState::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotState::~RobotState() {
  // @@protoc_insertion_point(destructor:eos.sdk.RobotState)
  SharedDtor();
}

void RobotState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RobotState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotState_descriptor_;
}

const RobotState& RobotState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

RobotState* RobotState::default_instance_ = NULL;

RobotState* RobotState::New() const {
  return new RobotState;
}

void RobotState::Clear() {
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobotState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.RobotState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .eos.sdk.RobotState.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::RobotState_Type_IsValid(value)) {
            set_type(static_cast< ::eos::sdk::RobotState_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.RobotState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.RobotState)
  return false;
#undef DO_
}

void RobotState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.RobotState)
  // required .eos.sdk.RobotState.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.RobotState)
}

::google::protobuf::uint8* RobotState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.RobotState)
  // required .eos.sdk.RobotState.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.RobotState)
  return target;
}

int RobotState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .eos.sdk.RobotState.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobotState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobotState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobotState::MergeFrom(const RobotState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobotState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotState::CopyFrom(const RobotState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RobotState::Swap(RobotState* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobotState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotState_descriptor_;
  metadata.reflection = RobotState_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* HardwareIssue_Issue_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HardwareIssue_Issue_descriptor_;
}
bool HardwareIssue_Issue_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const HardwareIssue_Issue HardwareIssue::OBSTRUCTED_LASER;
const HardwareIssue_Issue HardwareIssue::MISSING_MAIN_LASER;
const HardwareIssue_Issue HardwareIssue::MISSING_THERMIC_CAMERA;
const HardwareIssue_Issue HardwareIssue::MISSING_OPTICAL_CAMERA;
const HardwareIssue_Issue HardwareIssue::MISSING_CONTROL_BOARD;
const HardwareIssue_Issue HardwareIssue::MISSING_SECURITY_LASER;
const HardwareIssue_Issue HardwareIssue::LOW_BATTERY;
const HardwareIssue_Issue HardwareIssue::CHARGING_FAILURE;
const HardwareIssue_Issue HardwareIssue::NETWORK_FAILURE;
const HardwareIssue_Issue HardwareIssue::Issue_MIN;
const HardwareIssue_Issue HardwareIssue::Issue_MAX;
const int HardwareIssue::Issue_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int HardwareIssue::kIssueFieldNumber;
#endif  // !_MSC_VER

HardwareIssue::HardwareIssue()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.HardwareIssue)
}

void HardwareIssue::InitAsDefaultInstance() {
}

HardwareIssue::HardwareIssue(const HardwareIssue& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.HardwareIssue)
}

void HardwareIssue::SharedCtor() {
  _cached_size_ = 0;
  issue_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HardwareIssue::~HardwareIssue() {
  // @@protoc_insertion_point(destructor:eos.sdk.HardwareIssue)
  SharedDtor();
}

void HardwareIssue::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HardwareIssue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HardwareIssue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HardwareIssue_descriptor_;
}

const HardwareIssue& HardwareIssue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

HardwareIssue* HardwareIssue::default_instance_ = NULL;

HardwareIssue* HardwareIssue::New() const {
  return new HardwareIssue;
}

void HardwareIssue::Clear() {
  issue_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HardwareIssue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.HardwareIssue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .eos.sdk.HardwareIssue.Issue issue = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::HardwareIssue_Issue_IsValid(value)) {
            set_issue(static_cast< ::eos::sdk::HardwareIssue_Issue >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.HardwareIssue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.HardwareIssue)
  return false;
#undef DO_
}

void HardwareIssue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.HardwareIssue)
  // required .eos.sdk.HardwareIssue.Issue issue = 1;
  if (has_issue()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->issue(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.HardwareIssue)
}

::google::protobuf::uint8* HardwareIssue::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.HardwareIssue)
  // required .eos.sdk.HardwareIssue.Issue issue = 1;
  if (has_issue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->issue(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.HardwareIssue)
  return target;
}

int HardwareIssue::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .eos.sdk.HardwareIssue.Issue issue = 1;
    if (has_issue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->issue());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HardwareIssue::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HardwareIssue* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HardwareIssue*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HardwareIssue::MergeFrom(const HardwareIssue& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_issue()) {
      set_issue(from.issue());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HardwareIssue::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HardwareIssue::CopyFrom(const HardwareIssue& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HardwareIssue::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void HardwareIssue::Swap(HardwareIssue* other) {
  if (other != this) {
    std::swap(issue_, other->issue_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HardwareIssue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HardwareIssue_descriptor_;
  metadata.reflection = HardwareIssue_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Alarm_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Alarm_Type_descriptor_;
}
bool Alarm_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Alarm_Type Alarm::DISAPPEARED_OBJECT;
const Alarm_Type Alarm::FIXED_OBSTACLE;
const Alarm_Type Alarm::MOBILE_OBSTACLE;
const Alarm_Type Alarm::HOTPOINT;
const Alarm_Type Alarm::ROBOT_HARDWARE_ISSUE;
const Alarm_Type Alarm::ROBOT_BLOCKED;
const Alarm_Type Alarm::ROBOT_LOST;
const Alarm_Type Alarm::Type_MIN;
const Alarm_Type Alarm::Type_MAX;
const int Alarm::Type_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Alarm_Status_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Alarm_Status_descriptor_;
}
bool Alarm_Status_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Alarm_Status Alarm::ON;
const Alarm_Status Alarm::OFF;
const Alarm_Status Alarm::UPDATE;
const Alarm_Status Alarm::Status_MIN;
const Alarm_Status Alarm::Status_MAX;
const int Alarm::Status_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Alarm::kIdFieldNumber;
const int Alarm::kXFieldNumber;
const int Alarm::kYFieldNumber;
const int Alarm::kDistanceFieldNumber;
const int Alarm::kTypeFieldNumber;
const int Alarm::kStatusFieldNumber;
#endif  // !_MSC_VER

Alarm::Alarm()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.Alarm)
}

void Alarm::InitAsDefaultInstance() {
}

Alarm::Alarm(const Alarm& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.Alarm)
}

void Alarm::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  x_ = 0u;
  y_ = 0u;
  distance_ = 0u;
  type_ = 1;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Alarm::~Alarm() {
  // @@protoc_insertion_point(destructor:eos.sdk.Alarm)
  SharedDtor();
}

void Alarm::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Alarm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Alarm::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Alarm_descriptor_;
}

const Alarm& Alarm::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

Alarm* Alarm::default_instance_ = NULL;

Alarm* Alarm::New() const {
  return new Alarm;
}

void Alarm::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Alarm*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(id_, distance_);
    type_ = 1;
    status_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Alarm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.Alarm)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // required uint32 x = 2;
      case 2: {
        if (tag == 16) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // required uint32 y = 3;
      case 3: {
        if (tag == 24) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_distance;
        break;
      }

      // required uint32 distance = 4;
      case 4: {
        if (tag == 32) {
         parse_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &distance_)));
          set_has_distance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_type;
        break;
      }

      // required .eos.sdk.Alarm.Type type = 5;
      case 5: {
        if (tag == 40) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::Alarm_Type_IsValid(value)) {
            set_type(static_cast< ::eos::sdk::Alarm_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_status;
        break;
      }

      // required .eos.sdk.Alarm.Status status = 6;
      case 6: {
        if (tag == 48) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::Alarm_Status_IsValid(value)) {
            set_status(static_cast< ::eos::sdk::Alarm_Status >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.Alarm)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.Alarm)
  return false;
#undef DO_
}

void Alarm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.Alarm)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->x(), output);
  }

  // required uint32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->y(), output);
  }

  // required uint32 distance = 4;
  if (has_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->distance(), output);
  }

  // required .eos.sdk.Alarm.Type type = 5;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->type(), output);
  }

  // required .eos.sdk.Alarm.Status status = 6;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.Alarm)
}

::google::protobuf::uint8* Alarm::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.Alarm)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 x = 2;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->x(), target);
  }

  // required uint32 y = 3;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->y(), target);
  }

  // required uint32 distance = 4;
  if (has_distance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->distance(), target);
  }

  // required .eos.sdk.Alarm.Type type = 5;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->type(), target);
  }

  // required .eos.sdk.Alarm.Status status = 6;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.Alarm)
  return target;
}

int Alarm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->x());
    }

    // required uint32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->y());
    }

    // required uint32 distance = 4;
    if (has_distance()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->distance());
    }

    // required .eos.sdk.Alarm.Type type = 5;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required .eos.sdk.Alarm.Status status = 6;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Alarm::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Alarm* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Alarm*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Alarm::MergeFrom(const Alarm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_distance()) {
      set_distance(from.distance());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Alarm::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Alarm::CopyFrom(const Alarm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Alarm::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void Alarm::Swap(Alarm* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(distance_, other->distance_);
    std::swap(type_, other->type_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Alarm::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Alarm_descriptor_;
  metadata.reflection = Alarm_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AlarmUpdate::kIdFieldNumber;
const int AlarmUpdate::kXFieldNumber;
const int AlarmUpdate::kYFieldNumber;
const int AlarmUpdate::kDistanceFieldNumber;
#endif  // !_MSC_VER

AlarmUpdate::AlarmUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.AlarmUpdate)
}

void AlarmUpdate::InitAsDefaultInstance() {
}

AlarmUpdate::AlarmUpdate(const AlarmUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.AlarmUpdate)
}

void AlarmUpdate::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  x_ = 0u;
  y_ = 0u;
  distance_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AlarmUpdate::~AlarmUpdate() {
  // @@protoc_insertion_point(destructor:eos.sdk.AlarmUpdate)
  SharedDtor();
}

void AlarmUpdate::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AlarmUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AlarmUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AlarmUpdate_descriptor_;
}

const AlarmUpdate& AlarmUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

AlarmUpdate* AlarmUpdate::default_instance_ = NULL;

AlarmUpdate* AlarmUpdate::New() const {
  return new AlarmUpdate;
}

void AlarmUpdate::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<AlarmUpdate*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, distance_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AlarmUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.AlarmUpdate)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // required uint32 x = 2;
      case 2: {
        if (tag == 16) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // required uint32 y = 3;
      case 3: {
        if (tag == 24) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_distance;
        break;
      }

      // required uint32 distance = 4;
      case 4: {
        if (tag == 32) {
         parse_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &distance_)));
          set_has_distance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.AlarmUpdate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.AlarmUpdate)
  return false;
#undef DO_
}

void AlarmUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.AlarmUpdate)
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // required uint32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->x(), output);
  }

  // required uint32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->y(), output);
  }

  // required uint32 distance = 4;
  if (has_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->distance(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.AlarmUpdate)
}

::google::protobuf::uint8* AlarmUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.AlarmUpdate)
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // required uint32 x = 2;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->x(), target);
  }

  // required uint32 y = 3;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->y(), target);
  }

  // required uint32 distance = 4;
  if (has_distance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->distance(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.AlarmUpdate)
  return target;
}

int AlarmUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // required uint32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->x());
    }

    // required uint32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->y());
    }

    // required uint32 distance = 4;
    if (has_distance()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->distance());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AlarmUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AlarmUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AlarmUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AlarmUpdate::MergeFrom(const AlarmUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_distance()) {
      set_distance(from.distance());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AlarmUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AlarmUpdate::CopyFrom(const AlarmUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AlarmUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void AlarmUpdate::Swap(AlarmUpdate* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(distance_, other->distance_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AlarmUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AlarmUpdate_descriptor_;
  metadata.reflection = AlarmUpdate_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* BatteryState_State_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BatteryState_State_descriptor_;
}
bool BatteryState_State_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const BatteryState_State BatteryState::CHARGING;
const BatteryState_State BatteryState::DISCHARGING;
const BatteryState_State BatteryState::State_MIN;
const BatteryState_State BatteryState::State_MAX;
const int BatteryState::State_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int BatteryState::kStateFieldNumber;
const int BatteryState::kLevelFieldNumber;
const int BatteryState::kTensionFieldNumber;
#endif  // !_MSC_VER

BatteryState::BatteryState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.BatteryState)
}

void BatteryState::InitAsDefaultInstance() {
}

BatteryState::BatteryState(const BatteryState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.BatteryState)
}

void BatteryState::SharedCtor() {
  _cached_size_ = 0;
  state_ = 1;
  level_ = 0;
  tension_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BatteryState::~BatteryState() {
  // @@protoc_insertion_point(destructor:eos.sdk.BatteryState)
  SharedDtor();
}

void BatteryState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BatteryState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BatteryState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BatteryState_descriptor_;
}

const BatteryState& BatteryState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

BatteryState* BatteryState::default_instance_ = NULL;

BatteryState* BatteryState::New() const {
  return new BatteryState;
}

void BatteryState::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<BatteryState*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(level_, tension_);
    state_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BatteryState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.BatteryState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .eos.sdk.BatteryState.State state = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::BatteryState_State_IsValid(value)) {
            set_state(static_cast< ::eos::sdk::BatteryState_State >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_level;
        break;
      }

      // required float level = 2;
      case 2: {
        if (tag == 21) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_tension;
        break;
      }

      // required float tension = 3;
      case 3: {
        if (tag == 29) {
         parse_tension:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &tension_)));
          set_has_tension();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.BatteryState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.BatteryState)
  return false;
#undef DO_
}

void BatteryState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.BatteryState)
  // required .eos.sdk.BatteryState.State state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  // required float level = 2;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->level(), output);
  }

  // required float tension = 3;
  if (has_tension()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->tension(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.BatteryState)
}

::google::protobuf::uint8* BatteryState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.BatteryState)
  // required .eos.sdk.BatteryState.State state = 1;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  // required float level = 2;
  if (has_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->level(), target);
  }

  // required float tension = 3;
  if (has_tension()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->tension(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.BatteryState)
  return target;
}

int BatteryState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .eos.sdk.BatteryState.State state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // required float level = 2;
    if (has_level()) {
      total_size += 1 + 4;
    }

    // required float tension = 3;
    if (has_tension()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BatteryState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BatteryState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BatteryState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BatteryState::MergeFrom(const BatteryState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_tension()) {
      set_tension(from.tension());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BatteryState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BatteryState::CopyFrom(const BatteryState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatteryState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void BatteryState::Swap(BatteryState* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(level_, other->level_);
    std::swap(tension_, other->tension_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BatteryState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BatteryState_descriptor_;
  metadata.reflection = BatteryState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LaserShot::kXArrayFieldNumber;
const int LaserShot::kYArrayFieldNumber;
#endif  // !_MSC_VER

LaserShot::LaserShot()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.LaserShot)
}

void LaserShot::InitAsDefaultInstance() {
}

LaserShot::LaserShot(const LaserShot& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.LaserShot)
}

void LaserShot::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaserShot::~LaserShot() {
  // @@protoc_insertion_point(destructor:eos.sdk.LaserShot)
  SharedDtor();
}

void LaserShot::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LaserShot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaserShot::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaserShot_descriptor_;
}

const LaserShot& LaserShot::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

LaserShot* LaserShot::default_instance_ = NULL;

LaserShot* LaserShot::New() const {
  return new LaserShot;
}

void LaserShot::Clear() {
  x_array_.Clear();
  y_array_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LaserShot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.LaserShot)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float x_array = 1;
      case 1: {
        if (tag == 13) {
         parse_x_array:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13, input, this->mutable_x_array())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_x_array())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(13)) goto parse_x_array;
        if (input->ExpectTag(21)) goto parse_y_array;
        break;
      }

      // repeated float y_array = 2;
      case 2: {
        if (tag == 21) {
         parse_y_array:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_y_array())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_y_array())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y_array;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.LaserShot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.LaserShot)
  return false;
#undef DO_
}

void LaserShot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.LaserShot)
  // repeated float x_array = 1;
  for (int i = 0; i < this->x_array_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      1, this->x_array(i), output);
  }

  // repeated float y_array = 2;
  for (int i = 0; i < this->y_array_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->y_array(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.LaserShot)
}

::google::protobuf::uint8* LaserShot::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.LaserShot)
  // repeated float x_array = 1;
  for (int i = 0; i < this->x_array_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(1, this->x_array(i), target);
  }

  // repeated float y_array = 2;
  for (int i = 0; i < this->y_array_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(2, this->y_array(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.LaserShot)
  return target;
}

int LaserShot::ByteSize() const {
  int total_size = 0;

  // repeated float x_array = 1;
  {
    int data_size = 0;
    data_size = 4 * this->x_array_size();
    total_size += 1 * this->x_array_size() + data_size;
  }

  // repeated float y_array = 2;
  {
    int data_size = 0;
    data_size = 4 * this->y_array_size();
    total_size += 1 * this->y_array_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaserShot::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LaserShot* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LaserShot*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LaserShot::MergeFrom(const LaserShot& from) {
  GOOGLE_CHECK_NE(&from, this);
  x_array_.MergeFrom(from.x_array_);
  y_array_.MergeFrom(from.y_array_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LaserShot::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaserShot::CopyFrom(const LaserShot& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaserShot::IsInitialized() const {

  return true;
}

void LaserShot::Swap(LaserShot* other) {
  if (other != this) {
    x_array_.Swap(&other->x_array_);
    y_array_.Swap(&other->y_array_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LaserShot::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LaserShot_descriptor_;
  metadata.reflection = LaserShot_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RobotMonitoring::kCurrentScoreFieldNumber;
const int RobotMonitoring::kMinScoreFieldNumber;
const int RobotMonitoring::kMaxScoreFieldNumber;
const int RobotMonitoring::kAvgScoreFieldNumber;
const int RobotMonitoring::kSwitchToMappingFieldNumber;
const int RobotMonitoring::kSwitchToLocalizationFieldNumber;
const int RobotMonitoring::kSwitchToRelocalizationFieldNumber;
const int RobotMonitoring::kLaserFieldNumber;
#endif  // !_MSC_VER

RobotMonitoring::RobotMonitoring()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.RobotMonitoring)
}

void RobotMonitoring::InitAsDefaultInstance() {
  laser_ = const_cast< ::eos::sdk::LaserShot*>(&::eos::sdk::LaserShot::default_instance());
}

RobotMonitoring::RobotMonitoring(const RobotMonitoring& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.RobotMonitoring)
}

void RobotMonitoring::SharedCtor() {
  _cached_size_ = 0;
  current_score_ = GOOGLE_ULONGLONG(0);
  min_score_ = GOOGLE_ULONGLONG(0);
  max_score_ = GOOGLE_ULONGLONG(0);
  avg_score_ = GOOGLE_ULONGLONG(0);
  switch_to_mapping_ = GOOGLE_ULONGLONG(0);
  switch_to_localization_ = GOOGLE_ULONGLONG(0);
  switch_to_relocalization_ = GOOGLE_ULONGLONG(0);
  laser_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotMonitoring::~RobotMonitoring() {
  // @@protoc_insertion_point(destructor:eos.sdk.RobotMonitoring)
  SharedDtor();
}

void RobotMonitoring::SharedDtor() {
  if (this != default_instance_) {
    delete laser_;
  }
}

void RobotMonitoring::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotMonitoring::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotMonitoring_descriptor_;
}

const RobotMonitoring& RobotMonitoring::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

RobotMonitoring* RobotMonitoring::default_instance_ = NULL;

RobotMonitoring* RobotMonitoring::New() const {
  return new RobotMonitoring;
}

void RobotMonitoring::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RobotMonitoring*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(current_score_, switch_to_relocalization_);
    if (has_laser()) {
      if (laser_ != NULL) laser_->::eos::sdk::LaserShot::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobotMonitoring::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.RobotMonitoring)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 current_score = 3;
      case 3: {
        if (tag == 24) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &current_score_)));
          set_has_current_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_min_score;
        break;
      }

      // optional uint64 min_score = 4;
      case 4: {
        if (tag == 32) {
         parse_min_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &min_score_)));
          set_has_min_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_max_score;
        break;
      }

      // optional uint64 max_score = 5;
      case 5: {
        if (tag == 40) {
         parse_max_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_score_)));
          set_has_max_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_avg_score;
        break;
      }

      // optional uint64 avg_score = 6;
      case 6: {
        if (tag == 48) {
         parse_avg_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &avg_score_)));
          set_has_avg_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_switch_to_mapping;
        break;
      }

      // optional uint64 switch_to_mapping = 7;
      case 7: {
        if (tag == 56) {
         parse_switch_to_mapping:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &switch_to_mapping_)));
          set_has_switch_to_mapping();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_switch_to_localization;
        break;
      }

      // optional uint64 switch_to_localization = 8;
      case 8: {
        if (tag == 64) {
         parse_switch_to_localization:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &switch_to_localization_)));
          set_has_switch_to_localization();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_switch_to_relocalization;
        break;
      }

      // optional uint64 switch_to_relocalization = 9;
      case 9: {
        if (tag == 72) {
         parse_switch_to_relocalization:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &switch_to_relocalization_)));
          set_has_switch_to_relocalization();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_laser;
        break;
      }

      // optional .eos.sdk.LaserShot laser = 10;
      case 10: {
        if (tag == 82) {
         parse_laser:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_laser()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.RobotMonitoring)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.RobotMonitoring)
  return false;
#undef DO_
}

void RobotMonitoring::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.RobotMonitoring)
  // optional uint64 current_score = 3;
  if (has_current_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->current_score(), output);
  }

  // optional uint64 min_score = 4;
  if (has_min_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->min_score(), output);
  }

  // optional uint64 max_score = 5;
  if (has_max_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->max_score(), output);
  }

  // optional uint64 avg_score = 6;
  if (has_avg_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->avg_score(), output);
  }

  // optional uint64 switch_to_mapping = 7;
  if (has_switch_to_mapping()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->switch_to_mapping(), output);
  }

  // optional uint64 switch_to_localization = 8;
  if (has_switch_to_localization()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->switch_to_localization(), output);
  }

  // optional uint64 switch_to_relocalization = 9;
  if (has_switch_to_relocalization()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->switch_to_relocalization(), output);
  }

  // optional .eos.sdk.LaserShot laser = 10;
  if (has_laser()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->laser(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.RobotMonitoring)
}

::google::protobuf::uint8* RobotMonitoring::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.RobotMonitoring)
  // optional uint64 current_score = 3;
  if (has_current_score()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->current_score(), target);
  }

  // optional uint64 min_score = 4;
  if (has_min_score()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->min_score(), target);
  }

  // optional uint64 max_score = 5;
  if (has_max_score()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->max_score(), target);
  }

  // optional uint64 avg_score = 6;
  if (has_avg_score()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->avg_score(), target);
  }

  // optional uint64 switch_to_mapping = 7;
  if (has_switch_to_mapping()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->switch_to_mapping(), target);
  }

  // optional uint64 switch_to_localization = 8;
  if (has_switch_to_localization()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->switch_to_localization(), target);
  }

  // optional uint64 switch_to_relocalization = 9;
  if (has_switch_to_relocalization()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(9, this->switch_to_relocalization(), target);
  }

  // optional .eos.sdk.LaserShot laser = 10;
  if (has_laser()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->laser(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.RobotMonitoring)
  return target;
}

int RobotMonitoring::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 current_score = 3;
    if (has_current_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->current_score());
    }

    // optional uint64 min_score = 4;
    if (has_min_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->min_score());
    }

    // optional uint64 max_score = 5;
    if (has_max_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_score());
    }

    // optional uint64 avg_score = 6;
    if (has_avg_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->avg_score());
    }

    // optional uint64 switch_to_mapping = 7;
    if (has_switch_to_mapping()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->switch_to_mapping());
    }

    // optional uint64 switch_to_localization = 8;
    if (has_switch_to_localization()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->switch_to_localization());
    }

    // optional uint64 switch_to_relocalization = 9;
    if (has_switch_to_relocalization()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->switch_to_relocalization());
    }

    // optional .eos.sdk.LaserShot laser = 10;
    if (has_laser()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->laser());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotMonitoring::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobotMonitoring* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobotMonitoring*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobotMonitoring::MergeFrom(const RobotMonitoring& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_current_score()) {
      set_current_score(from.current_score());
    }
    if (from.has_min_score()) {
      set_min_score(from.min_score());
    }
    if (from.has_max_score()) {
      set_max_score(from.max_score());
    }
    if (from.has_avg_score()) {
      set_avg_score(from.avg_score());
    }
    if (from.has_switch_to_mapping()) {
      set_switch_to_mapping(from.switch_to_mapping());
    }
    if (from.has_switch_to_localization()) {
      set_switch_to_localization(from.switch_to_localization());
    }
    if (from.has_switch_to_relocalization()) {
      set_switch_to_relocalization(from.switch_to_relocalization());
    }
    if (from.has_laser()) {
      mutable_laser()->::eos::sdk::LaserShot::MergeFrom(from.laser());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobotMonitoring::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotMonitoring::CopyFrom(const RobotMonitoring& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotMonitoring::IsInitialized() const {

  return true;
}

void RobotMonitoring::Swap(RobotMonitoring* other) {
  if (other != this) {
    std::swap(current_score_, other->current_score_);
    std::swap(min_score_, other->min_score_);
    std::swap(max_score_, other->max_score_);
    std::swap(avg_score_, other->avg_score_);
    std::swap(switch_to_mapping_, other->switch_to_mapping_);
    std::swap(switch_to_localization_, other->switch_to_localization_);
    std::swap(switch_to_relocalization_, other->switch_to_relocalization_);
    std::swap(laser_, other->laser_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobotMonitoring::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotMonitoring_descriptor_;
  metadata.reflection = RobotMonitoring_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ScoresThreshold::kSwitchToMappingFieldNumber;
const int ScoresThreshold::kSwitchToLocalizationFieldNumber;
const int ScoresThreshold::kSwitchToRelocalizationFieldNumber;
#endif  // !_MSC_VER

ScoresThreshold::ScoresThreshold()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.ScoresThreshold)
}

void ScoresThreshold::InitAsDefaultInstance() {
}

ScoresThreshold::ScoresThreshold(const ScoresThreshold& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.ScoresThreshold)
}

void ScoresThreshold::SharedCtor() {
  _cached_size_ = 0;
  switch_to_mapping_ = GOOGLE_ULONGLONG(0);
  switch_to_localization_ = GOOGLE_ULONGLONG(0);
  switch_to_relocalization_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScoresThreshold::~ScoresThreshold() {
  // @@protoc_insertion_point(destructor:eos.sdk.ScoresThreshold)
  SharedDtor();
}

void ScoresThreshold::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ScoresThreshold::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScoresThreshold::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScoresThreshold_descriptor_;
}

const ScoresThreshold& ScoresThreshold::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

ScoresThreshold* ScoresThreshold::default_instance_ = NULL;

ScoresThreshold* ScoresThreshold::New() const {
  return new ScoresThreshold;
}

void ScoresThreshold::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ScoresThreshold*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(switch_to_mapping_, switch_to_relocalization_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ScoresThreshold::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.ScoresThreshold)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 switch_to_mapping = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &switch_to_mapping_)));
          set_has_switch_to_mapping();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_switch_to_localization;
        break;
      }

      // required uint64 switch_to_localization = 2;
      case 2: {
        if (tag == 16) {
         parse_switch_to_localization:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &switch_to_localization_)));
          set_has_switch_to_localization();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_switch_to_relocalization;
        break;
      }

      // required uint64 switch_to_relocalization = 3;
      case 3: {
        if (tag == 24) {
         parse_switch_to_relocalization:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &switch_to_relocalization_)));
          set_has_switch_to_relocalization();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.ScoresThreshold)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.ScoresThreshold)
  return false;
#undef DO_
}

void ScoresThreshold::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.ScoresThreshold)
  // required uint64 switch_to_mapping = 1;
  if (has_switch_to_mapping()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->switch_to_mapping(), output);
  }

  // required uint64 switch_to_localization = 2;
  if (has_switch_to_localization()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->switch_to_localization(), output);
  }

  // required uint64 switch_to_relocalization = 3;
  if (has_switch_to_relocalization()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->switch_to_relocalization(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.ScoresThreshold)
}

::google::protobuf::uint8* ScoresThreshold::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.ScoresThreshold)
  // required uint64 switch_to_mapping = 1;
  if (has_switch_to_mapping()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->switch_to_mapping(), target);
  }

  // required uint64 switch_to_localization = 2;
  if (has_switch_to_localization()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->switch_to_localization(), target);
  }

  // required uint64 switch_to_relocalization = 3;
  if (has_switch_to_relocalization()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->switch_to_relocalization(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.ScoresThreshold)
  return target;
}

int ScoresThreshold::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 switch_to_mapping = 1;
    if (has_switch_to_mapping()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->switch_to_mapping());
    }

    // required uint64 switch_to_localization = 2;
    if (has_switch_to_localization()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->switch_to_localization());
    }

    // required uint64 switch_to_relocalization = 3;
    if (has_switch_to_relocalization()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->switch_to_relocalization());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScoresThreshold::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ScoresThreshold* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ScoresThreshold*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ScoresThreshold::MergeFrom(const ScoresThreshold& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_switch_to_mapping()) {
      set_switch_to_mapping(from.switch_to_mapping());
    }
    if (from.has_switch_to_localization()) {
      set_switch_to_localization(from.switch_to_localization());
    }
    if (from.has_switch_to_relocalization()) {
      set_switch_to_relocalization(from.switch_to_relocalization());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ScoresThreshold::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScoresThreshold::CopyFrom(const ScoresThreshold& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScoresThreshold::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ScoresThreshold::Swap(ScoresThreshold* other) {
  if (other != this) {
    std::swap(switch_to_mapping_, other->switch_to_mapping_);
    std::swap(switch_to_localization_, other->switch_to_localization_);
    std::swap(switch_to_relocalization_, other->switch_to_relocalization_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ScoresThreshold::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ScoresThreshold_descriptor_;
  metadata.reflection = ScoresThreshold_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ControlPatrolling_ACTION_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ControlPatrolling_ACTION_descriptor_;
}
bool ControlPatrolling_ACTION_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ControlPatrolling_ACTION ControlPatrolling::START;
const ControlPatrolling_ACTION ControlPatrolling::STOP;
const ControlPatrolling_ACTION ControlPatrolling::ACTION_MIN;
const ControlPatrolling_ACTION ControlPatrolling::ACTION_MAX;
const int ControlPatrolling::ACTION_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ControlPatrolling::kActionFieldNumber;
const int ControlPatrolling::kPatrolNameFieldNumber;
const int ControlPatrolling::kDurationFieldNumber;
#endif  // !_MSC_VER

ControlPatrolling::ControlPatrolling()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.ControlPatrolling)
}

void ControlPatrolling::InitAsDefaultInstance() {
}

ControlPatrolling::ControlPatrolling(const ControlPatrolling& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.ControlPatrolling)
}

void ControlPatrolling::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  action_ = 1;
  patrol_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  duration_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ControlPatrolling::~ControlPatrolling() {
  // @@protoc_insertion_point(destructor:eos.sdk.ControlPatrolling)
  SharedDtor();
}

void ControlPatrolling::SharedDtor() {
  if (patrol_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete patrol_name_;
  }
  if (this != default_instance_) {
  }
}

void ControlPatrolling::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ControlPatrolling::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ControlPatrolling_descriptor_;
}

const ControlPatrolling& ControlPatrolling::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

ControlPatrolling* ControlPatrolling::default_instance_ = NULL;

ControlPatrolling* ControlPatrolling::New() const {
  return new ControlPatrolling;
}

void ControlPatrolling::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    action_ = 1;
    if (has_patrol_name()) {
      if (patrol_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        patrol_name_->clear();
      }
    }
    duration_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ControlPatrolling::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.ControlPatrolling)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .eos.sdk.ControlPatrolling.ACTION action = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::ControlPatrolling_ACTION_IsValid(value)) {
            set_action(static_cast< ::eos::sdk::ControlPatrolling_ACTION >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_patrol_name;
        break;
      }

      // required string patrol_name = 2;
      case 2: {
        if (tag == 18) {
         parse_patrol_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_patrol_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->patrol_name().data(), this->patrol_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "patrol_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_duration;
        break;
      }

      // required uint32 duration = 3;
      case 3: {
        if (tag == 24) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.ControlPatrolling)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.ControlPatrolling)
  return false;
#undef DO_
}

void ControlPatrolling::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.ControlPatrolling)
  // required .eos.sdk.ControlPatrolling.ACTION action = 1;
  if (has_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->action(), output);
  }

  // required string patrol_name = 2;
  if (has_patrol_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->patrol_name().data(), this->patrol_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "patrol_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->patrol_name(), output);
  }

  // required uint32 duration = 3;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->duration(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.ControlPatrolling)
}

::google::protobuf::uint8* ControlPatrolling::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.ControlPatrolling)
  // required .eos.sdk.ControlPatrolling.ACTION action = 1;
  if (has_action()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->action(), target);
  }

  // required string patrol_name = 2;
  if (has_patrol_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->patrol_name().data(), this->patrol_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "patrol_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->patrol_name(), target);
  }

  // required uint32 duration = 3;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->duration(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.ControlPatrolling)
  return target;
}

int ControlPatrolling::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .eos.sdk.ControlPatrolling.ACTION action = 1;
    if (has_action()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->action());
    }

    // required string patrol_name = 2;
    if (has_patrol_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->patrol_name());
    }

    // required uint32 duration = 3;
    if (has_duration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->duration());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ControlPatrolling::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ControlPatrolling* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ControlPatrolling*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ControlPatrolling::MergeFrom(const ControlPatrolling& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_action()) {
      set_action(from.action());
    }
    if (from.has_patrol_name()) {
      set_patrol_name(from.patrol_name());
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ControlPatrolling::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ControlPatrolling::CopyFrom(const ControlPatrolling& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControlPatrolling::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ControlPatrolling::Swap(ControlPatrolling* other) {
  if (other != this) {
    std::swap(action_, other->action_);
    std::swap(patrol_name_, other->patrol_name_);
    std::swap(duration_, other->duration_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ControlPatrolling::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ControlPatrolling_descriptor_;
  metadata.reflection = ControlPatrolling_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EmergencyStop::kActiveFieldNumber;
#endif  // !_MSC_VER

EmergencyStop::EmergencyStop()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.EmergencyStop)
}

void EmergencyStop::InitAsDefaultInstance() {
}

EmergencyStop::EmergencyStop(const EmergencyStop& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.EmergencyStop)
}

void EmergencyStop::SharedCtor() {
  _cached_size_ = 0;
  active_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmergencyStop::~EmergencyStop() {
  // @@protoc_insertion_point(destructor:eos.sdk.EmergencyStop)
  SharedDtor();
}

void EmergencyStop::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EmergencyStop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmergencyStop::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmergencyStop_descriptor_;
}

const EmergencyStop& EmergencyStop::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

EmergencyStop* EmergencyStop::default_instance_ = NULL;

EmergencyStop* EmergencyStop::New() const {
  return new EmergencyStop;
}

void EmergencyStop::Clear() {
  active_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmergencyStop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.EmergencyStop)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool active = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &active_)));
          set_has_active();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.EmergencyStop)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.EmergencyStop)
  return false;
#undef DO_
}

void EmergencyStop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.EmergencyStop)
  // required bool active = 1;
  if (has_active()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->active(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.EmergencyStop)
}

::google::protobuf::uint8* EmergencyStop::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.EmergencyStop)
  // required bool active = 1;
  if (has_active()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->active(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.EmergencyStop)
  return target;
}

int EmergencyStop::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool active = 1;
    if (has_active()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmergencyStop::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmergencyStop* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmergencyStop*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmergencyStop::MergeFrom(const EmergencyStop& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_active()) {
      set_active(from.active());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmergencyStop::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmergencyStop::CopyFrom(const EmergencyStop& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmergencyStop::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void EmergencyStop::Swap(EmergencyStop* other) {
  if (other != this) {
    std::swap(active_, other->active_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmergencyStop::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmergencyStop_descriptor_;
  metadata.reflection = EmergencyStop_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DynamicObstacle::kActiveFieldNumber;
const int DynamicObstacle::kXFieldNumber;
const int DynamicObstacle::kYFieldNumber;
const int DynamicObstacle::kRadiusFieldNumber;
#endif  // !_MSC_VER

DynamicObstacle::DynamicObstacle()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.DynamicObstacle)
}

void DynamicObstacle::InitAsDefaultInstance() {
}

DynamicObstacle::DynamicObstacle(const DynamicObstacle& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.DynamicObstacle)
}

void DynamicObstacle::SharedCtor() {
  _cached_size_ = 0;
  active_ = false;
  x_ = 0u;
  y_ = 0u;
  radius_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DynamicObstacle::~DynamicObstacle() {
  // @@protoc_insertion_point(destructor:eos.sdk.DynamicObstacle)
  SharedDtor();
}

void DynamicObstacle::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DynamicObstacle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DynamicObstacle::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DynamicObstacle_descriptor_;
}

const DynamicObstacle& DynamicObstacle::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

DynamicObstacle* DynamicObstacle::default_instance_ = NULL;

DynamicObstacle* DynamicObstacle::New() const {
  return new DynamicObstacle;
}

void DynamicObstacle::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DynamicObstacle*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(active_, radius_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DynamicObstacle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.DynamicObstacle)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool active = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &active_)));
          set_has_active();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // required uint32 x = 2;
      case 2: {
        if (tag == 16) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // required uint32 y = 3;
      case 3: {
        if (tag == 24) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_radius;
        break;
      }

      // required uint32 radius = 4;
      case 4: {
        if (tag == 32) {
         parse_radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.DynamicObstacle)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.DynamicObstacle)
  return false;
#undef DO_
}

void DynamicObstacle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.DynamicObstacle)
  // required bool active = 1;
  if (has_active()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->active(), output);
  }

  // required uint32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->x(), output);
  }

  // required uint32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->y(), output);
  }

  // required uint32 radius = 4;
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->radius(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.DynamicObstacle)
}

::google::protobuf::uint8* DynamicObstacle::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.DynamicObstacle)
  // required bool active = 1;
  if (has_active()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->active(), target);
  }

  // required uint32 x = 2;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->x(), target);
  }

  // required uint32 y = 3;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->y(), target);
  }

  // required uint32 radius = 4;
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->radius(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.DynamicObstacle)
  return target;
}

int DynamicObstacle::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool active = 1;
    if (has_active()) {
      total_size += 1 + 1;
    }

    // required uint32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->x());
    }

    // required uint32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->y());
    }

    // required uint32 radius = 4;
    if (has_radius()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->radius());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DynamicObstacle::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DynamicObstacle* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DynamicObstacle*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DynamicObstacle::MergeFrom(const DynamicObstacle& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_active()) {
      set_active(from.active());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DynamicObstacle::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DynamicObstacle::CopyFrom(const DynamicObstacle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DynamicObstacle::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void DynamicObstacle::Swap(DynamicObstacle* other) {
  if (other != this) {
    std::swap(active_, other->active_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(radius_, other->radius_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DynamicObstacle::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DynamicObstacle_descriptor_;
  metadata.reflection = DynamicObstacle_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ClearDynamicObstacles::ClearDynamicObstacles()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.ClearDynamicObstacles)
}

void ClearDynamicObstacles::InitAsDefaultInstance() {
}

ClearDynamicObstacles::ClearDynamicObstacles(const ClearDynamicObstacles& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.ClearDynamicObstacles)
}

void ClearDynamicObstacles::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClearDynamicObstacles::~ClearDynamicObstacles() {
  // @@protoc_insertion_point(destructor:eos.sdk.ClearDynamicObstacles)
  SharedDtor();
}

void ClearDynamicObstacles::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClearDynamicObstacles::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClearDynamicObstacles::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClearDynamicObstacles_descriptor_;
}

const ClearDynamicObstacles& ClearDynamicObstacles::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

ClearDynamicObstacles* ClearDynamicObstacles::default_instance_ = NULL;

ClearDynamicObstacles* ClearDynamicObstacles::New() const {
  return new ClearDynamicObstacles;
}

void ClearDynamicObstacles::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClearDynamicObstacles::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.ClearDynamicObstacles)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.ClearDynamicObstacles)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.ClearDynamicObstacles)
  return false;
#undef DO_
}

void ClearDynamicObstacles::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.ClearDynamicObstacles)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.ClearDynamicObstacles)
}

::google::protobuf::uint8* ClearDynamicObstacles::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.ClearDynamicObstacles)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.ClearDynamicObstacles)
  return target;
}

int ClearDynamicObstacles::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClearDynamicObstacles::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClearDynamicObstacles* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClearDynamicObstacles*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClearDynamicObstacles::MergeFrom(const ClearDynamicObstacles& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClearDynamicObstacles::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClearDynamicObstacles::CopyFrom(const ClearDynamicObstacles& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClearDynamicObstacles::IsInitialized() const {

  return true;
}

void ClearDynamicObstacles::Swap(ClearDynamicObstacles* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClearDynamicObstacles::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClearDynamicObstacles_descriptor_;
  metadata.reflection = ClearDynamicObstacles_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* RobotSensor_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotSensor_Type_descriptor_;
}
bool RobotSensor_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const RobotSensor_Type RobotSensor::DISTANCE;
const RobotSensor_Type RobotSensor::ON_OFF;
const RobotSensor_Type RobotSensor::TEMPERATURE;
const RobotSensor_Type RobotSensor::HYDROMETRY;
const RobotSensor_Type RobotSensor::Type_MIN;
const RobotSensor_Type RobotSensor::Type_MAX;
const int RobotSensor::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int RobotSensor::kPathFieldNumber;
const int RobotSensor::kTypeFieldNumber;
const int RobotSensor::kUnitFieldNumber;
const int RobotSensor::kValueFieldNumber;
#endif  // !_MSC_VER

RobotSensor::RobotSensor()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.RobotSensor)
}

void RobotSensor::InitAsDefaultInstance() {
}

RobotSensor::RobotSensor(const RobotSensor& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.RobotSensor)
}

void RobotSensor::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotSensor::~RobotSensor() {
  // @@protoc_insertion_point(destructor:eos.sdk.RobotSensor)
  SharedDtor();
}

void RobotSensor::SharedDtor() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (unit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unit_;
  }
  if (this != default_instance_) {
  }
}

void RobotSensor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotSensor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotSensor_descriptor_;
}

const RobotSensor& RobotSensor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

RobotSensor* RobotSensor::default_instance_ = NULL;

RobotSensor* RobotSensor::New() const {
  return new RobotSensor;
}

void RobotSensor::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RobotSensor*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(type_, value_);
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        path_->clear();
      }
    }
    if (has_unit()) {
      if (unit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        unit_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobotSensor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.RobotSensor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string path = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .eos.sdk.RobotSensor.Type type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::RobotSensor_Type_IsValid(value)) {
            set_type(static_cast< ::eos::sdk::RobotSensor_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_unit;
        break;
      }

      // required string unit = 3;
      case 3: {
        if (tag == 26) {
         parse_unit:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_unit()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->unit().data(), this->unit().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "unit");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_value;
        break;
      }

      // required float value = 4;
      case 4: {
        if (tag == 37) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.RobotSensor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.RobotSensor)
  return false;
#undef DO_
}

void RobotSensor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.RobotSensor)
  // required string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->path(), output);
  }

  // required .eos.sdk.RobotSensor.Type type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // required string unit = 3;
  if (has_unit()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->unit().data(), this->unit().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "unit");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->unit(), output);
  }

  // required float value = 4;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.RobotSensor)
}

::google::protobuf::uint8* RobotSensor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.RobotSensor)
  // required string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->path(), target);
  }

  // required .eos.sdk.RobotSensor.Type type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // required string unit = 3;
  if (has_unit()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->unit().data(), this->unit().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "unit");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->unit(), target);
  }

  // required float value = 4;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.RobotSensor)
  return target;
}

int RobotSensor::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string path = 1;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }

    // required .eos.sdk.RobotSensor.Type type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required string unit = 3;
    if (has_unit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->unit());
    }

    // required float value = 4;
    if (has_value()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotSensor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobotSensor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobotSensor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobotSensor::MergeFrom(const RobotSensor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_unit()) {
      set_unit(from.unit());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobotSensor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotSensor::CopyFrom(const RobotSensor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotSensor::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void RobotSensor::Swap(RobotSensor* other) {
  if (other != this) {
    std::swap(path_, other->path_);
    std::swap(type_, other->type_);
    std::swap(unit_, other->unit_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobotSensor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotSensor_descriptor_;
  metadata.reflection = RobotSensor_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RobotSensors::kSensorsFieldNumber;
#endif  // !_MSC_VER

RobotSensors::RobotSensors()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.RobotSensors)
}

void RobotSensors::InitAsDefaultInstance() {
}

RobotSensors::RobotSensors(const RobotSensors& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.RobotSensors)
}

void RobotSensors::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotSensors::~RobotSensors() {
  // @@protoc_insertion_point(destructor:eos.sdk.RobotSensors)
  SharedDtor();
}

void RobotSensors::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RobotSensors::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotSensors::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotSensors_descriptor_;
}

const RobotSensors& RobotSensors::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

RobotSensors* RobotSensors::default_instance_ = NULL;

RobotSensors* RobotSensors::New() const {
  return new RobotSensors;
}

void RobotSensors::Clear() {
  sensors_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobotSensors::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.RobotSensors)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .eos.sdk.RobotSensor sensors = 1;
      case 1: {
        if (tag == 10) {
         parse_sensors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sensors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_sensors;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.RobotSensors)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.RobotSensors)
  return false;
#undef DO_
}

void RobotSensors::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.RobotSensors)
  // repeated .eos.sdk.RobotSensor sensors = 1;
  for (int i = 0; i < this->sensors_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sensors(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.RobotSensors)
}

::google::protobuf::uint8* RobotSensors::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.RobotSensors)
  // repeated .eos.sdk.RobotSensor sensors = 1;
  for (int i = 0; i < this->sensors_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->sensors(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.RobotSensors)
  return target;
}

int RobotSensors::ByteSize() const {
  int total_size = 0;

  // repeated .eos.sdk.RobotSensor sensors = 1;
  total_size += 1 * this->sensors_size();
  for (int i = 0; i < this->sensors_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sensors(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotSensors::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobotSensors* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobotSensors*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobotSensors::MergeFrom(const RobotSensors& from) {
  GOOGLE_CHECK_NE(&from, this);
  sensors_.MergeFrom(from.sensors_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobotSensors::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotSensors::CopyFrom(const RobotSensors& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotSensors::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->sensors())) return false;
  return true;
}

void RobotSensors::Swap(RobotSensors* other) {
  if (other != this) {
    sensors_.Swap(&other->sensors_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobotSensors::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotSensors_descriptor_;
  metadata.reflection = RobotSensors_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NewMapAvailable::NewMapAvailable()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.NewMapAvailable)
}

void NewMapAvailable::InitAsDefaultInstance() {
}

NewMapAvailable::NewMapAvailable(const NewMapAvailable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.NewMapAvailable)
}

void NewMapAvailable::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewMapAvailable::~NewMapAvailable() {
  // @@protoc_insertion_point(destructor:eos.sdk.NewMapAvailable)
  SharedDtor();
}

void NewMapAvailable::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NewMapAvailable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NewMapAvailable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NewMapAvailable_descriptor_;
}

const NewMapAvailable& NewMapAvailable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

NewMapAvailable* NewMapAvailable::default_instance_ = NULL;

NewMapAvailable* NewMapAvailable::New() const {
  return new NewMapAvailable;
}

void NewMapAvailable::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NewMapAvailable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.NewMapAvailable)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.NewMapAvailable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.NewMapAvailable)
  return false;
#undef DO_
}

void NewMapAvailable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.NewMapAvailable)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.NewMapAvailable)
}

::google::protobuf::uint8* NewMapAvailable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.NewMapAvailable)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.NewMapAvailable)
  return target;
}

int NewMapAvailable::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewMapAvailable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NewMapAvailable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NewMapAvailable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NewMapAvailable::MergeFrom(const NewMapAvailable& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NewMapAvailable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NewMapAvailable::CopyFrom(const NewMapAvailable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewMapAvailable::IsInitialized() const {

  return true;
}

void NewMapAvailable::Swap(NewMapAvailable* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NewMapAvailable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NewMapAvailable_descriptor_;
  metadata.reflection = NewMapAvailable_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* CartoOrder_Action_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CartoOrder_Action_descriptor_;
}
bool CartoOrder_Action_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const CartoOrder_Action CartoOrder::START;
const CartoOrder_Action CartoOrder::PAUSE;
const CartoOrder_Action CartoOrder::STOP;
const CartoOrder_Action CartoOrder::ABORT;
const CartoOrder_Action CartoOrder::Action_MIN;
const CartoOrder_Action CartoOrder::Action_MAX;
const int CartoOrder::Action_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int CartoOrder::kActionFieldNumber;
const int CartoOrder::kResolutionFieldNumber;
const int CartoOrder::kSizeFieldNumber;
#endif  // !_MSC_VER

CartoOrder::CartoOrder()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.CartoOrder)
}

void CartoOrder::InitAsDefaultInstance() {
}

CartoOrder::CartoOrder(const CartoOrder& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.CartoOrder)
}

void CartoOrder::SharedCtor() {
  _cached_size_ = 0;
  action_ = 1;
  resolution_ = 0;
  size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CartoOrder::~CartoOrder() {
  // @@protoc_insertion_point(destructor:eos.sdk.CartoOrder)
  SharedDtor();
}

void CartoOrder::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CartoOrder::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CartoOrder::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CartoOrder_descriptor_;
}

const CartoOrder& CartoOrder::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

CartoOrder* CartoOrder::default_instance_ = NULL;

CartoOrder* CartoOrder::New() const {
  return new CartoOrder;
}

void CartoOrder::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CartoOrder*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(resolution_, size_);
    action_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CartoOrder::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.CartoOrder)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .eos.sdk.CartoOrder.Action action = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::CartoOrder_Action_IsValid(value)) {
            set_action(static_cast< ::eos::sdk::CartoOrder_Action >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_resolution;
        break;
      }

      // optional float resolution = 2;
      case 2: {
        if (tag == 21) {
         parse_resolution:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &resolution_)));
          set_has_resolution();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_size;
        break;
      }

      // optional uint32 size = 3;
      case 3: {
        if (tag == 24) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.CartoOrder)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.CartoOrder)
  return false;
#undef DO_
}

void CartoOrder::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.CartoOrder)
  // required .eos.sdk.CartoOrder.Action action = 1;
  if (has_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->action(), output);
  }

  // optional float resolution = 2;
  if (has_resolution()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->resolution(), output);
  }

  // optional uint32 size = 3;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.CartoOrder)
}

::google::protobuf::uint8* CartoOrder::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.CartoOrder)
  // required .eos.sdk.CartoOrder.Action action = 1;
  if (has_action()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->action(), target);
  }

  // optional float resolution = 2;
  if (has_resolution()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->resolution(), target);
  }

  // optional uint32 size = 3;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.CartoOrder)
  return target;
}

int CartoOrder::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .eos.sdk.CartoOrder.Action action = 1;
    if (has_action()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->action());
    }

    // optional float resolution = 2;
    if (has_resolution()) {
      total_size += 1 + 4;
    }

    // optional uint32 size = 3;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CartoOrder::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CartoOrder* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CartoOrder*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CartoOrder::MergeFrom(const CartoOrder& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_action()) {
      set_action(from.action());
    }
    if (from.has_resolution()) {
      set_resolution(from.resolution());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CartoOrder::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartoOrder::CopyFrom(const CartoOrder& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartoOrder::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CartoOrder::Swap(CartoOrder* other) {
  if (other != this) {
    std::swap(action_, other->action_);
    std::swap(resolution_, other->resolution_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CartoOrder::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CartoOrder_descriptor_;
  metadata.reflection = CartoOrder_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* CartoState_State_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CartoState_State_descriptor_;
}
bool CartoState_State_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const CartoState_State CartoState::STATE_STARTED;
const CartoState_State CartoState::STATE_PAUSED;
const CartoState_State CartoState::STATE_STOPPED;
const CartoState_State CartoState::State_MIN;
const CartoState_State CartoState::State_MAX;
const int CartoState::State_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* CartoState_Result_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CartoState_Result_descriptor_;
}
bool CartoState_Result_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const CartoState_Result CartoState::RESULT_OK;
const CartoState_Result CartoState::RESULT_ERROR;
const CartoState_Result CartoState::Result_MIN;
const CartoState_Result CartoState::Result_MAX;
const int CartoState::Result_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int CartoState::kStateFieldNumber;
const int CartoState::kResultFieldNumber;
const int CartoState::kDescriptionFieldNumber;
#endif  // !_MSC_VER

CartoState::CartoState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.CartoState)
}

void CartoState::InitAsDefaultInstance() {
}

CartoState::CartoState(const CartoState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.CartoState)
}

void CartoState::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  state_ = 1;
  result_ = 1;
  description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CartoState::~CartoState() {
  // @@protoc_insertion_point(destructor:eos.sdk.CartoState)
  SharedDtor();
}

void CartoState::SharedDtor() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (this != default_instance_) {
  }
}

void CartoState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CartoState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CartoState_descriptor_;
}

const CartoState& CartoState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

CartoState* CartoState::default_instance_ = NULL;

CartoState* CartoState::New() const {
  return new CartoState;
}

void CartoState::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    state_ = 1;
    result_ = 1;
    if (has_description()) {
      if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        description_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CartoState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.CartoState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .eos.sdk.CartoState.State state = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::CartoState_State_IsValid(value)) {
            set_state(static_cast< ::eos::sdk::CartoState_State >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_result;
        break;
      }

      // required .eos.sdk.CartoState.Result result = 2;
      case 2: {
        if (tag == 16) {
         parse_result:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::eos::sdk::CartoState_Result_IsValid(value)) {
            set_result(static_cast< ::eos::sdk::CartoState_Result >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_description;
        break;
      }

      // required string description = 3;
      case 3: {
        if (tag == 26) {
         parse_description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->description().data(), this->description().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "description");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.CartoState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.CartoState)
  return false;
#undef DO_
}

void CartoState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.CartoState)
  // required .eos.sdk.CartoState.State state = 1;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->state(), output);
  }

  // required .eos.sdk.CartoState.Result result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->result(), output);
  }

  // required string description = 3;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "description");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->description(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.CartoState)
}

::google::protobuf::uint8* CartoState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.CartoState)
  // required .eos.sdk.CartoState.State state = 1;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->state(), target);
  }

  // required .eos.sdk.CartoState.Result result = 2;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->result(), target);
  }

  // required string description = 3;
  if (has_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "description");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->description(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.CartoState)
  return target;
}

int CartoState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .eos.sdk.CartoState.State state = 1;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // required .eos.sdk.CartoState.Result result = 2;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // required string description = 3;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CartoState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CartoState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CartoState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CartoState::MergeFrom(const CartoState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_description()) {
      set_description(from.description());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CartoState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CartoState::CopyFrom(const CartoState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CartoState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void CartoState::Swap(CartoState* other) {
  if (other != this) {
    std::swap(state_, other->state_);
    std::swap(result_, other->result_);
    std::swap(description_, other->description_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CartoState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CartoState_descriptor_;
  metadata.reflection = CartoState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Version::kValueFieldNumber;
#endif  // !_MSC_VER

Version::Version()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.Version)
}

void Version::InitAsDefaultInstance() {
}

Version::Version(const Version& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.Version)
}

void Version::SharedCtor() {
  _cached_size_ = 0;
  value_ = GOOGLE_ULONGLONG(20161108);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Version::~Version() {
  // @@protoc_insertion_point(destructor:eos.sdk.Version)
  SharedDtor();
}

void Version::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Version::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Version::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Version_descriptor_;
}

const Version& Version::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

Version* Version::default_instance_ = NULL;

Version* Version::New() const {
  return new Version;
}

void Version::Clear() {
  value_ = GOOGLE_ULONGLONG(20161108);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Version::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.Version)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 value = 1 [default = 20161108];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.Version)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.Version)
  return false;
#undef DO_
}

void Version::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.Version)
  // required uint64 value = 1 [default = 20161108];
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.Version)
}

::google::protobuf::uint8* Version::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.Version)
  // required uint64 value = 1 [default = 20161108];
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.Version)
  return target;
}

int Version::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 value = 1 [default = 20161108];
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Version::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Version* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Version*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Version::MergeFrom(const Version& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Version::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Version::CopyFrom(const Version& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Version::Swap(Version* other) {
  if (other != this) {
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Version::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Version_descriptor_;
  metadata.reflection = Version_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

Reboot::Reboot()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:eos.sdk.Reboot)
}

void Reboot::InitAsDefaultInstance() {
}

Reboot::Reboot(const Reboot& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:eos.sdk.Reboot)
}

void Reboot::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Reboot::~Reboot() {
  // @@protoc_insertion_point(destructor:eos.sdk.Reboot)
  SharedDtor();
}

void Reboot::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Reboot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Reboot::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Reboot_descriptor_;
}

const Reboot& Reboot::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msgs_2eproto();
  return *default_instance_;
}

Reboot* Reboot::default_instance_ = NULL;

Reboot* Reboot::New() const {
  return new Reboot;
}

void Reboot::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Reboot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:eos.sdk.Reboot)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:eos.sdk.Reboot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:eos.sdk.Reboot)
  return false;
#undef DO_
}

void Reboot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:eos.sdk.Reboot)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:eos.sdk.Reboot)
}

::google::protobuf::uint8* Reboot::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:eos.sdk.Reboot)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:eos.sdk.Reboot)
  return target;
}

int Reboot::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Reboot::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Reboot* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Reboot*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Reboot::MergeFrom(const Reboot& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Reboot::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Reboot::CopyFrom(const Reboot& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reboot::IsInitialized() const {

  return true;
}

void Reboot::Swap(Reboot* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Reboot::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Reboot_descriptor_;
  metadata.reflection = Reboot_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sdk
}  // namespace eos

// @@protoc_insertion_point(global_scope)
