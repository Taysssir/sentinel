// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msgs.proto

#ifndef PROTOBUF_msgs_2eproto__INCLUDED
#define PROTOBUF_msgs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace eos {
namespace sdk {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msgs_2eproto();
void protobuf_AssignDesc_msgs_2eproto();
void protobuf_ShutdownFile_msgs_2eproto();

class RobotDataSubscription;
class Protocol;
class Camera;
class RobotInfo;
class JoystickCommand;
class Turn;
class Stop;
class SetRobotMode;
class MoveTo;
class Hooter;
class ToggleCharging;
class ToggleComponentsPowerSupply;
class RobotPosition;
class RobotVelocity;
class RobotState;
class HardwareIssue;
class Alarm;
class AlarmUpdate;
class BatteryState;
class LaserShot;
class RobotMonitoring;
class ScoresThreshold;
class ControlPatrolling;
class EmergencyStop;
class DynamicObstacle;
class ClearDynamicObstacles;
class RobotSensor;
class RobotSensors;
class NewMapAvailable;
class CartoOrder;
class CartoState;
class Version;
class Reboot;

enum Protocol_Port {
  Protocol_Port_PORT = 55499
};
bool Protocol_Port_IsValid(int value);
const Protocol_Port Protocol_Port_Port_MIN = Protocol_Port_PORT;
const Protocol_Port Protocol_Port_Port_MAX = Protocol_Port_PORT;
const int Protocol_Port_Port_ARRAYSIZE = Protocol_Port_Port_MAX + 1;

const ::google::protobuf::EnumDescriptor* Protocol_Port_descriptor();
inline const ::std::string& Protocol_Port_Name(Protocol_Port value) {
  return ::google::protobuf::internal::NameOfEnum(
    Protocol_Port_descriptor(), value);
}
inline bool Protocol_Port_Parse(
    const ::std::string& name, Protocol_Port* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Protocol_Port>(
    Protocol_Port_descriptor(), name, value);
}
enum Camera_Type {
  Camera_Type_MAIN = 0,
  Camera_Type_SIDE_UP = 1,
  Camera_Type_SIDE_MIDDLE = 2,
  Camera_Type_SIDE_DOWN = 3,
  Camera_Type_THERMIC = 4
};
bool Camera_Type_IsValid(int value);
const Camera_Type Camera_Type_Type_MIN = Camera_Type_MAIN;
const Camera_Type Camera_Type_Type_MAX = Camera_Type_THERMIC;
const int Camera_Type_Type_ARRAYSIZE = Camera_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Camera_Type_descriptor();
inline const ::std::string& Camera_Type_Name(Camera_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Camera_Type_descriptor(), value);
}
inline bool Camera_Type_Parse(
    const ::std::string& name, Camera_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Camera_Type>(
    Camera_Type_descriptor(), name, value);
}
enum Turn_Sens {
  Turn_Sens_LEFT = 0,
  Turn_Sens_RIGHT = 1
};
bool Turn_Sens_IsValid(int value);
const Turn_Sens Turn_Sens_Sens_MIN = Turn_Sens_LEFT;
const Turn_Sens Turn_Sens_Sens_MAX = Turn_Sens_RIGHT;
const int Turn_Sens_Sens_ARRAYSIZE = Turn_Sens_Sens_MAX + 1;

const ::google::protobuf::EnumDescriptor* Turn_Sens_descriptor();
inline const ::std::string& Turn_Sens_Name(Turn_Sens value) {
  return ::google::protobuf::internal::NameOfEnum(
    Turn_Sens_descriptor(), value);
}
inline bool Turn_Sens_Parse(
    const ::std::string& name, Turn_Sens* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Turn_Sens>(
    Turn_Sens_descriptor(), name, value);
}
enum SetRobotMode_Type {
  SetRobotMode_Type_AUTOMATIC = 0,
  SetRobotMode_Type_MANUAL = 1
};
bool SetRobotMode_Type_IsValid(int value);
const SetRobotMode_Type SetRobotMode_Type_Type_MIN = SetRobotMode_Type_AUTOMATIC;
const SetRobotMode_Type SetRobotMode_Type_Type_MAX = SetRobotMode_Type_MANUAL;
const int SetRobotMode_Type_Type_ARRAYSIZE = SetRobotMode_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SetRobotMode_Type_descriptor();
inline const ::std::string& SetRobotMode_Type_Name(SetRobotMode_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SetRobotMode_Type_descriptor(), value);
}
inline bool SetRobotMode_Type_Parse(
    const ::std::string& name, SetRobotMode_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SetRobotMode_Type>(
    SetRobotMode_Type_descriptor(), name, value);
}
enum RobotState_Type {
  RobotState_Type_READY = 0,
  RobotState_Type_CHARGING = 1,
  RobotState_Type_REMAPPING = 2,
  RobotState_Type_PATROLLING = 3,
  RobotState_Type_MANUAL_CONTROLLED = 4,
  RobotState_Type_ALARM = 5,
  RobotState_Type_JOB_END = 6
};
bool RobotState_Type_IsValid(int value);
const RobotState_Type RobotState_Type_Type_MIN = RobotState_Type_READY;
const RobotState_Type RobotState_Type_Type_MAX = RobotState_Type_JOB_END;
const int RobotState_Type_Type_ARRAYSIZE = RobotState_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RobotState_Type_descriptor();
inline const ::std::string& RobotState_Type_Name(RobotState_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RobotState_Type_descriptor(), value);
}
inline bool RobotState_Type_Parse(
    const ::std::string& name, RobotState_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RobotState_Type>(
    RobotState_Type_descriptor(), name, value);
}
enum HardwareIssue_Issue {
  HardwareIssue_Issue_OBSTRUCTED_LASER = 0,
  HardwareIssue_Issue_MISSING_MAIN_LASER = 1,
  HardwareIssue_Issue_MISSING_THERMIC_CAMERA = 2,
  HardwareIssue_Issue_MISSING_OPTICAL_CAMERA = 3,
  HardwareIssue_Issue_MISSING_CONTROL_BOARD = 4,
  HardwareIssue_Issue_MISSING_SECURITY_LASER = 5,
  HardwareIssue_Issue_LOW_BATTERY = 6,
  HardwareIssue_Issue_CHARGING_FAILURE = 7,
  HardwareIssue_Issue_NETWORK_FAILURE = 8
};
bool HardwareIssue_Issue_IsValid(int value);
const HardwareIssue_Issue HardwareIssue_Issue_Issue_MIN = HardwareIssue_Issue_OBSTRUCTED_LASER;
const HardwareIssue_Issue HardwareIssue_Issue_Issue_MAX = HardwareIssue_Issue_NETWORK_FAILURE;
const int HardwareIssue_Issue_Issue_ARRAYSIZE = HardwareIssue_Issue_Issue_MAX + 1;

const ::google::protobuf::EnumDescriptor* HardwareIssue_Issue_descriptor();
inline const ::std::string& HardwareIssue_Issue_Name(HardwareIssue_Issue value) {
  return ::google::protobuf::internal::NameOfEnum(
    HardwareIssue_Issue_descriptor(), value);
}
inline bool HardwareIssue_Issue_Parse(
    const ::std::string& name, HardwareIssue_Issue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HardwareIssue_Issue>(
    HardwareIssue_Issue_descriptor(), name, value);
}
enum Alarm_Type {
  Alarm_Type_DISAPPEARED_OBJECT = 1,
  Alarm_Type_FIXED_OBSTACLE = 2,
  Alarm_Type_MOBILE_OBSTACLE = 3,
  Alarm_Type_HOTPOINT = 4,
  Alarm_Type_ROBOT_HARDWARE_ISSUE = 5,
  Alarm_Type_ROBOT_BLOCKED = 6,
  Alarm_Type_ROBOT_LOST = 7
};
bool Alarm_Type_IsValid(int value);
const Alarm_Type Alarm_Type_Type_MIN = Alarm_Type_DISAPPEARED_OBJECT;
const Alarm_Type Alarm_Type_Type_MAX = Alarm_Type_ROBOT_LOST;
const int Alarm_Type_Type_ARRAYSIZE = Alarm_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Alarm_Type_descriptor();
inline const ::std::string& Alarm_Type_Name(Alarm_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Alarm_Type_descriptor(), value);
}
inline bool Alarm_Type_Parse(
    const ::std::string& name, Alarm_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alarm_Type>(
    Alarm_Type_descriptor(), name, value);
}
enum Alarm_Status {
  Alarm_Status_ON = 0,
  Alarm_Status_OFF = 1,
  Alarm_Status_UPDATE = 2
};
bool Alarm_Status_IsValid(int value);
const Alarm_Status Alarm_Status_Status_MIN = Alarm_Status_ON;
const Alarm_Status Alarm_Status_Status_MAX = Alarm_Status_UPDATE;
const int Alarm_Status_Status_ARRAYSIZE = Alarm_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Alarm_Status_descriptor();
inline const ::std::string& Alarm_Status_Name(Alarm_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Alarm_Status_descriptor(), value);
}
inline bool Alarm_Status_Parse(
    const ::std::string& name, Alarm_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alarm_Status>(
    Alarm_Status_descriptor(), name, value);
}
enum BatteryState_State {
  BatteryState_State_CHARGING = 1,
  BatteryState_State_DISCHARGING = 2
};
bool BatteryState_State_IsValid(int value);
const BatteryState_State BatteryState_State_State_MIN = BatteryState_State_CHARGING;
const BatteryState_State BatteryState_State_State_MAX = BatteryState_State_DISCHARGING;
const int BatteryState_State_State_ARRAYSIZE = BatteryState_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* BatteryState_State_descriptor();
inline const ::std::string& BatteryState_State_Name(BatteryState_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    BatteryState_State_descriptor(), value);
}
inline bool BatteryState_State_Parse(
    const ::std::string& name, BatteryState_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BatteryState_State>(
    BatteryState_State_descriptor(), name, value);
}
enum ControlPatrolling_ACTION {
  ControlPatrolling_ACTION_START = 1,
  ControlPatrolling_ACTION_STOP = 2
};
bool ControlPatrolling_ACTION_IsValid(int value);
const ControlPatrolling_ACTION ControlPatrolling_ACTION_ACTION_MIN = ControlPatrolling_ACTION_START;
const ControlPatrolling_ACTION ControlPatrolling_ACTION_ACTION_MAX = ControlPatrolling_ACTION_STOP;
const int ControlPatrolling_ACTION_ACTION_ARRAYSIZE = ControlPatrolling_ACTION_ACTION_MAX + 1;

const ::google::protobuf::EnumDescriptor* ControlPatrolling_ACTION_descriptor();
inline const ::std::string& ControlPatrolling_ACTION_Name(ControlPatrolling_ACTION value) {
  return ::google::protobuf::internal::NameOfEnum(
    ControlPatrolling_ACTION_descriptor(), value);
}
inline bool ControlPatrolling_ACTION_Parse(
    const ::std::string& name, ControlPatrolling_ACTION* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ControlPatrolling_ACTION>(
    ControlPatrolling_ACTION_descriptor(), name, value);
}
enum RobotSensor_Type {
  RobotSensor_Type_DISTANCE = 0,
  RobotSensor_Type_ON_OFF = 1,
  RobotSensor_Type_TEMPERATURE = 2,
  RobotSensor_Type_HYDROMETRY = 3
};
bool RobotSensor_Type_IsValid(int value);
const RobotSensor_Type RobotSensor_Type_Type_MIN = RobotSensor_Type_DISTANCE;
const RobotSensor_Type RobotSensor_Type_Type_MAX = RobotSensor_Type_HYDROMETRY;
const int RobotSensor_Type_Type_ARRAYSIZE = RobotSensor_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RobotSensor_Type_descriptor();
inline const ::std::string& RobotSensor_Type_Name(RobotSensor_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RobotSensor_Type_descriptor(), value);
}
inline bool RobotSensor_Type_Parse(
    const ::std::string& name, RobotSensor_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RobotSensor_Type>(
    RobotSensor_Type_descriptor(), name, value);
}
enum CartoOrder_Action {
  CartoOrder_Action_START = 1,
  CartoOrder_Action_PAUSE = 2,
  CartoOrder_Action_STOP = 3,
  CartoOrder_Action_ABORT = 4
};
bool CartoOrder_Action_IsValid(int value);
const CartoOrder_Action CartoOrder_Action_Action_MIN = CartoOrder_Action_START;
const CartoOrder_Action CartoOrder_Action_Action_MAX = CartoOrder_Action_ABORT;
const int CartoOrder_Action_Action_ARRAYSIZE = CartoOrder_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* CartoOrder_Action_descriptor();
inline const ::std::string& CartoOrder_Action_Name(CartoOrder_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    CartoOrder_Action_descriptor(), value);
}
inline bool CartoOrder_Action_Parse(
    const ::std::string& name, CartoOrder_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CartoOrder_Action>(
    CartoOrder_Action_descriptor(), name, value);
}
enum CartoState_State {
  CartoState_State_STATE_STARTED = 1,
  CartoState_State_STATE_PAUSED = 2,
  CartoState_State_STATE_STOPPED = 3
};
bool CartoState_State_IsValid(int value);
const CartoState_State CartoState_State_State_MIN = CartoState_State_STATE_STARTED;
const CartoState_State CartoState_State_State_MAX = CartoState_State_STATE_STOPPED;
const int CartoState_State_State_ARRAYSIZE = CartoState_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* CartoState_State_descriptor();
inline const ::std::string& CartoState_State_Name(CartoState_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    CartoState_State_descriptor(), value);
}
inline bool CartoState_State_Parse(
    const ::std::string& name, CartoState_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CartoState_State>(
    CartoState_State_descriptor(), name, value);
}
enum CartoState_Result {
  CartoState_Result_RESULT_OK = 1,
  CartoState_Result_RESULT_ERROR = 2
};
bool CartoState_Result_IsValid(int value);
const CartoState_Result CartoState_Result_Result_MIN = CartoState_Result_RESULT_OK;
const CartoState_Result CartoState_Result_Result_MAX = CartoState_Result_RESULT_ERROR;
const int CartoState_Result_Result_ARRAYSIZE = CartoState_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* CartoState_Result_descriptor();
inline const ::std::string& CartoState_Result_Name(CartoState_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    CartoState_Result_descriptor(), value);
}
inline bool CartoState_Result_Parse(
    const ::std::string& name, CartoState_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CartoState_Result>(
    CartoState_Result_descriptor(), name, value);
}
// ===================================================================

class RobotDataSubscription : public ::google::protobuf::Message {
 public:
  RobotDataSubscription();
  virtual ~RobotDataSubscription();

  RobotDataSubscription(const RobotDataSubscription& from);

  inline RobotDataSubscription& operator=(const RobotDataSubscription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotDataSubscription& default_instance();

  void Swap(RobotDataSubscription* other);

  // implements Message ----------------------------------------------

  RobotDataSubscription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotDataSubscription& from);
  void MergeFrom(const RobotDataSubscription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 dataIndex = 1;
  inline int dataindex_size() const;
  inline void clear_dataindex();
  static const int kDataIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 dataindex(int index) const;
  inline void set_dataindex(int index, ::google::protobuf::uint32 value);
  inline void add_dataindex(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dataindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dataindex();

  // optional bool All = 2 [default = false];
  inline bool has_all() const;
  inline void clear_all();
  static const int kAllFieldNumber = 2;
  inline bool all() const;
  inline void set_all(bool value);

  // @@protoc_insertion_point(class_scope:eos.sdk.RobotDataSubscription)
 private:
  inline void set_has_all();
  inline void clear_has_all();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dataindex_;
  bool all_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static RobotDataSubscription* default_instance_;
};
// -------------------------------------------------------------------

class Protocol : public ::google::protobuf::Message {
 public:
  Protocol();
  virtual ~Protocol();

  Protocol(const Protocol& from);

  inline Protocol& operator=(const Protocol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Protocol& default_instance();

  void Swap(Protocol* other);

  // implements Message ----------------------------------------------

  Protocol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Protocol& from);
  void MergeFrom(const Protocol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Protocol_Port Port;
  static const Port PORT = Protocol_Port_PORT;
  static inline bool Port_IsValid(int value) {
    return Protocol_Port_IsValid(value);
  }
  static const Port Port_MIN =
    Protocol_Port_Port_MIN;
  static const Port Port_MAX =
    Protocol_Port_Port_MAX;
  static const int Port_ARRAYSIZE =
    Protocol_Port_Port_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Port_descriptor() {
    return Protocol_Port_descriptor();
  }
  static inline const ::std::string& Port_Name(Port value) {
    return Protocol_Port_Name(value);
  }
  static inline bool Port_Parse(const ::std::string& name,
      Port* value) {
    return Protocol_Port_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eos.sdk.Protocol)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static Protocol* default_instance_;
};
// -------------------------------------------------------------------

class Camera : public ::google::protobuf::Message {
 public:
  Camera();
  virtual ~Camera();

  Camera(const Camera& from);

  inline Camera& operator=(const Camera& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Camera& default_instance();

  void Swap(Camera* other);

  // implements Message ----------------------------------------------

  Camera* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Camera& from);
  void MergeFrom(const Camera& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Camera_Type Type;
  static const Type MAIN = Camera_Type_MAIN;
  static const Type SIDE_UP = Camera_Type_SIDE_UP;
  static const Type SIDE_MIDDLE = Camera_Type_SIDE_MIDDLE;
  static const Type SIDE_DOWN = Camera_Type_SIDE_DOWN;
  static const Type THERMIC = Camera_Type_THERMIC;
  static inline bool Type_IsValid(int value) {
    return Camera_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Camera_Type_Type_MIN;
  static const Type Type_MAX =
    Camera_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Camera_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Camera_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Camera_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Camera_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .eos.sdk.Camera.Type type = 1 [default = MAIN];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::eos::sdk::Camera_Type type() const;
  inline void set_type(::eos::sdk::Camera_Type value);

  // optional string ip_address = 2;
  inline bool has_ip_address() const;
  inline void clear_ip_address();
  static const int kIpAddressFieldNumber = 2;
  inline const ::std::string& ip_address() const;
  inline void set_ip_address(const ::std::string& value);
  inline void set_ip_address(const char* value);
  inline void set_ip_address(const char* value, size_t size);
  inline ::std::string* mutable_ip_address();
  inline ::std::string* release_ip_address();
  inline void set_allocated_ip_address(::std::string* ip_address);

  // optional uint32 port = 3 [default = 0];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // optional uint32 id = 4 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eos.sdk.Camera)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ip_address();
  inline void clear_has_ip_address();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_address_;
  int type_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static Camera* default_instance_;
};
// -------------------------------------------------------------------

class RobotInfo : public ::google::protobuf::Message {
 public:
  RobotInfo();
  virtual ~RobotInfo();

  RobotInfo(const RobotInfo& from);

  inline RobotInfo& operator=(const RobotInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotInfo& default_instance();

  void Swap(RobotInfo* other);

  // implements Message ----------------------------------------------

  RobotInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotInfo& from);
  void MergeFrom(const RobotInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint64 uptime = 2;
  inline bool has_uptime() const;
  inline void clear_uptime();
  static const int kUptimeFieldNumber = 2;
  inline ::google::protobuf::uint64 uptime() const;
  inline void set_uptime(::google::protobuf::uint64 value);

  // optional string filepath = 3;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 3;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // optional string robot_type = 4;
  inline bool has_robot_type() const;
  inline void clear_robot_type();
  static const int kRobotTypeFieldNumber = 4;
  inline const ::std::string& robot_type() const;
  inline void set_robot_type(const ::std::string& value);
  inline void set_robot_type(const char* value);
  inline void set_robot_type(const char* value, size_t size);
  inline ::std::string* mutable_robot_type();
  inline ::std::string* release_robot_type();
  inline void set_allocated_robot_type(::std::string* robot_type);

  // repeated .eos.sdk.Camera camera = 5;
  inline int camera_size() const;
  inline void clear_camera();
  static const int kCameraFieldNumber = 5;
  inline const ::eos::sdk::Camera& camera(int index) const;
  inline ::eos::sdk::Camera* mutable_camera(int index);
  inline ::eos::sdk::Camera* add_camera();
  inline const ::google::protobuf::RepeatedPtrField< ::eos::sdk::Camera >&
      camera() const;
  inline ::google::protobuf::RepeatedPtrField< ::eos::sdk::Camera >*
      mutable_camera();

  // @@protoc_insertion_point(class_scope:eos.sdk.RobotInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_uptime();
  inline void clear_has_uptime();
  inline void set_has_filepath();
  inline void clear_has_filepath();
  inline void set_has_robot_type();
  inline void clear_has_robot_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint64 uptime_;
  ::std::string* filepath_;
  ::std::string* robot_type_;
  ::google::protobuf::RepeatedPtrField< ::eos::sdk::Camera > camera_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static RobotInfo* default_instance_;
};
// -------------------------------------------------------------------

class JoystickCommand : public ::google::protobuf::Message {
 public:
  JoystickCommand();
  virtual ~JoystickCommand();

  JoystickCommand(const JoystickCommand& from);

  inline JoystickCommand& operator=(const JoystickCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoystickCommand& default_instance();

  void Swap(JoystickCommand* other);

  // implements Message ----------------------------------------------

  JoystickCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoystickCommand& from);
  void MergeFrom(const JoystickCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional bool super = 3 [default = false];
  inline bool has_super() const;
  inline void clear_super();
  static const int kSuperFieldNumber = 3;
  inline bool super() const;
  inline void set_super(bool value);

  // @@protoc_insertion_point(class_scope:eos.sdk.JoystickCommand)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_super();
  inline void clear_has_super();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  bool super_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static JoystickCommand* default_instance_;
};
// -------------------------------------------------------------------

class Turn : public ::google::protobuf::Message {
 public:
  Turn();
  virtual ~Turn();

  Turn(const Turn& from);

  inline Turn& operator=(const Turn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Turn& default_instance();

  void Swap(Turn* other);

  // implements Message ----------------------------------------------

  Turn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Turn& from);
  void MergeFrom(const Turn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Turn_Sens Sens;
  static const Sens LEFT = Turn_Sens_LEFT;
  static const Sens RIGHT = Turn_Sens_RIGHT;
  static inline bool Sens_IsValid(int value) {
    return Turn_Sens_IsValid(value);
  }
  static const Sens Sens_MIN =
    Turn_Sens_Sens_MIN;
  static const Sens Sens_MAX =
    Turn_Sens_Sens_MAX;
  static const int Sens_ARRAYSIZE =
    Turn_Sens_Sens_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Sens_descriptor() {
    return Turn_Sens_descriptor();
  }
  static inline const ::std::string& Sens_Name(Sens value) {
    return Turn_Sens_Name(value);
  }
  static inline bool Sens_Parse(const ::std::string& name,
      Sens* value) {
    return Turn_Sens_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .eos.sdk.Turn.Sens sens = 1 [default = LEFT];
  inline bool has_sens() const;
  inline void clear_sens();
  static const int kSensFieldNumber = 1;
  inline ::eos::sdk::Turn_Sens sens() const;
  inline void set_sens(::eos::sdk::Turn_Sens value);

  // @@protoc_insertion_point(class_scope:eos.sdk.Turn)
 private:
  inline void set_has_sens();
  inline void clear_has_sens();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int sens_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static Turn* default_instance_;
};
// -------------------------------------------------------------------

class Stop : public ::google::protobuf::Message {
 public:
  Stop();
  virtual ~Stop();

  Stop(const Stop& from);

  inline Stop& operator=(const Stop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stop& default_instance();

  void Swap(Stop* other);

  // implements Message ----------------------------------------------

  Stop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stop& from);
  void MergeFrom(const Stop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eos.sdk.Stop)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static Stop* default_instance_;
};
// -------------------------------------------------------------------

class SetRobotMode : public ::google::protobuf::Message {
 public:
  SetRobotMode();
  virtual ~SetRobotMode();

  SetRobotMode(const SetRobotMode& from);

  inline SetRobotMode& operator=(const SetRobotMode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetRobotMode& default_instance();

  void Swap(SetRobotMode* other);

  // implements Message ----------------------------------------------

  SetRobotMode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetRobotMode& from);
  void MergeFrom(const SetRobotMode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SetRobotMode_Type Type;
  static const Type AUTOMATIC = SetRobotMode_Type_AUTOMATIC;
  static const Type MANUAL = SetRobotMode_Type_MANUAL;
  static inline bool Type_IsValid(int value) {
    return SetRobotMode_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SetRobotMode_Type_Type_MIN;
  static const Type Type_MAX =
    SetRobotMode_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SetRobotMode_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SetRobotMode_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SetRobotMode_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SetRobotMode_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .eos.sdk.SetRobotMode.Type type = 1 [default = AUTOMATIC];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::eos::sdk::SetRobotMode_Type type() const;
  inline void set_type(::eos::sdk::SetRobotMode_Type value);

  // @@protoc_insertion_point(class_scope:eos.sdk.SetRobotMode)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static SetRobotMode* default_instance_;
};
// -------------------------------------------------------------------

class MoveTo : public ::google::protobuf::Message {
 public:
  MoveTo();
  virtual ~MoveTo();

  MoveTo(const MoveTo& from);

  inline MoveTo& operator=(const MoveTo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveTo& default_instance();

  void Swap(MoveTo* other);

  // implements Message ----------------------------------------------

  MoveTo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveTo& from);
  void MergeFrom(const MoveTo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int64 x() const;
  inline void set_x(::google::protobuf::int64 value);

  // required int64 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int64 y() const;
  inline void set_y(::google::protobuf::int64 value);

  // required double theta = 3;
  inline bool has_theta() const;
  inline void clear_theta();
  static const int kThetaFieldNumber = 3;
  inline double theta() const;
  inline void set_theta(double value);

  // @@protoc_insertion_point(class_scope:eos.sdk.MoveTo)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_theta();
  inline void clear_has_theta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 x_;
  ::google::protobuf::int64 y_;
  double theta_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static MoveTo* default_instance_;
};
// -------------------------------------------------------------------

class Hooter : public ::google::protobuf::Message {
 public:
  Hooter();
  virtual ~Hooter();

  Hooter(const Hooter& from);

  inline Hooter& operator=(const Hooter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hooter& default_instance();

  void Swap(Hooter* other);

  // implements Message ----------------------------------------------

  Hooter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hooter& from);
  void MergeFrom(const Hooter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  inline bool active() const;
  inline void set_active(bool value);

  // @@protoc_insertion_point(class_scope:eos.sdk.Hooter)
 private:
  inline void set_has_active();
  inline void clear_has_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static Hooter* default_instance_;
};
// -------------------------------------------------------------------

class ToggleCharging : public ::google::protobuf::Message {
 public:
  ToggleCharging();
  virtual ~ToggleCharging();

  ToggleCharging(const ToggleCharging& from);

  inline ToggleCharging& operator=(const ToggleCharging& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ToggleCharging& default_instance();

  void Swap(ToggleCharging* other);

  // implements Message ----------------------------------------------

  ToggleCharging* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ToggleCharging& from);
  void MergeFrom(const ToggleCharging& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  inline bool active() const;
  inline void set_active(bool value);

  // @@protoc_insertion_point(class_scope:eos.sdk.ToggleCharging)
 private:
  inline void set_has_active();
  inline void clear_has_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static ToggleCharging* default_instance_;
};
// -------------------------------------------------------------------

class ToggleComponentsPowerSupply : public ::google::protobuf::Message {
 public:
  ToggleComponentsPowerSupply();
  virtual ~ToggleComponentsPowerSupply();

  ToggleComponentsPowerSupply(const ToggleComponentsPowerSupply& from);

  inline ToggleComponentsPowerSupply& operator=(const ToggleComponentsPowerSupply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ToggleComponentsPowerSupply& default_instance();

  void Swap(ToggleComponentsPowerSupply* other);

  // implements Message ----------------------------------------------

  ToggleComponentsPowerSupply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ToggleComponentsPowerSupply& from);
  void MergeFrom(const ToggleComponentsPowerSupply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  inline bool active() const;
  inline void set_active(bool value);

  // @@protoc_insertion_point(class_scope:eos.sdk.ToggleComponentsPowerSupply)
 private:
  inline void set_has_active();
  inline void clear_has_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static ToggleComponentsPowerSupply* default_instance_;
};
// -------------------------------------------------------------------

class RobotPosition : public ::google::protobuf::Message {
 public:
  RobotPosition();
  virtual ~RobotPosition();

  RobotPosition(const RobotPosition& from);

  inline RobotPosition& operator=(const RobotPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotPosition& default_instance();

  void Swap(RobotPosition* other);

  // implements Message ----------------------------------------------

  RobotPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotPosition& from);
  void MergeFrom(const RobotPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int64 x() const;
  inline void set_x(::google::protobuf::int64 value);

  // required int64 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int64 y() const;
  inline void set_y(::google::protobuf::int64 value);

  // required double theta = 3;
  inline bool has_theta() const;
  inline void clear_theta();
  static const int kThetaFieldNumber = 3;
  inline double theta() const;
  inline void set_theta(double value);

  // @@protoc_insertion_point(class_scope:eos.sdk.RobotPosition)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_theta();
  inline void clear_has_theta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 x_;
  ::google::protobuf::int64 y_;
  double theta_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static RobotPosition* default_instance_;
};
// -------------------------------------------------------------------

class RobotVelocity : public ::google::protobuf::Message {
 public:
  RobotVelocity();
  virtual ~RobotVelocity();

  RobotVelocity(const RobotVelocity& from);

  inline RobotVelocity& operator=(const RobotVelocity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotVelocity& default_instance();

  void Swap(RobotVelocity* other);

  // implements Message ----------------------------------------------

  RobotVelocity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotVelocity& from);
  void MergeFrom(const RobotVelocity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float linear = 1;
  inline bool has_linear() const;
  inline void clear_linear();
  static const int kLinearFieldNumber = 1;
  inline float linear() const;
  inline void set_linear(float value);

  // required float angular = 2;
  inline bool has_angular() const;
  inline void clear_angular();
  static const int kAngularFieldNumber = 2;
  inline float angular() const;
  inline void set_angular(float value);

  // @@protoc_insertion_point(class_scope:eos.sdk.RobotVelocity)
 private:
  inline void set_has_linear();
  inline void clear_has_linear();
  inline void set_has_angular();
  inline void clear_has_angular();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float linear_;
  float angular_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static RobotVelocity* default_instance_;
};
// -------------------------------------------------------------------

class RobotState : public ::google::protobuf::Message {
 public:
  RobotState();
  virtual ~RobotState();

  RobotState(const RobotState& from);

  inline RobotState& operator=(const RobotState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotState& default_instance();

  void Swap(RobotState* other);

  // implements Message ----------------------------------------------

  RobotState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotState& from);
  void MergeFrom(const RobotState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RobotState_Type Type;
  static const Type READY = RobotState_Type_READY;
  static const Type CHARGING = RobotState_Type_CHARGING;
  static const Type REMAPPING = RobotState_Type_REMAPPING;
  static const Type PATROLLING = RobotState_Type_PATROLLING;
  static const Type MANUAL_CONTROLLED = RobotState_Type_MANUAL_CONTROLLED;
  static const Type ALARM = RobotState_Type_ALARM;
  static const Type JOB_END = RobotState_Type_JOB_END;
  static inline bool Type_IsValid(int value) {
    return RobotState_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RobotState_Type_Type_MIN;
  static const Type Type_MAX =
    RobotState_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RobotState_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RobotState_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RobotState_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RobotState_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .eos.sdk.RobotState.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::eos::sdk::RobotState_Type type() const;
  inline void set_type(::eos::sdk::RobotState_Type value);

  // @@protoc_insertion_point(class_scope:eos.sdk.RobotState)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static RobotState* default_instance_;
};
// -------------------------------------------------------------------

class HardwareIssue : public ::google::protobuf::Message {
 public:
  HardwareIssue();
  virtual ~HardwareIssue();

  HardwareIssue(const HardwareIssue& from);

  inline HardwareIssue& operator=(const HardwareIssue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HardwareIssue& default_instance();

  void Swap(HardwareIssue* other);

  // implements Message ----------------------------------------------

  HardwareIssue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HardwareIssue& from);
  void MergeFrom(const HardwareIssue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HardwareIssue_Issue Issue;
  static const Issue OBSTRUCTED_LASER = HardwareIssue_Issue_OBSTRUCTED_LASER;
  static const Issue MISSING_MAIN_LASER = HardwareIssue_Issue_MISSING_MAIN_LASER;
  static const Issue MISSING_THERMIC_CAMERA = HardwareIssue_Issue_MISSING_THERMIC_CAMERA;
  static const Issue MISSING_OPTICAL_CAMERA = HardwareIssue_Issue_MISSING_OPTICAL_CAMERA;
  static const Issue MISSING_CONTROL_BOARD = HardwareIssue_Issue_MISSING_CONTROL_BOARD;
  static const Issue MISSING_SECURITY_LASER = HardwareIssue_Issue_MISSING_SECURITY_LASER;
  static const Issue LOW_BATTERY = HardwareIssue_Issue_LOW_BATTERY;
  static const Issue CHARGING_FAILURE = HardwareIssue_Issue_CHARGING_FAILURE;
  static const Issue NETWORK_FAILURE = HardwareIssue_Issue_NETWORK_FAILURE;
  static inline bool Issue_IsValid(int value) {
    return HardwareIssue_Issue_IsValid(value);
  }
  static const Issue Issue_MIN =
    HardwareIssue_Issue_Issue_MIN;
  static const Issue Issue_MAX =
    HardwareIssue_Issue_Issue_MAX;
  static const int Issue_ARRAYSIZE =
    HardwareIssue_Issue_Issue_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Issue_descriptor() {
    return HardwareIssue_Issue_descriptor();
  }
  static inline const ::std::string& Issue_Name(Issue value) {
    return HardwareIssue_Issue_Name(value);
  }
  static inline bool Issue_Parse(const ::std::string& name,
      Issue* value) {
    return HardwareIssue_Issue_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .eos.sdk.HardwareIssue.Issue issue = 1;
  inline bool has_issue() const;
  inline void clear_issue();
  static const int kIssueFieldNumber = 1;
  inline ::eos::sdk::HardwareIssue_Issue issue() const;
  inline void set_issue(::eos::sdk::HardwareIssue_Issue value);

  // @@protoc_insertion_point(class_scope:eos.sdk.HardwareIssue)
 private:
  inline void set_has_issue();
  inline void clear_has_issue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int issue_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static HardwareIssue* default_instance_;
};
// -------------------------------------------------------------------

class Alarm : public ::google::protobuf::Message {
 public:
  Alarm();
  virtual ~Alarm();

  Alarm(const Alarm& from);

  inline Alarm& operator=(const Alarm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Alarm& default_instance();

  void Swap(Alarm* other);

  // implements Message ----------------------------------------------

  Alarm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Alarm& from);
  void MergeFrom(const Alarm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Alarm_Type Type;
  static const Type DISAPPEARED_OBJECT = Alarm_Type_DISAPPEARED_OBJECT;
  static const Type FIXED_OBSTACLE = Alarm_Type_FIXED_OBSTACLE;
  static const Type MOBILE_OBSTACLE = Alarm_Type_MOBILE_OBSTACLE;
  static const Type HOTPOINT = Alarm_Type_HOTPOINT;
  static const Type ROBOT_HARDWARE_ISSUE = Alarm_Type_ROBOT_HARDWARE_ISSUE;
  static const Type ROBOT_BLOCKED = Alarm_Type_ROBOT_BLOCKED;
  static const Type ROBOT_LOST = Alarm_Type_ROBOT_LOST;
  static inline bool Type_IsValid(int value) {
    return Alarm_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Alarm_Type_Type_MIN;
  static const Type Type_MAX =
    Alarm_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Alarm_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Alarm_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Alarm_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Alarm_Type_Parse(name, value);
  }

  typedef Alarm_Status Status;
  static const Status ON = Alarm_Status_ON;
  static const Status OFF = Alarm_Status_OFF;
  static const Status UPDATE = Alarm_Status_UPDATE;
  static inline bool Status_IsValid(int value) {
    return Alarm_Status_IsValid(value);
  }
  static const Status Status_MIN =
    Alarm_Status_Status_MIN;
  static const Status Status_MAX =
    Alarm_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    Alarm_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return Alarm_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return Alarm_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return Alarm_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // required uint32 distance = 4;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 4;
  inline ::google::protobuf::uint32 distance() const;
  inline void set_distance(::google::protobuf::uint32 value);

  // required .eos.sdk.Alarm.Type type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::eos::sdk::Alarm_Type type() const;
  inline void set_type(::eos::sdk::Alarm_Type value);

  // required .eos.sdk.Alarm.Status status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::eos::sdk::Alarm_Status status() const;
  inline void set_status(::eos::sdk::Alarm_Status value);

  // @@protoc_insertion_point(class_scope:eos.sdk.Alarm)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 distance_;
  int type_;
  int status_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static Alarm* default_instance_;
};
// -------------------------------------------------------------------

class AlarmUpdate : public ::google::protobuf::Message {
 public:
  AlarmUpdate();
  virtual ~AlarmUpdate();

  AlarmUpdate(const AlarmUpdate& from);

  inline AlarmUpdate& operator=(const AlarmUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlarmUpdate& default_instance();

  void Swap(AlarmUpdate* other);

  // implements Message ----------------------------------------------

  AlarmUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlarmUpdate& from);
  void MergeFrom(const AlarmUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required uint32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // required uint32 distance = 4;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 4;
  inline ::google::protobuf::uint32 distance() const;
  inline void set_distance(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eos.sdk.AlarmUpdate)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_distance();
  inline void clear_has_distance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 distance_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static AlarmUpdate* default_instance_;
};
// -------------------------------------------------------------------

class BatteryState : public ::google::protobuf::Message {
 public:
  BatteryState();
  virtual ~BatteryState();

  BatteryState(const BatteryState& from);

  inline BatteryState& operator=(const BatteryState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatteryState& default_instance();

  void Swap(BatteryState* other);

  // implements Message ----------------------------------------------

  BatteryState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatteryState& from);
  void MergeFrom(const BatteryState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BatteryState_State State;
  static const State CHARGING = BatteryState_State_CHARGING;
  static const State DISCHARGING = BatteryState_State_DISCHARGING;
  static inline bool State_IsValid(int value) {
    return BatteryState_State_IsValid(value);
  }
  static const State State_MIN =
    BatteryState_State_State_MIN;
  static const State State_MAX =
    BatteryState_State_State_MAX;
  static const int State_ARRAYSIZE =
    BatteryState_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return BatteryState_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return BatteryState_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return BatteryState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .eos.sdk.BatteryState.State state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::eos::sdk::BatteryState_State state() const;
  inline void set_state(::eos::sdk::BatteryState_State value);

  // required float level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline float level() const;
  inline void set_level(float value);

  // required float tension = 3;
  inline bool has_tension() const;
  inline void clear_tension();
  static const int kTensionFieldNumber = 3;
  inline float tension() const;
  inline void set_tension(float value);

  // @@protoc_insertion_point(class_scope:eos.sdk.BatteryState)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_tension();
  inline void clear_has_tension();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int state_;
  float level_;
  float tension_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static BatteryState* default_instance_;
};
// -------------------------------------------------------------------

class LaserShot : public ::google::protobuf::Message {
 public:
  LaserShot();
  virtual ~LaserShot();

  LaserShot(const LaserShot& from);

  inline LaserShot& operator=(const LaserShot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaserShot& default_instance();

  void Swap(LaserShot* other);

  // implements Message ----------------------------------------------

  LaserShot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaserShot& from);
  void MergeFrom(const LaserShot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float x_array = 1;
  inline int x_array_size() const;
  inline void clear_x_array();
  static const int kXArrayFieldNumber = 1;
  inline float x_array(int index) const;
  inline void set_x_array(int index, float value);
  inline void add_x_array(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      x_array() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_x_array();

  // repeated float y_array = 2;
  inline int y_array_size() const;
  inline void clear_y_array();
  static const int kYArrayFieldNumber = 2;
  inline float y_array(int index) const;
  inline void set_y_array(int index, float value);
  inline void add_y_array(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      y_array() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_y_array();

  // @@protoc_insertion_point(class_scope:eos.sdk.LaserShot)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > x_array_;
  ::google::protobuf::RepeatedField< float > y_array_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static LaserShot* default_instance_;
};
// -------------------------------------------------------------------

class RobotMonitoring : public ::google::protobuf::Message {
 public:
  RobotMonitoring();
  virtual ~RobotMonitoring();

  RobotMonitoring(const RobotMonitoring& from);

  inline RobotMonitoring& operator=(const RobotMonitoring& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotMonitoring& default_instance();

  void Swap(RobotMonitoring* other);

  // implements Message ----------------------------------------------

  RobotMonitoring* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotMonitoring& from);
  void MergeFrom(const RobotMonitoring& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 current_score = 3;
  inline bool has_current_score() const;
  inline void clear_current_score();
  static const int kCurrentScoreFieldNumber = 3;
  inline ::google::protobuf::uint64 current_score() const;
  inline void set_current_score(::google::protobuf::uint64 value);

  // optional uint64 min_score = 4;
  inline bool has_min_score() const;
  inline void clear_min_score();
  static const int kMinScoreFieldNumber = 4;
  inline ::google::protobuf::uint64 min_score() const;
  inline void set_min_score(::google::protobuf::uint64 value);

  // optional uint64 max_score = 5;
  inline bool has_max_score() const;
  inline void clear_max_score();
  static const int kMaxScoreFieldNumber = 5;
  inline ::google::protobuf::uint64 max_score() const;
  inline void set_max_score(::google::protobuf::uint64 value);

  // optional uint64 avg_score = 6;
  inline bool has_avg_score() const;
  inline void clear_avg_score();
  static const int kAvgScoreFieldNumber = 6;
  inline ::google::protobuf::uint64 avg_score() const;
  inline void set_avg_score(::google::protobuf::uint64 value);

  // optional uint64 switch_to_mapping = 7;
  inline bool has_switch_to_mapping() const;
  inline void clear_switch_to_mapping();
  static const int kSwitchToMappingFieldNumber = 7;
  inline ::google::protobuf::uint64 switch_to_mapping() const;
  inline void set_switch_to_mapping(::google::protobuf::uint64 value);

  // optional uint64 switch_to_localization = 8;
  inline bool has_switch_to_localization() const;
  inline void clear_switch_to_localization();
  static const int kSwitchToLocalizationFieldNumber = 8;
  inline ::google::protobuf::uint64 switch_to_localization() const;
  inline void set_switch_to_localization(::google::protobuf::uint64 value);

  // optional uint64 switch_to_relocalization = 9;
  inline bool has_switch_to_relocalization() const;
  inline void clear_switch_to_relocalization();
  static const int kSwitchToRelocalizationFieldNumber = 9;
  inline ::google::protobuf::uint64 switch_to_relocalization() const;
  inline void set_switch_to_relocalization(::google::protobuf::uint64 value);

  // optional .eos.sdk.LaserShot laser = 10;
  inline bool has_laser() const;
  inline void clear_laser();
  static const int kLaserFieldNumber = 10;
  inline const ::eos::sdk::LaserShot& laser() const;
  inline ::eos::sdk::LaserShot* mutable_laser();
  inline ::eos::sdk::LaserShot* release_laser();
  inline void set_allocated_laser(::eos::sdk::LaserShot* laser);

  // @@protoc_insertion_point(class_scope:eos.sdk.RobotMonitoring)
 private:
  inline void set_has_current_score();
  inline void clear_has_current_score();
  inline void set_has_min_score();
  inline void clear_has_min_score();
  inline void set_has_max_score();
  inline void clear_has_max_score();
  inline void set_has_avg_score();
  inline void clear_has_avg_score();
  inline void set_has_switch_to_mapping();
  inline void clear_has_switch_to_mapping();
  inline void set_has_switch_to_localization();
  inline void clear_has_switch_to_localization();
  inline void set_has_switch_to_relocalization();
  inline void clear_has_switch_to_relocalization();
  inline void set_has_laser();
  inline void clear_has_laser();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 current_score_;
  ::google::protobuf::uint64 min_score_;
  ::google::protobuf::uint64 max_score_;
  ::google::protobuf::uint64 avg_score_;
  ::google::protobuf::uint64 switch_to_mapping_;
  ::google::protobuf::uint64 switch_to_localization_;
  ::google::protobuf::uint64 switch_to_relocalization_;
  ::eos::sdk::LaserShot* laser_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static RobotMonitoring* default_instance_;
};
// -------------------------------------------------------------------

class ScoresThreshold : public ::google::protobuf::Message {
 public:
  ScoresThreshold();
  virtual ~ScoresThreshold();

  ScoresThreshold(const ScoresThreshold& from);

  inline ScoresThreshold& operator=(const ScoresThreshold& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScoresThreshold& default_instance();

  void Swap(ScoresThreshold* other);

  // implements Message ----------------------------------------------

  ScoresThreshold* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScoresThreshold& from);
  void MergeFrom(const ScoresThreshold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 switch_to_mapping = 1;
  inline bool has_switch_to_mapping() const;
  inline void clear_switch_to_mapping();
  static const int kSwitchToMappingFieldNumber = 1;
  inline ::google::protobuf::uint64 switch_to_mapping() const;
  inline void set_switch_to_mapping(::google::protobuf::uint64 value);

  // required uint64 switch_to_localization = 2;
  inline bool has_switch_to_localization() const;
  inline void clear_switch_to_localization();
  static const int kSwitchToLocalizationFieldNumber = 2;
  inline ::google::protobuf::uint64 switch_to_localization() const;
  inline void set_switch_to_localization(::google::protobuf::uint64 value);

  // required uint64 switch_to_relocalization = 3;
  inline bool has_switch_to_relocalization() const;
  inline void clear_switch_to_relocalization();
  static const int kSwitchToRelocalizationFieldNumber = 3;
  inline ::google::protobuf::uint64 switch_to_relocalization() const;
  inline void set_switch_to_relocalization(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:eos.sdk.ScoresThreshold)
 private:
  inline void set_has_switch_to_mapping();
  inline void clear_has_switch_to_mapping();
  inline void set_has_switch_to_localization();
  inline void clear_has_switch_to_localization();
  inline void set_has_switch_to_relocalization();
  inline void clear_has_switch_to_relocalization();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 switch_to_mapping_;
  ::google::protobuf::uint64 switch_to_localization_;
  ::google::protobuf::uint64 switch_to_relocalization_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static ScoresThreshold* default_instance_;
};
// -------------------------------------------------------------------

class ControlPatrolling : public ::google::protobuf::Message {
 public:
  ControlPatrolling();
  virtual ~ControlPatrolling();

  ControlPatrolling(const ControlPatrolling& from);

  inline ControlPatrolling& operator=(const ControlPatrolling& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlPatrolling& default_instance();

  void Swap(ControlPatrolling* other);

  // implements Message ----------------------------------------------

  ControlPatrolling* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlPatrolling& from);
  void MergeFrom(const ControlPatrolling& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ControlPatrolling_ACTION ACTION;
  static const ACTION START = ControlPatrolling_ACTION_START;
  static const ACTION STOP = ControlPatrolling_ACTION_STOP;
  static inline bool ACTION_IsValid(int value) {
    return ControlPatrolling_ACTION_IsValid(value);
  }
  static const ACTION ACTION_MIN =
    ControlPatrolling_ACTION_ACTION_MIN;
  static const ACTION ACTION_MAX =
    ControlPatrolling_ACTION_ACTION_MAX;
  static const int ACTION_ARRAYSIZE =
    ControlPatrolling_ACTION_ACTION_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ACTION_descriptor() {
    return ControlPatrolling_ACTION_descriptor();
  }
  static inline const ::std::string& ACTION_Name(ACTION value) {
    return ControlPatrolling_ACTION_Name(value);
  }
  static inline bool ACTION_Parse(const ::std::string& name,
      ACTION* value) {
    return ControlPatrolling_ACTION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .eos.sdk.ControlPatrolling.ACTION action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::eos::sdk::ControlPatrolling_ACTION action() const;
  inline void set_action(::eos::sdk::ControlPatrolling_ACTION value);

  // required string patrol_name = 2;
  inline bool has_patrol_name() const;
  inline void clear_patrol_name();
  static const int kPatrolNameFieldNumber = 2;
  inline const ::std::string& patrol_name() const;
  inline void set_patrol_name(const ::std::string& value);
  inline void set_patrol_name(const char* value);
  inline void set_patrol_name(const char* value, size_t size);
  inline ::std::string* mutable_patrol_name();
  inline ::std::string* release_patrol_name();
  inline void set_allocated_patrol_name(::std::string* patrol_name);

  // required uint32 duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eos.sdk.ControlPatrolling)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_patrol_name();
  inline void clear_has_patrol_name();
  inline void set_has_duration();
  inline void clear_has_duration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* patrol_name_;
  int action_;
  ::google::protobuf::uint32 duration_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static ControlPatrolling* default_instance_;
};
// -------------------------------------------------------------------

class EmergencyStop : public ::google::protobuf::Message {
 public:
  EmergencyStop();
  virtual ~EmergencyStop();

  EmergencyStop(const EmergencyStop& from);

  inline EmergencyStop& operator=(const EmergencyStop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmergencyStop& default_instance();

  void Swap(EmergencyStop* other);

  // implements Message ----------------------------------------------

  EmergencyStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmergencyStop& from);
  void MergeFrom(const EmergencyStop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  inline bool active() const;
  inline void set_active(bool value);

  // @@protoc_insertion_point(class_scope:eos.sdk.EmergencyStop)
 private:
  inline void set_has_active();
  inline void clear_has_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static EmergencyStop* default_instance_;
};
// -------------------------------------------------------------------

class DynamicObstacle : public ::google::protobuf::Message {
 public:
  DynamicObstacle();
  virtual ~DynamicObstacle();

  DynamicObstacle(const DynamicObstacle& from);

  inline DynamicObstacle& operator=(const DynamicObstacle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DynamicObstacle& default_instance();

  void Swap(DynamicObstacle* other);

  // implements Message ----------------------------------------------

  DynamicObstacle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DynamicObstacle& from);
  void MergeFrom(const DynamicObstacle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  inline bool active() const;
  inline void set_active(bool value);

  // required uint32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // required uint32 radius = 4;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 4;
  inline ::google::protobuf::uint32 radius() const;
  inline void set_radius(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eos.sdk.DynamicObstacle)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool active_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 radius_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static DynamicObstacle* default_instance_;
};
// -------------------------------------------------------------------

class ClearDynamicObstacles : public ::google::protobuf::Message {
 public:
  ClearDynamicObstacles();
  virtual ~ClearDynamicObstacles();

  ClearDynamicObstacles(const ClearDynamicObstacles& from);

  inline ClearDynamicObstacles& operator=(const ClearDynamicObstacles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClearDynamicObstacles& default_instance();

  void Swap(ClearDynamicObstacles* other);

  // implements Message ----------------------------------------------

  ClearDynamicObstacles* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClearDynamicObstacles& from);
  void MergeFrom(const ClearDynamicObstacles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eos.sdk.ClearDynamicObstacles)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static ClearDynamicObstacles* default_instance_;
};
// -------------------------------------------------------------------

class RobotSensor : public ::google::protobuf::Message {
 public:
  RobotSensor();
  virtual ~RobotSensor();

  RobotSensor(const RobotSensor& from);

  inline RobotSensor& operator=(const RobotSensor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotSensor& default_instance();

  void Swap(RobotSensor* other);

  // implements Message ----------------------------------------------

  RobotSensor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotSensor& from);
  void MergeFrom(const RobotSensor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RobotSensor_Type Type;
  static const Type DISTANCE = RobotSensor_Type_DISTANCE;
  static const Type ON_OFF = RobotSensor_Type_ON_OFF;
  static const Type TEMPERATURE = RobotSensor_Type_TEMPERATURE;
  static const Type HYDROMETRY = RobotSensor_Type_HYDROMETRY;
  static inline bool Type_IsValid(int value) {
    return RobotSensor_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RobotSensor_Type_Type_MIN;
  static const Type Type_MAX =
    RobotSensor_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RobotSensor_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RobotSensor_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RobotSensor_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RobotSensor_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required .eos.sdk.RobotSensor.Type type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::eos::sdk::RobotSensor_Type type() const;
  inline void set_type(::eos::sdk::RobotSensor_Type value);

  // required string unit = 3;
  inline bool has_unit() const;
  inline void clear_unit();
  static const int kUnitFieldNumber = 3;
  inline const ::std::string& unit() const;
  inline void set_unit(const ::std::string& value);
  inline void set_unit(const char* value);
  inline void set_unit(const char* value, size_t size);
  inline ::std::string* mutable_unit();
  inline ::std::string* release_unit();
  inline void set_allocated_unit(::std::string* unit);

  // required float value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline float value() const;
  inline void set_value(float value);

  // @@protoc_insertion_point(class_scope:eos.sdk.RobotSensor)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_unit();
  inline void clear_has_unit();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::std::string* unit_;
  int type_;
  float value_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static RobotSensor* default_instance_;
};
// -------------------------------------------------------------------

class RobotSensors : public ::google::protobuf::Message {
 public:
  RobotSensors();
  virtual ~RobotSensors();

  RobotSensors(const RobotSensors& from);

  inline RobotSensors& operator=(const RobotSensors& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotSensors& default_instance();

  void Swap(RobotSensors* other);

  // implements Message ----------------------------------------------

  RobotSensors* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotSensors& from);
  void MergeFrom(const RobotSensors& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .eos.sdk.RobotSensor sensors = 1;
  inline int sensors_size() const;
  inline void clear_sensors();
  static const int kSensorsFieldNumber = 1;
  inline const ::eos::sdk::RobotSensor& sensors(int index) const;
  inline ::eos::sdk::RobotSensor* mutable_sensors(int index);
  inline ::eos::sdk::RobotSensor* add_sensors();
  inline const ::google::protobuf::RepeatedPtrField< ::eos::sdk::RobotSensor >&
      sensors() const;
  inline ::google::protobuf::RepeatedPtrField< ::eos::sdk::RobotSensor >*
      mutable_sensors();

  // @@protoc_insertion_point(class_scope:eos.sdk.RobotSensors)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::eos::sdk::RobotSensor > sensors_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static RobotSensors* default_instance_;
};
// -------------------------------------------------------------------

class NewMapAvailable : public ::google::protobuf::Message {
 public:
  NewMapAvailable();
  virtual ~NewMapAvailable();

  NewMapAvailable(const NewMapAvailable& from);

  inline NewMapAvailable& operator=(const NewMapAvailable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewMapAvailable& default_instance();

  void Swap(NewMapAvailable* other);

  // implements Message ----------------------------------------------

  NewMapAvailable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewMapAvailable& from);
  void MergeFrom(const NewMapAvailable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eos.sdk.NewMapAvailable)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static NewMapAvailable* default_instance_;
};
// -------------------------------------------------------------------

class CartoOrder : public ::google::protobuf::Message {
 public:
  CartoOrder();
  virtual ~CartoOrder();

  CartoOrder(const CartoOrder& from);

  inline CartoOrder& operator=(const CartoOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartoOrder& default_instance();

  void Swap(CartoOrder* other);

  // implements Message ----------------------------------------------

  CartoOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CartoOrder& from);
  void MergeFrom(const CartoOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CartoOrder_Action Action;
  static const Action START = CartoOrder_Action_START;
  static const Action PAUSE = CartoOrder_Action_PAUSE;
  static const Action STOP = CartoOrder_Action_STOP;
  static const Action ABORT = CartoOrder_Action_ABORT;
  static inline bool Action_IsValid(int value) {
    return CartoOrder_Action_IsValid(value);
  }
  static const Action Action_MIN =
    CartoOrder_Action_Action_MIN;
  static const Action Action_MAX =
    CartoOrder_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    CartoOrder_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return CartoOrder_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return CartoOrder_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return CartoOrder_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .eos.sdk.CartoOrder.Action action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::eos::sdk::CartoOrder_Action action() const;
  inline void set_action(::eos::sdk::CartoOrder_Action value);

  // optional float resolution = 2;
  inline bool has_resolution() const;
  inline void clear_resolution();
  static const int kResolutionFieldNumber = 2;
  inline float resolution() const;
  inline void set_resolution(float value);

  // optional uint32 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eos.sdk.CartoOrder)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_resolution();
  inline void clear_has_resolution();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int action_;
  float resolution_;
  ::google::protobuf::uint32 size_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static CartoOrder* default_instance_;
};
// -------------------------------------------------------------------

class CartoState : public ::google::protobuf::Message {
 public:
  CartoState();
  virtual ~CartoState();

  CartoState(const CartoState& from);

  inline CartoState& operator=(const CartoState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CartoState& default_instance();

  void Swap(CartoState* other);

  // implements Message ----------------------------------------------

  CartoState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CartoState& from);
  void MergeFrom(const CartoState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CartoState_State State;
  static const State STATE_STARTED = CartoState_State_STATE_STARTED;
  static const State STATE_PAUSED = CartoState_State_STATE_PAUSED;
  static const State STATE_STOPPED = CartoState_State_STATE_STOPPED;
  static inline bool State_IsValid(int value) {
    return CartoState_State_IsValid(value);
  }
  static const State State_MIN =
    CartoState_State_State_MIN;
  static const State State_MAX =
    CartoState_State_State_MAX;
  static const int State_ARRAYSIZE =
    CartoState_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return CartoState_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return CartoState_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return CartoState_State_Parse(name, value);
  }

  typedef CartoState_Result Result;
  static const Result RESULT_OK = CartoState_Result_RESULT_OK;
  static const Result RESULT_ERROR = CartoState_Result_RESULT_ERROR;
  static inline bool Result_IsValid(int value) {
    return CartoState_Result_IsValid(value);
  }
  static const Result Result_MIN =
    CartoState_Result_Result_MIN;
  static const Result Result_MAX =
    CartoState_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    CartoState_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return CartoState_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return CartoState_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return CartoState_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .eos.sdk.CartoState.State state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::eos::sdk::CartoState_State state() const;
  inline void set_state(::eos::sdk::CartoState_State value);

  // required .eos.sdk.CartoState.Result result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::eos::sdk::CartoState_Result result() const;
  inline void set_result(::eos::sdk::CartoState_Result value);

  // required string description = 3;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 3;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:eos.sdk.CartoState)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int state_;
  int result_;
  ::std::string* description_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static CartoState* default_instance_;
};
// -------------------------------------------------------------------

class Version : public ::google::protobuf::Message {
 public:
  Version();
  virtual ~Version();

  Version(const Version& from);

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Version& default_instance();

  void Swap(Version* other);

  // implements Message ----------------------------------------------

  Version* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 value = 1 [default = 20161108];
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint64 value() const;
  inline void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:eos.sdk.Version)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 value_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static Version* default_instance_;
};
// -------------------------------------------------------------------

class Reboot : public ::google::protobuf::Message {
 public:
  Reboot();
  virtual ~Reboot();

  Reboot(const Reboot& from);

  inline Reboot& operator=(const Reboot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reboot& default_instance();

  void Swap(Reboot* other);

  // implements Message ----------------------------------------------

  Reboot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reboot& from);
  void MergeFrom(const Reboot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:eos.sdk.Reboot)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_msgs_2eproto();
  friend void protobuf_AssignDesc_msgs_2eproto();
  friend void protobuf_ShutdownFile_msgs_2eproto();

  void InitAsDefaultInstance();
  static Reboot* default_instance_;
};
// ===================================================================


// ===================================================================

// RobotDataSubscription

// repeated uint32 dataIndex = 1;
inline int RobotDataSubscription::dataindex_size() const {
  return dataindex_.size();
}
inline void RobotDataSubscription::clear_dataindex() {
  dataindex_.Clear();
}
inline ::google::protobuf::uint32 RobotDataSubscription::dataindex(int index) const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotDataSubscription.dataIndex)
  return dataindex_.Get(index);
}
inline void RobotDataSubscription::set_dataindex(int index, ::google::protobuf::uint32 value) {
  dataindex_.Set(index, value);
  // @@protoc_insertion_point(field_set:eos.sdk.RobotDataSubscription.dataIndex)
}
inline void RobotDataSubscription::add_dataindex(::google::protobuf::uint32 value) {
  dataindex_.Add(value);
  // @@protoc_insertion_point(field_add:eos.sdk.RobotDataSubscription.dataIndex)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RobotDataSubscription::dataindex() const {
  // @@protoc_insertion_point(field_list:eos.sdk.RobotDataSubscription.dataIndex)
  return dataindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RobotDataSubscription::mutable_dataindex() {
  // @@protoc_insertion_point(field_mutable_list:eos.sdk.RobotDataSubscription.dataIndex)
  return &dataindex_;
}

// optional bool All = 2 [default = false];
inline bool RobotDataSubscription::has_all() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotDataSubscription::set_has_all() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotDataSubscription::clear_has_all() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotDataSubscription::clear_all() {
  all_ = false;
  clear_has_all();
}
inline bool RobotDataSubscription::all() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotDataSubscription.All)
  return all_;
}
inline void RobotDataSubscription::set_all(bool value) {
  set_has_all();
  all_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotDataSubscription.All)
}

// -------------------------------------------------------------------

// Protocol

// -------------------------------------------------------------------

// Camera

// optional .eos.sdk.Camera.Type type = 1 [default = MAIN];
inline bool Camera::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Camera::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Camera::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Camera::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::eos::sdk::Camera_Type Camera::type() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Camera.type)
  return static_cast< ::eos::sdk::Camera_Type >(type_);
}
inline void Camera::set_type(::eos::sdk::Camera_Type value) {
  assert(::eos::sdk::Camera_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.Camera.type)
}

// optional string ip_address = 2;
inline bool Camera::has_ip_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Camera::set_has_ip_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Camera::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Camera::clear_ip_address() {
  if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_->clear();
  }
  clear_has_ip_address();
}
inline const ::std::string& Camera::ip_address() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Camera.ip_address)
  return *ip_address_;
}
inline void Camera::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
  // @@protoc_insertion_point(field_set:eos.sdk.Camera.ip_address)
}
inline void Camera::set_ip_address(const char* value) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.sdk.Camera.ip_address)
}
inline void Camera::set_ip_address(const char* value, size_t size) {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  ip_address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.sdk.Camera.ip_address)
}
inline ::std::string* Camera::mutable_ip_address() {
  set_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.sdk.Camera.ip_address)
  return ip_address_;
}
inline ::std::string* Camera::release_ip_address() {
  clear_has_ip_address();
  if (ip_address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_address_;
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Camera::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_address_;
  }
  if (ip_address) {
    set_has_ip_address();
    ip_address_ = ip_address;
  } else {
    clear_has_ip_address();
    ip_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.sdk.Camera.ip_address)
}

// optional uint32 port = 3 [default = 0];
inline bool Camera::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Camera::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Camera::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Camera::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 Camera::port() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Camera.port)
  return port_;
}
inline void Camera::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.Camera.port)
}

// optional uint32 id = 4 [default = 0];
inline bool Camera::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Camera::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Camera::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Camera::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Camera::id() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Camera.id)
  return id_;
}
inline void Camera::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.Camera.id)
}

// -------------------------------------------------------------------

// RobotInfo

// optional string name = 1;
inline bool RobotInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RobotInfo::name() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotInfo.name)
  return *name_;
}
inline void RobotInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:eos.sdk.RobotInfo.name)
}
inline void RobotInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.sdk.RobotInfo.name)
}
inline void RobotInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.sdk.RobotInfo.name)
}
inline ::std::string* RobotInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.sdk.RobotInfo.name)
  return name_;
}
inline ::std::string* RobotInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RobotInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.sdk.RobotInfo.name)
}

// optional uint64 uptime = 2;
inline bool RobotInfo::has_uptime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotInfo::set_has_uptime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotInfo::clear_has_uptime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotInfo::clear_uptime() {
  uptime_ = GOOGLE_ULONGLONG(0);
  clear_has_uptime();
}
inline ::google::protobuf::uint64 RobotInfo::uptime() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotInfo.uptime)
  return uptime_;
}
inline void RobotInfo::set_uptime(::google::protobuf::uint64 value) {
  set_has_uptime();
  uptime_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotInfo.uptime)
}

// optional string filepath = 3;
inline bool RobotInfo::has_filepath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotInfo::set_has_filepath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotInfo::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotInfo::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& RobotInfo::filepath() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotInfo.filepath)
  return *filepath_;
}
inline void RobotInfo::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set:eos.sdk.RobotInfo.filepath)
}
inline void RobotInfo::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.sdk.RobotInfo.filepath)
}
inline void RobotInfo::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.sdk.RobotInfo.filepath)
}
inline ::std::string* RobotInfo::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.sdk.RobotInfo.filepath)
  return filepath_;
}
inline ::std::string* RobotInfo::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RobotInfo::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.sdk.RobotInfo.filepath)
}

// optional string robot_type = 4;
inline bool RobotInfo::has_robot_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotInfo::set_has_robot_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotInfo::clear_has_robot_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotInfo::clear_robot_type() {
  if (robot_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    robot_type_->clear();
  }
  clear_has_robot_type();
}
inline const ::std::string& RobotInfo::robot_type() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotInfo.robot_type)
  return *robot_type_;
}
inline void RobotInfo::set_robot_type(const ::std::string& value) {
  set_has_robot_type();
  if (robot_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    robot_type_ = new ::std::string;
  }
  robot_type_->assign(value);
  // @@protoc_insertion_point(field_set:eos.sdk.RobotInfo.robot_type)
}
inline void RobotInfo::set_robot_type(const char* value) {
  set_has_robot_type();
  if (robot_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    robot_type_ = new ::std::string;
  }
  robot_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.sdk.RobotInfo.robot_type)
}
inline void RobotInfo::set_robot_type(const char* value, size_t size) {
  set_has_robot_type();
  if (robot_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    robot_type_ = new ::std::string;
  }
  robot_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.sdk.RobotInfo.robot_type)
}
inline ::std::string* RobotInfo::mutable_robot_type() {
  set_has_robot_type();
  if (robot_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    robot_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.sdk.RobotInfo.robot_type)
  return robot_type_;
}
inline ::std::string* RobotInfo::release_robot_type() {
  clear_has_robot_type();
  if (robot_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = robot_type_;
    robot_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RobotInfo::set_allocated_robot_type(::std::string* robot_type) {
  if (robot_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete robot_type_;
  }
  if (robot_type) {
    set_has_robot_type();
    robot_type_ = robot_type;
  } else {
    clear_has_robot_type();
    robot_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.sdk.RobotInfo.robot_type)
}

// repeated .eos.sdk.Camera camera = 5;
inline int RobotInfo::camera_size() const {
  return camera_.size();
}
inline void RobotInfo::clear_camera() {
  camera_.Clear();
}
inline const ::eos::sdk::Camera& RobotInfo::camera(int index) const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotInfo.camera)
  return camera_.Get(index);
}
inline ::eos::sdk::Camera* RobotInfo::mutable_camera(int index) {
  // @@protoc_insertion_point(field_mutable:eos.sdk.RobotInfo.camera)
  return camera_.Mutable(index);
}
inline ::eos::sdk::Camera* RobotInfo::add_camera() {
  // @@protoc_insertion_point(field_add:eos.sdk.RobotInfo.camera)
  return camera_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eos::sdk::Camera >&
RobotInfo::camera() const {
  // @@protoc_insertion_point(field_list:eos.sdk.RobotInfo.camera)
  return camera_;
}
inline ::google::protobuf::RepeatedPtrField< ::eos::sdk::Camera >*
RobotInfo::mutable_camera() {
  // @@protoc_insertion_point(field_mutable_list:eos.sdk.RobotInfo.camera)
  return &camera_;
}

// -------------------------------------------------------------------

// JoystickCommand

// required float x = 1;
inline bool JoystickCommand::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoystickCommand::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoystickCommand::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoystickCommand::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float JoystickCommand::x() const {
  // @@protoc_insertion_point(field_get:eos.sdk.JoystickCommand.x)
  return x_;
}
inline void JoystickCommand::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.JoystickCommand.x)
}

// required float y = 2;
inline bool JoystickCommand::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoystickCommand::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoystickCommand::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoystickCommand::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float JoystickCommand::y() const {
  // @@protoc_insertion_point(field_get:eos.sdk.JoystickCommand.y)
  return y_;
}
inline void JoystickCommand::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.JoystickCommand.y)
}

// optional bool super = 3 [default = false];
inline bool JoystickCommand::has_super() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoystickCommand::set_has_super() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoystickCommand::clear_has_super() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoystickCommand::clear_super() {
  super_ = false;
  clear_has_super();
}
inline bool JoystickCommand::super() const {
  // @@protoc_insertion_point(field_get:eos.sdk.JoystickCommand.super)
  return super_;
}
inline void JoystickCommand::set_super(bool value) {
  set_has_super();
  super_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.JoystickCommand.super)
}

// -------------------------------------------------------------------

// Turn

// required .eos.sdk.Turn.Sens sens = 1 [default = LEFT];
inline bool Turn::has_sens() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Turn::set_has_sens() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Turn::clear_has_sens() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Turn::clear_sens() {
  sens_ = 0;
  clear_has_sens();
}
inline ::eos::sdk::Turn_Sens Turn::sens() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Turn.sens)
  return static_cast< ::eos::sdk::Turn_Sens >(sens_);
}
inline void Turn::set_sens(::eos::sdk::Turn_Sens value) {
  assert(::eos::sdk::Turn_Sens_IsValid(value));
  set_has_sens();
  sens_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.Turn.sens)
}

// -------------------------------------------------------------------

// Stop

// -------------------------------------------------------------------

// SetRobotMode

// required .eos.sdk.SetRobotMode.Type type = 1 [default = AUTOMATIC];
inline bool SetRobotMode::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetRobotMode::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetRobotMode::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetRobotMode::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::eos::sdk::SetRobotMode_Type SetRobotMode::type() const {
  // @@protoc_insertion_point(field_get:eos.sdk.SetRobotMode.type)
  return static_cast< ::eos::sdk::SetRobotMode_Type >(type_);
}
inline void SetRobotMode::set_type(::eos::sdk::SetRobotMode_Type value) {
  assert(::eos::sdk::SetRobotMode_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.SetRobotMode.type)
}

// -------------------------------------------------------------------

// MoveTo

// required int64 x = 1;
inline bool MoveTo::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveTo::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveTo::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveTo::clear_x() {
  x_ = GOOGLE_LONGLONG(0);
  clear_has_x();
}
inline ::google::protobuf::int64 MoveTo::x() const {
  // @@protoc_insertion_point(field_get:eos.sdk.MoveTo.x)
  return x_;
}
inline void MoveTo::set_x(::google::protobuf::int64 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.MoveTo.x)
}

// required int64 y = 2;
inline bool MoveTo::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveTo::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveTo::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveTo::clear_y() {
  y_ = GOOGLE_LONGLONG(0);
  clear_has_y();
}
inline ::google::protobuf::int64 MoveTo::y() const {
  // @@protoc_insertion_point(field_get:eos.sdk.MoveTo.y)
  return y_;
}
inline void MoveTo::set_y(::google::protobuf::int64 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.MoveTo.y)
}

// required double theta = 3;
inline bool MoveTo::has_theta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveTo::set_has_theta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveTo::clear_has_theta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveTo::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double MoveTo::theta() const {
  // @@protoc_insertion_point(field_get:eos.sdk.MoveTo.theta)
  return theta_;
}
inline void MoveTo::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.MoveTo.theta)
}

// -------------------------------------------------------------------

// Hooter

// required bool active = 1;
inline bool Hooter::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hooter::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hooter::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hooter::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool Hooter::active() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Hooter.active)
  return active_;
}
inline void Hooter::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.Hooter.active)
}

// -------------------------------------------------------------------

// ToggleCharging

// required bool active = 1;
inline bool ToggleCharging::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ToggleCharging::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ToggleCharging::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ToggleCharging::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool ToggleCharging::active() const {
  // @@protoc_insertion_point(field_get:eos.sdk.ToggleCharging.active)
  return active_;
}
inline void ToggleCharging::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.ToggleCharging.active)
}

// -------------------------------------------------------------------

// ToggleComponentsPowerSupply

// required bool active = 1;
inline bool ToggleComponentsPowerSupply::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ToggleComponentsPowerSupply::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ToggleComponentsPowerSupply::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ToggleComponentsPowerSupply::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool ToggleComponentsPowerSupply::active() const {
  // @@protoc_insertion_point(field_get:eos.sdk.ToggleComponentsPowerSupply.active)
  return active_;
}
inline void ToggleComponentsPowerSupply::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.ToggleComponentsPowerSupply.active)
}

// -------------------------------------------------------------------

// RobotPosition

// required int64 x = 1;
inline bool RobotPosition::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotPosition::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotPosition::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotPosition::clear_x() {
  x_ = GOOGLE_LONGLONG(0);
  clear_has_x();
}
inline ::google::protobuf::int64 RobotPosition::x() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotPosition.x)
  return x_;
}
inline void RobotPosition::set_x(::google::protobuf::int64 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotPosition.x)
}

// required int64 y = 2;
inline bool RobotPosition::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotPosition::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotPosition::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotPosition::clear_y() {
  y_ = GOOGLE_LONGLONG(0);
  clear_has_y();
}
inline ::google::protobuf::int64 RobotPosition::y() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotPosition.y)
  return y_;
}
inline void RobotPosition::set_y(::google::protobuf::int64 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotPosition.y)
}

// required double theta = 3;
inline bool RobotPosition::has_theta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotPosition::set_has_theta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotPosition::clear_has_theta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotPosition::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double RobotPosition::theta() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotPosition.theta)
  return theta_;
}
inline void RobotPosition::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotPosition.theta)
}

// -------------------------------------------------------------------

// RobotVelocity

// required float linear = 1;
inline bool RobotVelocity::has_linear() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotVelocity::set_has_linear() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotVelocity::clear_has_linear() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotVelocity::clear_linear() {
  linear_ = 0;
  clear_has_linear();
}
inline float RobotVelocity::linear() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotVelocity.linear)
  return linear_;
}
inline void RobotVelocity::set_linear(float value) {
  set_has_linear();
  linear_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotVelocity.linear)
}

// required float angular = 2;
inline bool RobotVelocity::has_angular() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotVelocity::set_has_angular() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotVelocity::clear_has_angular() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotVelocity::clear_angular() {
  angular_ = 0;
  clear_has_angular();
}
inline float RobotVelocity::angular() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotVelocity.angular)
  return angular_;
}
inline void RobotVelocity::set_angular(float value) {
  set_has_angular();
  angular_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotVelocity.angular)
}

// -------------------------------------------------------------------

// RobotState

// required .eos.sdk.RobotState.Type type = 1;
inline bool RobotState::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotState::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotState::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotState::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::eos::sdk::RobotState_Type RobotState::type() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotState.type)
  return static_cast< ::eos::sdk::RobotState_Type >(type_);
}
inline void RobotState::set_type(::eos::sdk::RobotState_Type value) {
  assert(::eos::sdk::RobotState_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotState.type)
}

// -------------------------------------------------------------------

// HardwareIssue

// required .eos.sdk.HardwareIssue.Issue issue = 1;
inline bool HardwareIssue::has_issue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HardwareIssue::set_has_issue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HardwareIssue::clear_has_issue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HardwareIssue::clear_issue() {
  issue_ = 0;
  clear_has_issue();
}
inline ::eos::sdk::HardwareIssue_Issue HardwareIssue::issue() const {
  // @@protoc_insertion_point(field_get:eos.sdk.HardwareIssue.issue)
  return static_cast< ::eos::sdk::HardwareIssue_Issue >(issue_);
}
inline void HardwareIssue::set_issue(::eos::sdk::HardwareIssue_Issue value) {
  assert(::eos::sdk::HardwareIssue_Issue_IsValid(value));
  set_has_issue();
  issue_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.HardwareIssue.issue)
}

// -------------------------------------------------------------------

// Alarm

// required uint32 id = 1;
inline bool Alarm::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Alarm::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Alarm::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Alarm::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Alarm::id() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Alarm.id)
  return id_;
}
inline void Alarm::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.Alarm.id)
}

// required uint32 x = 2;
inline bool Alarm::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Alarm::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Alarm::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Alarm::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 Alarm::x() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Alarm.x)
  return x_;
}
inline void Alarm::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.Alarm.x)
}

// required uint32 y = 3;
inline bool Alarm::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Alarm::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Alarm::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Alarm::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 Alarm::y() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Alarm.y)
  return y_;
}
inline void Alarm::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.Alarm.y)
}

// required uint32 distance = 4;
inline bool Alarm::has_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Alarm::set_has_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Alarm::clear_has_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Alarm::clear_distance() {
  distance_ = 0u;
  clear_has_distance();
}
inline ::google::protobuf::uint32 Alarm::distance() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Alarm.distance)
  return distance_;
}
inline void Alarm::set_distance(::google::protobuf::uint32 value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.Alarm.distance)
}

// required .eos.sdk.Alarm.Type type = 5;
inline bool Alarm::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Alarm::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Alarm::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Alarm::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::eos::sdk::Alarm_Type Alarm::type() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Alarm.type)
  return static_cast< ::eos::sdk::Alarm_Type >(type_);
}
inline void Alarm::set_type(::eos::sdk::Alarm_Type value) {
  assert(::eos::sdk::Alarm_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.Alarm.type)
}

// required .eos.sdk.Alarm.Status status = 6;
inline bool Alarm::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Alarm::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Alarm::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Alarm::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::eos::sdk::Alarm_Status Alarm::status() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Alarm.status)
  return static_cast< ::eos::sdk::Alarm_Status >(status_);
}
inline void Alarm::set_status(::eos::sdk::Alarm_Status value) {
  assert(::eos::sdk::Alarm_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.Alarm.status)
}

// -------------------------------------------------------------------

// AlarmUpdate

// required int32 id = 1;
inline bool AlarmUpdate::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlarmUpdate::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlarmUpdate::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlarmUpdate::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AlarmUpdate::id() const {
  // @@protoc_insertion_point(field_get:eos.sdk.AlarmUpdate.id)
  return id_;
}
inline void AlarmUpdate::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.AlarmUpdate.id)
}

// required uint32 x = 2;
inline bool AlarmUpdate::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlarmUpdate::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlarmUpdate::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlarmUpdate::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 AlarmUpdate::x() const {
  // @@protoc_insertion_point(field_get:eos.sdk.AlarmUpdate.x)
  return x_;
}
inline void AlarmUpdate::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.AlarmUpdate.x)
}

// required uint32 y = 3;
inline bool AlarmUpdate::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AlarmUpdate::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AlarmUpdate::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AlarmUpdate::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 AlarmUpdate::y() const {
  // @@protoc_insertion_point(field_get:eos.sdk.AlarmUpdate.y)
  return y_;
}
inline void AlarmUpdate::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.AlarmUpdate.y)
}

// required uint32 distance = 4;
inline bool AlarmUpdate::has_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AlarmUpdate::set_has_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AlarmUpdate::clear_has_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AlarmUpdate::clear_distance() {
  distance_ = 0u;
  clear_has_distance();
}
inline ::google::protobuf::uint32 AlarmUpdate::distance() const {
  // @@protoc_insertion_point(field_get:eos.sdk.AlarmUpdate.distance)
  return distance_;
}
inline void AlarmUpdate::set_distance(::google::protobuf::uint32 value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.AlarmUpdate.distance)
}

// -------------------------------------------------------------------

// BatteryState

// required .eos.sdk.BatteryState.State state = 1;
inline bool BatteryState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatteryState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatteryState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatteryState::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::eos::sdk::BatteryState_State BatteryState::state() const {
  // @@protoc_insertion_point(field_get:eos.sdk.BatteryState.state)
  return static_cast< ::eos::sdk::BatteryState_State >(state_);
}
inline void BatteryState::set_state(::eos::sdk::BatteryState_State value) {
  assert(::eos::sdk::BatteryState_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.BatteryState.state)
}

// required float level = 2;
inline bool BatteryState::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatteryState::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatteryState::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatteryState::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline float BatteryState::level() const {
  // @@protoc_insertion_point(field_get:eos.sdk.BatteryState.level)
  return level_;
}
inline void BatteryState::set_level(float value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.BatteryState.level)
}

// required float tension = 3;
inline bool BatteryState::has_tension() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BatteryState::set_has_tension() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BatteryState::clear_has_tension() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BatteryState::clear_tension() {
  tension_ = 0;
  clear_has_tension();
}
inline float BatteryState::tension() const {
  // @@protoc_insertion_point(field_get:eos.sdk.BatteryState.tension)
  return tension_;
}
inline void BatteryState::set_tension(float value) {
  set_has_tension();
  tension_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.BatteryState.tension)
}

// -------------------------------------------------------------------

// LaserShot

// repeated float x_array = 1;
inline int LaserShot::x_array_size() const {
  return x_array_.size();
}
inline void LaserShot::clear_x_array() {
  x_array_.Clear();
}
inline float LaserShot::x_array(int index) const {
  // @@protoc_insertion_point(field_get:eos.sdk.LaserShot.x_array)
  return x_array_.Get(index);
}
inline void LaserShot::set_x_array(int index, float value) {
  x_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:eos.sdk.LaserShot.x_array)
}
inline void LaserShot::add_x_array(float value) {
  x_array_.Add(value);
  // @@protoc_insertion_point(field_add:eos.sdk.LaserShot.x_array)
}
inline const ::google::protobuf::RepeatedField< float >&
LaserShot::x_array() const {
  // @@protoc_insertion_point(field_list:eos.sdk.LaserShot.x_array)
  return x_array_;
}
inline ::google::protobuf::RepeatedField< float >*
LaserShot::mutable_x_array() {
  // @@protoc_insertion_point(field_mutable_list:eos.sdk.LaserShot.x_array)
  return &x_array_;
}

// repeated float y_array = 2;
inline int LaserShot::y_array_size() const {
  return y_array_.size();
}
inline void LaserShot::clear_y_array() {
  y_array_.Clear();
}
inline float LaserShot::y_array(int index) const {
  // @@protoc_insertion_point(field_get:eos.sdk.LaserShot.y_array)
  return y_array_.Get(index);
}
inline void LaserShot::set_y_array(int index, float value) {
  y_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:eos.sdk.LaserShot.y_array)
}
inline void LaserShot::add_y_array(float value) {
  y_array_.Add(value);
  // @@protoc_insertion_point(field_add:eos.sdk.LaserShot.y_array)
}
inline const ::google::protobuf::RepeatedField< float >&
LaserShot::y_array() const {
  // @@protoc_insertion_point(field_list:eos.sdk.LaserShot.y_array)
  return y_array_;
}
inline ::google::protobuf::RepeatedField< float >*
LaserShot::mutable_y_array() {
  // @@protoc_insertion_point(field_mutable_list:eos.sdk.LaserShot.y_array)
  return &y_array_;
}

// -------------------------------------------------------------------

// RobotMonitoring

// optional uint64 current_score = 3;
inline bool RobotMonitoring::has_current_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotMonitoring::set_has_current_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotMonitoring::clear_has_current_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotMonitoring::clear_current_score() {
  current_score_ = GOOGLE_ULONGLONG(0);
  clear_has_current_score();
}
inline ::google::protobuf::uint64 RobotMonitoring::current_score() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotMonitoring.current_score)
  return current_score_;
}
inline void RobotMonitoring::set_current_score(::google::protobuf::uint64 value) {
  set_has_current_score();
  current_score_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotMonitoring.current_score)
}

// optional uint64 min_score = 4;
inline bool RobotMonitoring::has_min_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotMonitoring::set_has_min_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotMonitoring::clear_has_min_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotMonitoring::clear_min_score() {
  min_score_ = GOOGLE_ULONGLONG(0);
  clear_has_min_score();
}
inline ::google::protobuf::uint64 RobotMonitoring::min_score() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotMonitoring.min_score)
  return min_score_;
}
inline void RobotMonitoring::set_min_score(::google::protobuf::uint64 value) {
  set_has_min_score();
  min_score_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotMonitoring.min_score)
}

// optional uint64 max_score = 5;
inline bool RobotMonitoring::has_max_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotMonitoring::set_has_max_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotMonitoring::clear_has_max_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotMonitoring::clear_max_score() {
  max_score_ = GOOGLE_ULONGLONG(0);
  clear_has_max_score();
}
inline ::google::protobuf::uint64 RobotMonitoring::max_score() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotMonitoring.max_score)
  return max_score_;
}
inline void RobotMonitoring::set_max_score(::google::protobuf::uint64 value) {
  set_has_max_score();
  max_score_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotMonitoring.max_score)
}

// optional uint64 avg_score = 6;
inline bool RobotMonitoring::has_avg_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotMonitoring::set_has_avg_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotMonitoring::clear_has_avg_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotMonitoring::clear_avg_score() {
  avg_score_ = GOOGLE_ULONGLONG(0);
  clear_has_avg_score();
}
inline ::google::protobuf::uint64 RobotMonitoring::avg_score() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotMonitoring.avg_score)
  return avg_score_;
}
inline void RobotMonitoring::set_avg_score(::google::protobuf::uint64 value) {
  set_has_avg_score();
  avg_score_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotMonitoring.avg_score)
}

// optional uint64 switch_to_mapping = 7;
inline bool RobotMonitoring::has_switch_to_mapping() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RobotMonitoring::set_has_switch_to_mapping() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RobotMonitoring::clear_has_switch_to_mapping() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RobotMonitoring::clear_switch_to_mapping() {
  switch_to_mapping_ = GOOGLE_ULONGLONG(0);
  clear_has_switch_to_mapping();
}
inline ::google::protobuf::uint64 RobotMonitoring::switch_to_mapping() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotMonitoring.switch_to_mapping)
  return switch_to_mapping_;
}
inline void RobotMonitoring::set_switch_to_mapping(::google::protobuf::uint64 value) {
  set_has_switch_to_mapping();
  switch_to_mapping_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotMonitoring.switch_to_mapping)
}

// optional uint64 switch_to_localization = 8;
inline bool RobotMonitoring::has_switch_to_localization() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RobotMonitoring::set_has_switch_to_localization() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RobotMonitoring::clear_has_switch_to_localization() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RobotMonitoring::clear_switch_to_localization() {
  switch_to_localization_ = GOOGLE_ULONGLONG(0);
  clear_has_switch_to_localization();
}
inline ::google::protobuf::uint64 RobotMonitoring::switch_to_localization() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotMonitoring.switch_to_localization)
  return switch_to_localization_;
}
inline void RobotMonitoring::set_switch_to_localization(::google::protobuf::uint64 value) {
  set_has_switch_to_localization();
  switch_to_localization_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotMonitoring.switch_to_localization)
}

// optional uint64 switch_to_relocalization = 9;
inline bool RobotMonitoring::has_switch_to_relocalization() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RobotMonitoring::set_has_switch_to_relocalization() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RobotMonitoring::clear_has_switch_to_relocalization() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RobotMonitoring::clear_switch_to_relocalization() {
  switch_to_relocalization_ = GOOGLE_ULONGLONG(0);
  clear_has_switch_to_relocalization();
}
inline ::google::protobuf::uint64 RobotMonitoring::switch_to_relocalization() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotMonitoring.switch_to_relocalization)
  return switch_to_relocalization_;
}
inline void RobotMonitoring::set_switch_to_relocalization(::google::protobuf::uint64 value) {
  set_has_switch_to_relocalization();
  switch_to_relocalization_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotMonitoring.switch_to_relocalization)
}

// optional .eos.sdk.LaserShot laser = 10;
inline bool RobotMonitoring::has_laser() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RobotMonitoring::set_has_laser() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RobotMonitoring::clear_has_laser() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RobotMonitoring::clear_laser() {
  if (laser_ != NULL) laser_->::eos::sdk::LaserShot::Clear();
  clear_has_laser();
}
inline const ::eos::sdk::LaserShot& RobotMonitoring::laser() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotMonitoring.laser)
  return laser_ != NULL ? *laser_ : *default_instance_->laser_;
}
inline ::eos::sdk::LaserShot* RobotMonitoring::mutable_laser() {
  set_has_laser();
  if (laser_ == NULL) laser_ = new ::eos::sdk::LaserShot;
  // @@protoc_insertion_point(field_mutable:eos.sdk.RobotMonitoring.laser)
  return laser_;
}
inline ::eos::sdk::LaserShot* RobotMonitoring::release_laser() {
  clear_has_laser();
  ::eos::sdk::LaserShot* temp = laser_;
  laser_ = NULL;
  return temp;
}
inline void RobotMonitoring::set_allocated_laser(::eos::sdk::LaserShot* laser) {
  delete laser_;
  laser_ = laser;
  if (laser) {
    set_has_laser();
  } else {
    clear_has_laser();
  }
  // @@protoc_insertion_point(field_set_allocated:eos.sdk.RobotMonitoring.laser)
}

// -------------------------------------------------------------------

// ScoresThreshold

// required uint64 switch_to_mapping = 1;
inline bool ScoresThreshold::has_switch_to_mapping() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScoresThreshold::set_has_switch_to_mapping() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScoresThreshold::clear_has_switch_to_mapping() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScoresThreshold::clear_switch_to_mapping() {
  switch_to_mapping_ = GOOGLE_ULONGLONG(0);
  clear_has_switch_to_mapping();
}
inline ::google::protobuf::uint64 ScoresThreshold::switch_to_mapping() const {
  // @@protoc_insertion_point(field_get:eos.sdk.ScoresThreshold.switch_to_mapping)
  return switch_to_mapping_;
}
inline void ScoresThreshold::set_switch_to_mapping(::google::protobuf::uint64 value) {
  set_has_switch_to_mapping();
  switch_to_mapping_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.ScoresThreshold.switch_to_mapping)
}

// required uint64 switch_to_localization = 2;
inline bool ScoresThreshold::has_switch_to_localization() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScoresThreshold::set_has_switch_to_localization() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScoresThreshold::clear_has_switch_to_localization() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScoresThreshold::clear_switch_to_localization() {
  switch_to_localization_ = GOOGLE_ULONGLONG(0);
  clear_has_switch_to_localization();
}
inline ::google::protobuf::uint64 ScoresThreshold::switch_to_localization() const {
  // @@protoc_insertion_point(field_get:eos.sdk.ScoresThreshold.switch_to_localization)
  return switch_to_localization_;
}
inline void ScoresThreshold::set_switch_to_localization(::google::protobuf::uint64 value) {
  set_has_switch_to_localization();
  switch_to_localization_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.ScoresThreshold.switch_to_localization)
}

// required uint64 switch_to_relocalization = 3;
inline bool ScoresThreshold::has_switch_to_relocalization() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScoresThreshold::set_has_switch_to_relocalization() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScoresThreshold::clear_has_switch_to_relocalization() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScoresThreshold::clear_switch_to_relocalization() {
  switch_to_relocalization_ = GOOGLE_ULONGLONG(0);
  clear_has_switch_to_relocalization();
}
inline ::google::protobuf::uint64 ScoresThreshold::switch_to_relocalization() const {
  // @@protoc_insertion_point(field_get:eos.sdk.ScoresThreshold.switch_to_relocalization)
  return switch_to_relocalization_;
}
inline void ScoresThreshold::set_switch_to_relocalization(::google::protobuf::uint64 value) {
  set_has_switch_to_relocalization();
  switch_to_relocalization_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.ScoresThreshold.switch_to_relocalization)
}

// -------------------------------------------------------------------

// ControlPatrolling

// required .eos.sdk.ControlPatrolling.ACTION action = 1;
inline bool ControlPatrolling::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControlPatrolling::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControlPatrolling::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControlPatrolling::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::eos::sdk::ControlPatrolling_ACTION ControlPatrolling::action() const {
  // @@protoc_insertion_point(field_get:eos.sdk.ControlPatrolling.action)
  return static_cast< ::eos::sdk::ControlPatrolling_ACTION >(action_);
}
inline void ControlPatrolling::set_action(::eos::sdk::ControlPatrolling_ACTION value) {
  assert(::eos::sdk::ControlPatrolling_ACTION_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.ControlPatrolling.action)
}

// required string patrol_name = 2;
inline bool ControlPatrolling::has_patrol_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControlPatrolling::set_has_patrol_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControlPatrolling::clear_has_patrol_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControlPatrolling::clear_patrol_name() {
  if (patrol_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrol_name_->clear();
  }
  clear_has_patrol_name();
}
inline const ::std::string& ControlPatrolling::patrol_name() const {
  // @@protoc_insertion_point(field_get:eos.sdk.ControlPatrolling.patrol_name)
  return *patrol_name_;
}
inline void ControlPatrolling::set_patrol_name(const ::std::string& value) {
  set_has_patrol_name();
  if (patrol_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrol_name_ = new ::std::string;
  }
  patrol_name_->assign(value);
  // @@protoc_insertion_point(field_set:eos.sdk.ControlPatrolling.patrol_name)
}
inline void ControlPatrolling::set_patrol_name(const char* value) {
  set_has_patrol_name();
  if (patrol_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrol_name_ = new ::std::string;
  }
  patrol_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.sdk.ControlPatrolling.patrol_name)
}
inline void ControlPatrolling::set_patrol_name(const char* value, size_t size) {
  set_has_patrol_name();
  if (patrol_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrol_name_ = new ::std::string;
  }
  patrol_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.sdk.ControlPatrolling.patrol_name)
}
inline ::std::string* ControlPatrolling::mutable_patrol_name() {
  set_has_patrol_name();
  if (patrol_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    patrol_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.sdk.ControlPatrolling.patrol_name)
  return patrol_name_;
}
inline ::std::string* ControlPatrolling::release_patrol_name() {
  clear_has_patrol_name();
  if (patrol_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = patrol_name_;
    patrol_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ControlPatrolling::set_allocated_patrol_name(::std::string* patrol_name) {
  if (patrol_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete patrol_name_;
  }
  if (patrol_name) {
    set_has_patrol_name();
    patrol_name_ = patrol_name;
  } else {
    clear_has_patrol_name();
    patrol_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.sdk.ControlPatrolling.patrol_name)
}

// required uint32 duration = 3;
inline bool ControlPatrolling::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControlPatrolling::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControlPatrolling::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControlPatrolling::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 ControlPatrolling::duration() const {
  // @@protoc_insertion_point(field_get:eos.sdk.ControlPatrolling.duration)
  return duration_;
}
inline void ControlPatrolling::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.ControlPatrolling.duration)
}

// -------------------------------------------------------------------

// EmergencyStop

// required bool active = 1;
inline bool EmergencyStop::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmergencyStop::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmergencyStop::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmergencyStop::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool EmergencyStop::active() const {
  // @@protoc_insertion_point(field_get:eos.sdk.EmergencyStop.active)
  return active_;
}
inline void EmergencyStop::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.EmergencyStop.active)
}

// -------------------------------------------------------------------

// DynamicObstacle

// required bool active = 1;
inline bool DynamicObstacle::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DynamicObstacle::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DynamicObstacle::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DynamicObstacle::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool DynamicObstacle::active() const {
  // @@protoc_insertion_point(field_get:eos.sdk.DynamicObstacle.active)
  return active_;
}
inline void DynamicObstacle::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.DynamicObstacle.active)
}

// required uint32 x = 2;
inline bool DynamicObstacle::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DynamicObstacle::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DynamicObstacle::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DynamicObstacle::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 DynamicObstacle::x() const {
  // @@protoc_insertion_point(field_get:eos.sdk.DynamicObstacle.x)
  return x_;
}
inline void DynamicObstacle::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.DynamicObstacle.x)
}

// required uint32 y = 3;
inline bool DynamicObstacle::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DynamicObstacle::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DynamicObstacle::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DynamicObstacle::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 DynamicObstacle::y() const {
  // @@protoc_insertion_point(field_get:eos.sdk.DynamicObstacle.y)
  return y_;
}
inline void DynamicObstacle::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.DynamicObstacle.y)
}

// required uint32 radius = 4;
inline bool DynamicObstacle::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DynamicObstacle::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DynamicObstacle::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DynamicObstacle::clear_radius() {
  radius_ = 0u;
  clear_has_radius();
}
inline ::google::protobuf::uint32 DynamicObstacle::radius() const {
  // @@protoc_insertion_point(field_get:eos.sdk.DynamicObstacle.radius)
  return radius_;
}
inline void DynamicObstacle::set_radius(::google::protobuf::uint32 value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.DynamicObstacle.radius)
}

// -------------------------------------------------------------------

// ClearDynamicObstacles

// -------------------------------------------------------------------

// RobotSensor

// required string path = 1;
inline bool RobotSensor::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotSensor::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotSensor::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotSensor::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& RobotSensor::path() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotSensor.path)
  return *path_;
}
inline void RobotSensor::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:eos.sdk.RobotSensor.path)
}
inline void RobotSensor::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.sdk.RobotSensor.path)
}
inline void RobotSensor::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.sdk.RobotSensor.path)
}
inline ::std::string* RobotSensor::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.sdk.RobotSensor.path)
  return path_;
}
inline ::std::string* RobotSensor::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RobotSensor::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.sdk.RobotSensor.path)
}

// required .eos.sdk.RobotSensor.Type type = 2;
inline bool RobotSensor::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotSensor::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotSensor::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotSensor::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::eos::sdk::RobotSensor_Type RobotSensor::type() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotSensor.type)
  return static_cast< ::eos::sdk::RobotSensor_Type >(type_);
}
inline void RobotSensor::set_type(::eos::sdk::RobotSensor_Type value) {
  assert(::eos::sdk::RobotSensor_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotSensor.type)
}

// required string unit = 3;
inline bool RobotSensor::has_unit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotSensor::set_has_unit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotSensor::clear_has_unit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotSensor::clear_unit() {
  if (unit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_->clear();
  }
  clear_has_unit();
}
inline const ::std::string& RobotSensor::unit() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotSensor.unit)
  return *unit_;
}
inline void RobotSensor::set_unit(const ::std::string& value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
  // @@protoc_insertion_point(field_set:eos.sdk.RobotSensor.unit)
}
inline void RobotSensor::set_unit(const char* value) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.sdk.RobotSensor.unit)
}
inline void RobotSensor::set_unit(const char* value, size_t size) {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  unit_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.sdk.RobotSensor.unit)
}
inline ::std::string* RobotSensor::mutable_unit() {
  set_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    unit_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.sdk.RobotSensor.unit)
  return unit_;
}
inline ::std::string* RobotSensor::release_unit() {
  clear_has_unit();
  if (unit_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = unit_;
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RobotSensor::set_allocated_unit(::std::string* unit) {
  if (unit_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete unit_;
  }
  if (unit) {
    set_has_unit();
    unit_ = unit;
  } else {
    clear_has_unit();
    unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.sdk.RobotSensor.unit)
}

// required float value = 4;
inline bool RobotSensor::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotSensor::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotSensor::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotSensor::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float RobotSensor::value() const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotSensor.value)
  return value_;
}
inline void RobotSensor::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.RobotSensor.value)
}

// -------------------------------------------------------------------

// RobotSensors

// repeated .eos.sdk.RobotSensor sensors = 1;
inline int RobotSensors::sensors_size() const {
  return sensors_.size();
}
inline void RobotSensors::clear_sensors() {
  sensors_.Clear();
}
inline const ::eos::sdk::RobotSensor& RobotSensors::sensors(int index) const {
  // @@protoc_insertion_point(field_get:eos.sdk.RobotSensors.sensors)
  return sensors_.Get(index);
}
inline ::eos::sdk::RobotSensor* RobotSensors::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:eos.sdk.RobotSensors.sensors)
  return sensors_.Mutable(index);
}
inline ::eos::sdk::RobotSensor* RobotSensors::add_sensors() {
  // @@protoc_insertion_point(field_add:eos.sdk.RobotSensors.sensors)
  return sensors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eos::sdk::RobotSensor >&
RobotSensors::sensors() const {
  // @@protoc_insertion_point(field_list:eos.sdk.RobotSensors.sensors)
  return sensors_;
}
inline ::google::protobuf::RepeatedPtrField< ::eos::sdk::RobotSensor >*
RobotSensors::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:eos.sdk.RobotSensors.sensors)
  return &sensors_;
}

// -------------------------------------------------------------------

// NewMapAvailable

// -------------------------------------------------------------------

// CartoOrder

// required .eos.sdk.CartoOrder.Action action = 1;
inline bool CartoOrder::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartoOrder::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartoOrder::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartoOrder::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::eos::sdk::CartoOrder_Action CartoOrder::action() const {
  // @@protoc_insertion_point(field_get:eos.sdk.CartoOrder.action)
  return static_cast< ::eos::sdk::CartoOrder_Action >(action_);
}
inline void CartoOrder::set_action(::eos::sdk::CartoOrder_Action value) {
  assert(::eos::sdk::CartoOrder_Action_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.CartoOrder.action)
}

// optional float resolution = 2;
inline bool CartoOrder::has_resolution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartoOrder::set_has_resolution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartoOrder::clear_has_resolution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartoOrder::clear_resolution() {
  resolution_ = 0;
  clear_has_resolution();
}
inline float CartoOrder::resolution() const {
  // @@protoc_insertion_point(field_get:eos.sdk.CartoOrder.resolution)
  return resolution_;
}
inline void CartoOrder::set_resolution(float value) {
  set_has_resolution();
  resolution_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.CartoOrder.resolution)
}

// optional uint32 size = 3;
inline bool CartoOrder::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CartoOrder::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CartoOrder::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CartoOrder::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 CartoOrder::size() const {
  // @@protoc_insertion_point(field_get:eos.sdk.CartoOrder.size)
  return size_;
}
inline void CartoOrder::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.CartoOrder.size)
}

// -------------------------------------------------------------------

// CartoState

// required .eos.sdk.CartoState.State state = 1;
inline bool CartoState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CartoState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CartoState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CartoState::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::eos::sdk::CartoState_State CartoState::state() const {
  // @@protoc_insertion_point(field_get:eos.sdk.CartoState.state)
  return static_cast< ::eos::sdk::CartoState_State >(state_);
}
inline void CartoState::set_state(::eos::sdk::CartoState_State value) {
  assert(::eos::sdk::CartoState_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.CartoState.state)
}

// required .eos.sdk.CartoState.Result result = 2;
inline bool CartoState::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CartoState::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CartoState::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CartoState::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::eos::sdk::CartoState_Result CartoState::result() const {
  // @@protoc_insertion_point(field_get:eos.sdk.CartoState.result)
  return static_cast< ::eos::sdk::CartoState_Result >(result_);
}
inline void CartoState::set_result(::eos::sdk::CartoState_Result value) {
  assert(::eos::sdk::CartoState_Result_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.CartoState.result)
}

// required string description = 3;
inline bool CartoState::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CartoState::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CartoState::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CartoState::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CartoState::description() const {
  // @@protoc_insertion_point(field_get:eos.sdk.CartoState.description)
  return *description_;
}
inline void CartoState::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:eos.sdk.CartoState.description)
}
inline void CartoState::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:eos.sdk.CartoState.description)
}
inline void CartoState::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eos.sdk.CartoState.description)
}
inline ::std::string* CartoState::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:eos.sdk.CartoState.description)
  return description_;
}
inline ::std::string* CartoState::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CartoState::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:eos.sdk.CartoState.description)
}

// -------------------------------------------------------------------

// Version

// required uint64 value = 1 [default = 20161108];
inline bool Version::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Version::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Version::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Version::clear_value() {
  value_ = GOOGLE_ULONGLONG(20161108);
  clear_has_value();
}
inline ::google::protobuf::uint64 Version::value() const {
  // @@protoc_insertion_point(field_get:eos.sdk.Version.value)
  return value_;
}
inline void Version::set_value(::google::protobuf::uint64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:eos.sdk.Version.value)
}

// -------------------------------------------------------------------

// Reboot


// @@protoc_insertion_point(namespace_scope)

}  // namespace sdk
}  // namespace eos

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::eos::sdk::Protocol_Port> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::Protocol_Port>() {
  return ::eos::sdk::Protocol_Port_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::Camera_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::Camera_Type>() {
  return ::eos::sdk::Camera_Type_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::Turn_Sens> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::Turn_Sens>() {
  return ::eos::sdk::Turn_Sens_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::SetRobotMode_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::SetRobotMode_Type>() {
  return ::eos::sdk::SetRobotMode_Type_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::RobotState_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::RobotState_Type>() {
  return ::eos::sdk::RobotState_Type_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::HardwareIssue_Issue> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::HardwareIssue_Issue>() {
  return ::eos::sdk::HardwareIssue_Issue_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::Alarm_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::Alarm_Type>() {
  return ::eos::sdk::Alarm_Type_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::Alarm_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::Alarm_Status>() {
  return ::eos::sdk::Alarm_Status_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::BatteryState_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::BatteryState_State>() {
  return ::eos::sdk::BatteryState_State_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::ControlPatrolling_ACTION> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::ControlPatrolling_ACTION>() {
  return ::eos::sdk::ControlPatrolling_ACTION_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::RobotSensor_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::RobotSensor_Type>() {
  return ::eos::sdk::RobotSensor_Type_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::CartoOrder_Action> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::CartoOrder_Action>() {
  return ::eos::sdk::CartoOrder_Action_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::CartoState_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::CartoState_State>() {
  return ::eos::sdk::CartoState_State_descriptor();
}
template <> struct is_proto_enum< ::eos::sdk::CartoState_Result> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eos::sdk::CartoState_Result>() {
  return ::eos::sdk::CartoState_Result_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msgs_2eproto__INCLUDED
